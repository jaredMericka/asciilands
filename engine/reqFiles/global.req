<?php

// CAUTION!
// NEVER EDIT A REQ FILE!


/**
 * GLOSSARY:
 *
 * UIN		- User INteration
 * DIR		- DIRection
 * TPL		- Tile PLane
 * QS		- Quest Status
 * GND		- GeNDer
 * DMGDL	- DaMaGe DeLivery
 * DMG		- DaMaGe
 * DS		- Dude Stat
 * TEQT		- TEchniQue Type
 * TEQ		- TEchniQue
 * SPRI		- SPRIte Index
 * UPD		- UPDate index
 * SKLS		- SKiLl Slot
 * DRCT		- client DiReCTive (not used atm)
 * EQP		- EQuiPment type
 * TFI		- TransFormation Inventory type
 * SPSI		- SPeech SItuation
 * SEI		- Sprite Element Index
 * BHVK		- BeHaViour Key
 * TRG		- behaviour TRiGger
 * ICAT		- Item CATegory
 * FAC		- FACtion
 * INV		- sub-INVentory type
 * EOI		- Event Of Interst (to the quest checker)
 * WP		- Waypoint
 */

// Version
const VERSION = '0.2 &#x03b1;';

// URLs
const URL_GAME	= 'play.php';
const URL_INTRO	= 'index.php';
const URL_MAP	= 'minimap.php';

// Character dimensions
const CHAR_HEIGHT	= 13;
const CHAR_WIDTH	= 8;

// Line break character
const LINE_BREAK	= "\n";

// Width of side-wings
const WING_WIDTH	= 40;

// Fastest possible cooldown (important for controlling poll rate)
const MIN_COOLDOWN	= 0.2;

// Lowest possible durability for an item
const MIN_DURABILITY = 5;

// UI motification types
const UIN_CLICK					= 100;
const UIN_RIGHT_CLICK			= 200;

const UIN_CTRL_CLICK			= 110;
const UIN_CTRL_RIGHT_CLICK		= 210;

const UIN_ALT_CLICK				= 101;
const UIN_ALT_RIGHT_CLICK		= 201;

const UIN_CTRL_ALT_CLICK		= 111;
const UIN_CTRL_ALT_RIGHT_CLICK	= 211;

const UIN_TEXT					= 300;

// Ready time correction (keep an eye on this; it should be the minimum effective dose)
const READY_TIME_CORRECTION	= 0.001;

// View parameters
const DEFAULT_VIEW_SIZE		= 21;
const MAX_VIEW_SIZE			= 25;
const MIN_VIEW_SIZE			= 5;
const ACTION_AREA_RADIUS	= 15;

// Directions
const DIR_NORTH	= 111;
const DIR_SOUTH	= 222;
const DIR_WEST	= 333;
const DIR_EAST	= 444;

// Tile planes
const TPL_OPENGROUND	= 1;	// Player can move over this
const TPL_VERTICAL		= 2;	// Vertical faces (e.g., cliff faces, walls)
const TPL_LOWOBSTACLE	= 3;	// Something under the ground layer that can't be traversed (e.g., water, void)
const TPL_HIGHOBSTACLE	= 4;	// Something above the ground that can't be traversed (e.g., rocks, trees)
const TPL_WALL			= 5;	// Something that notching can traverse (e.g., inside the walls of caves, outside the walls in building interiors)
const TPL_LADDER		= 6;	// A ladder or something as easy to climb as a ladder. Players and humanoids can climb this by default.
const TPL_STAIRS		= 7;	// Stairs. Player and dudes can handle by default.

// Quest statuses
const QS_NOT_STARTED	= 0;
const QS_IN_PROGRESS	= 1;
const QS_COMPLETE		= 2;
const QS_FAILED			= 3;
const QS_ABANDONED		= 4;

// Headers
const HEADER_TILES			= 't';
const HEADER_SPRITES		= 's';
const HEADER_VIEW_HEIGHT	= 'vh';
const HEADER_VIEW_WIDTH		= 'vw';
const HEADER_NEXTFRAME		= 'n';

// Damage deliveries
const DMGDL_BLUNT	= 1000;
const DMGDL_POINT	= 1001;
const DMGDL_CUT		= 1002;
const DMGDL_MISSILE	= 1003;
const DMGDL_LIQUID	= 1004;
const DMGDL_VAPOUR	= 1005;
const DMGDL_PLASMA	= 1006;

// Damage types
const DMG_TRAUMA	= 1100;
const DMG_FIRE		= 1101;
const DMG_COLD		= 1102;
const DMG_ELECTRIC	= 1103;
const DMG_WATER		= 1104;
const DMG_POISON	= 1105;
const DMG_INFECTION	= 1106;

// Attack config types
const TEQT_MELEE		= 2001		;
const TEQT_RANGED		= 2002		;
const TEQT_MAGIC		= 2003		;

// Attack config channels
const TEQ_DAMAGE		= 2100		;
const TEQ_HIT_CHANCE		= 2101		;
const TEQ_CRIT_DAMAGE	= 2102		;
const TEQ_CRIT_CHANCE	= 2103		;
const TEQ_DEFENCE		= 2104		;
const TEQ_DODGE_CHANCE	= 2105		;

// Experimental TEQs
const TEQ_ATTACK_SPEED	= 2106		;
const TEQ_CONSISTENCY	= 2107		;

// Genders
const GND_MALE		= 0;
const GND_FEMALE	= 1;

// Dude Stats
	// Hidden
const DS_HANDICAP		= -1	;	// Applies a handicap to all stats with unaltered defaults
const DS_RANDOMISER		= -2	;	// Randomises all stats by this percentage

const DS_HP_MAX			= 2		;	// Max life
const DS_REGENERATION	= 3		;	// Life regenerated per second
const DS_EP_MAX			= 4		;	// Max energy
const DS_RECHARGE		= 5		;	// Energy regenerated per second

const DS_LUCK			= 7		;	// Luck

const DS_EXPERIENCE		= 10	;	// Experience

const DS_ATTACKSPEED	= 53	;	// Attack interval

const DS_SPEED			= 50	;	// Movement speed
const DS_SPEED_FAST		= 51	;	// Movement speed (fast e.g., for chasing)

const DS_DAMAGE			= TEQ_DAMAGE		;	// Final multiplier of damage
const DS_HIT_CHANCE		= TEQ_HIT_CHANCE	;	// Final multiplier of chance to hit
const DS_CRIT_DAMAGE	= TEQ_CRIT_DAMAGE	;	// Final multiplier of crit damage
const DS_CRIT_CHANCE	= TEQ_CRIT_CHANCE	;	// Final multiplier of crit chance
const DS_DEFENCE		= TEQ_DEFENCE		;	// Final multiplier of defence
const DS_DODGE_CHANCE	= TEQ_DODGE_CHANCE	;	// Final multiplier of dodge chance

const DS_ATTACK_SPEED	= TEQ_ATTACK_SPEED	;	// Final multiplier of attack speed
const DS_CONSISTENCY	= TEQ_CONSISTENCY	;	// Final multiplier of consitency

const DS_ENERGYUSE		= 60		;	// Final multiplier of energy use

// These will hold percentages and those percentages will be added to the pool when damage of that type is calculated.
const DS_DMGDL_BLUNT	= DMGDL_BLUNT	;
const DS_DMGDL_POINT	= DMGDL_POINT	;
const DS_DMGDL_CUT		= DMGDL_CUT		;
const DS_DMGDL_MISSILE	= DMGDL_MISSILE	;
const DS_DMGDL_LIQUID	= DMGDL_LIQUID	;
const DS_DMGDL_VAPOUR	= DMGDL_VAPOUR	;
const DS_DMGDL_PLASMA	= DMGDL_PLASMA	;

const DS_DMG_TRAUMA		= DMG_TRAUMA	;
const DS_DMG_FIRE		= DMG_FIRE		;
const DS_DMG_COLD		= DMG_COLD		;
const DS_DMG_ELECTRIC	= DMG_ELECTRIC	;
const DS_DMG_WATER		= DMG_WATER		;
const DS_DMG_POISON		= DMG_POISON	;
const DS_DMG_INFECTION	= DMG_INFECTION	;

	// Exposed
		// Strength
const DS_STRENGTH		= 100	;	// Base strength stat
const DS_FORCE			= 101	;	// Increases damage of melee damage
const DS_RESILIENCE		= 102	;	// Decreases incoming physical damage
const DS_CONTROL		= 103	;	// Reduces random aspects of physical activities

const DS_INERTIA		= 150	;	// Makes for long swings. May affect chance to hit or crit chance
const DS_RECOVERY		= 151	;	// Increases effect of healing actions

		// Agility
const DS_AGILITY		= 200	;	// Movement stuff
const DS_DEXTERITY		= 201	;	// Hit chance
const DS_EVASIVENESS	= 202	;	// Dodge chance
const DS_FINESSE		= 203	;	// Increases the positive aspects of agility (increases reputation?)

const DS_BALANCE		= 250	;	// Affects dodging and reduces knock-back, may stop a dodge from delaying next attack
const DS_REACH			= 251	;	// Affects dodging and reduces knock-back, may stop a dodge from delaying next attack

		// Magic
const DS_MAGIC			= 300	;	// Base Magic stat
const DS_DISRUPTION		= 301	;	// Power of the magic you cast
const DS_DISCIPLINE		= 302	;	// Reduces the strong random aspects of the magic you cast
const DS_FOCUS			= 303	;	// Increases general strength of magic effects

const DS_INSANITY		= 350	;	// Greatly increases power of magic, moderately increases random aspect of magic.

		// Social
const DS_CHARISMA		= 400	;	// Affects how people treat you
const DS_REPUTATION		= 401	;	// How impressed people are by you
const DS_NOTORIETY		= 402	;	// How afaid people are of you
const DS_FAME			= 403	;	// Odds of meeting someone who has heard of you

const DS_DISCOUNT		= 450	;	// Discounts when buying goods
const DS_BARGAINING		= 451	;	// Kinda like a "trading crit", a chance to recieve something for a substantial discount.
const DS_LEADERSHIP		= 452	;	// Affects effectiveness of non-summoned minions.

		// Intellect
const DS_INTELLECT		= 500	;	// Base intelligence stat
const DS_TENACITY		= 501	;	// Persistence, is admirable to others (increases reputation?)
const DS_KNOWLEDGE		= 502	;	// Unlocks additional details on general stuff
const DS_HEURISTICS		= 503	;	// Gives "gut-feelings", can be used to strengthen various effects of intellect (may work like an intel-crit)

const DS_JUDGEMENT		= 550	;	// May help with stuff like accuracy at a large distance
const DS_PRAXIS			= 551	;	// Increases experience gathering



// Sprite indexes
const SPRI_DEFAULT			= 0;
const SPRI_CORPSE			= 1;
const SPRI_MALE				= 2;
const SPRI_FEMALE			= 3;
const SPRI_MALE_CORPSE		= 4;
const SPRI_FEMALE_CORPSE	= 5;
const SPRI_ACTIVE			= 6;
const SPRI_INACTIVE			= 7;
const SPRI_OPEN				= 8;
const SPRI_CLOSED			= 9;
const SPRI_OVERSPRITE		= 10;
const SPRI_GEAR				= 11;
const SPRI_NORTH			= DIR_NORTH;	// 111
const SPRI_SOUTH			= DIR_SOUTH;	// 222
const SPRI_WEST				= DIR_WEST;		// 333
const SPRI_EAST				= DIR_EAST;		// 444

// AsObject layers
const LAYER_PLAYER		= 9999;
const LAYER_DOOR_CLOSED	= 9000;
const LAYER_DUDE		= 8000;
const LAYER_PROJECTILE	= 7000;
const LAYER_PUSHBLOCK	= 6000;
const LAYER_PORTAL		= 5000;
const LAYER_CHECKPOINT	= 4500;
const LAYER_SIGN		= 4000;
const LAYER_CHEST		= 3000;
const LAYER_COLLECTIBLE	= 2000;
const LAYER_DOOR_OPEN	= 1000;

const LAYER_EDITOR_MARK		= 100000;
const LAYER_EDITOR_PLAYER	= 200000;

// Update keys
// Update keys in capital letters are deployed first followed by update keys in lowercase.
const UPD_OVERLAY		= 'OL'	;
const UPD_JVS_KEYS		= 'JVK'	;
const UPD_PLAYER_SPRITE	= 'PS'	;
const UPD_SPRITE		= 'PE'	;

const UPD_REFRESHRATE	= 'rr'	;
const UPD_STATS			= 'st'	;
const UPD_PLAYER_STATUS	= 'pst'	;
const UPD_HP			= 'hp'	;
const UPD_EP			= 'ep'	;
const UPD_XP			= 'xp'	;
const UPD_BOONS			= 'bn'	;
const UPD_PLAYER_INFO	= 'inf'	;
const UPD_CONVERSATION	= 'cnv'	;
const UPD_COMMS			= 'com'	;
const UPD_RESPONSES		= 'rsp'	; // NYI
const UPD_ITEMS			= 'itm'	;
const UPD_MONEY			= 'mon'	;
const UPD_STATUS		= 'tus'	;
const UPD_TEXT			= 'txt'	;
const UPD_AVAILABLE		= 'avl'	;
const UPD_COMBAT		= 'cmb'	;
const UPD_ITEM_INFO		= 'itn'	;
const UPD_DMG_DEF		= 'dd'	;
const UPD_OPPONENT		= 'opp'	;
const UPD_QUESTS		= 'qst'	;
const UPD_QUESTS_C		= 'qcm'	;
const UPD_TASKS			= 'tsk'	;
const UPD_SKILLS		= 'skl'	;
const UPD_PASSIVES		= 'psv'	;
const UPD_SKILL_INFO	= 'ski'	;
const UPD_PASSIVE_INFO	= 'psi'	;
const UPD_BINDINGS		= 'bnd'	;
const UPD_TECHNIQUE		= 'teq'	;
const UPD_SOUNDS		= 'snd'	;
const UPD_INTERACTIONS	= 'int'	;

const UPD_EDITOR_SKILLS		= 'edsk';
const UPD_EDITOR_CLIPBOARD	= 'eclp';

// Skill slots
const SKLS_KEY_0		= 0;
const SKLS_KEY_1		= 1;
const SKLS_KEY_2		= 2;
const SKLS_KEY_3		= 3;
const SKLS_KEY_4		= 4;
const SKLS_KEY_5		= 5;
const SKLS_KEY_6		= 6;
const SKLS_KEY_7		= 7;
const SKLS_KEY_8		= 8;
const SKLS_KEY_9		= 9;
const SKLS_CLICK		= UIN_CLICK;
const SKLS_RIGHT_CLICK	= UIN_RIGHT_CLICK;

// Client directives
const DRCT_RELOAD		= 0;
const DRCT_RFSH_REND	= 1;

// Special case update bodies
const UPDB_CLEAR		= 'CLEAR';

// Equipment slots
const EQP_HEAD		= 'Head'		;
const EQP_CHEST		= 'Chest'		;
const EQP_BELT		= 'Belt'		;
const EQP_GLOVES	= 'Gloves'		;
const EQP_PANTS		= 'Pants'		;
const EQP_BOOTS		= 'Boots'		;
const EQP_CLOAK		= 'Cloak'		;
const EQP_SHOULDERS	= 'Shoulders'	;
const EQP_FAULD		= 'Fauld'		;
const EQP_WRISTS	= 'Wrists'		;

const EQP_NECKLACE	= 'Necklace'	;
const EQP_RING		= 'Ring'		;
const EQP_BANGLE	= 'Bangle'		;

const EQP_BANNER	= 'Banner'		;

const EQP_HAND		= 'Hand'		;
const EQP_OFFHAND	= 'Off-hand'	;

// Transformation types
const TFI_FIRE		= 1		;
const TFI_WATER		= 2		;
const TFI_FURNACE	= 3		;
const TFI_CRUSHER	= 4		;

// Speech Delay
const SPEECH_DELAY		= 1		;

// Speech Situations
const SPSI_GREETING		= 1		;
const SPSI_CONVERSING	= 2		;
const SPSI_SAYING_BYE	= 3		;

const SPSI_SELLING		= 10	;
const SPSI_BUYING		= 11	;
const SPSI_SELLING_NE	= 12	;

const SPSI_GIVING		= 13	;
const SPSI_TAKING		= 14	;

const SPSI_EXCHANGING	= 15	;

const SPSI_REPAIRING	= 16	;
const SPSI_REPAIRING_NE	= 17	;

const SPSI_FOLLOWING	= 20	;
const SPSI_WAITING		= 21	;

const SPSI_ATTACKING	= 30	;
const SPSI_MISSING		= 31	;
const SPSI_STRIKING		= 32	;
const SPSI_KILLING		= 33	;

const SPSI_DEFENDING	= 34	;
const SPSI_DEFLECTING	= 35	;
const SPSI_TAKING_HIT	= 36	;
const SPSI_DYING		= 37	;

const SPSI_ERROR		= -1	;


// Sprite Element Indexes
const SEI_TOP_L		= 0;
const SEI_TOP_M		= 1;
const SEI_TOP_R		= 2;
const SEI_BOTTOM_L	= 3;
const SEI_BOTTOM_M	= 4;
const SEI_BOTTOM_R	= 5;

// Behaviour keys
const BHVK_MOVEMENT		= 'mov'		;
const BHVK_SPEAK		= 'spk'		;
const BHVK_SHOWTEXT		= 'stx'		;
const BHVK_TELEPORT		= 'tlp'		;
const BHVK_TELEPORT_MOD	= 'tlpm'	;
const BHVK_PRIMARY		= 'prm'		;
const BHVK_PUSHABLE		= 'psh'		;
const BHVK_TEXT			= 'txt'		;
const BHVK_OVERLAY		= 'ovl'		;
const BHVK_TRANSACTION	= 'tns'		;
const BHVK_DAMAGE		= 'dmg'		;
const BHVK_DEATH		= 'dth'		;
const BHVK_CORPSE		= 'cps'		;

// Behaviour triggers
const TRG_ATTACK		= 'onAttack'	;
const TRG_MISS			= 'onMiss'		;
const TRG_STRIKE		= 'onStrike'	;
const TRG_KILL			= 'onKill'		;
const TRG_DEFEND		= 'onDefend'	;
const TRG_DEFLECT		= 'onDeflect'	;
const TRG_TAKE_HIT		= 'onTakeHit'	;
const TRG_DEATH			= 'onDeath'		;

const TRG_EQUIP			= 'onEquip'		;
const TRG_UNEQUIP		= 'onUnequip'	;
const TRG_MAP_CHANGE	= 'onMapChange'	;

const TRG_COLLECT		= 'onCollect'	;
const TRG_DROP			= 'onDrop'		;
const TRG_USE			= 'onUse'		;

const TRG_IDLE			= 'onIdle'		;
const TRG_COLLISION		= 'onCollision'	;
const TRG_REACTION		= 'onReaction'	;
const TRG_ENGAGE		= 'onEngage'	;
const TRG_DISENGAGE		= 'onDisengage'	;

const TRG_GAIN_ITEM		= 'onGainItem'	;
const TRG_LOSE_ITEM		= 'onLoseItem'	;

// Item Categories
const ICAT_MATERIAL		= 'Material';
const ICAT_KEY			= 'Key';
const ICAT_TEXT			= 'Text';
const ICAT_CONSUMABLE	= 'Consumable';
const ICAT_REMEDY		= 'Remedial';

const ICAT_EQUIP		= 'Equippable';
	const ICAT_WEAPON		= 'Weapon';
		const ICAT_SWORD		= 'Sword';
		const ICAT_AXE			= 'Axe';
		const ICAT_MACE			= 'Mace';
		const ICAT_HAMMER		= 'Hammer';
		const ICAT_POLEARM		= 'Polearm';
		const ICAT_SPEAR		= 'Spear';

	const ICAT_TOOL			= 'Tool';
		const ICAT_TORCH		= 'Torch';

	const ICAT_ARMOR		= 'Armor';
		const ICAT_HELMET		= 'Helmet';
		const ICAT_CHEST_ARMOR	= 'Chest Armour';

	const ICAT_CLOTHING		= 'Clothing';
		const ICAT_HAT			= 'Hat';
		const ICAT_JACKET		= 'Jacket';


// Factions
const FAC_PLAYER		= 0;
const FAC_ANIMAL		= 1;
const FAC_MONSTER		= 2;
const FAC_NPC_NEUTRAL	= 3;

// Inventory subtypes
const INV_QUEST			= 'Quest';
const INV_MATERIALS		= 'Materials';
const INV_POTIONS		= 'Potions';
const INV_KEYS			= 'Keys';
const INV_BANNERS		= 'Banners';

// Events of interest (used for quest triggers)
const EOI_INVENTORY		= 0;	// Change of inventory contents
const EOI_WALLET		= 1;	// Change of wallet contents
const EOI_ATTACK		= 2;	// Happens at the very end of an attack.		Send the attack
const EOI_ENGAGE_NPC	= 3;	// Happens when you chat to an NPC.				Send the NPC

// Maximum random integer used for calculating random things
define('RAND_MAX', getrandmax());

const EDITOR_FILL_MARKER	= 'X';	// EDITOR LINE

const WP_GRUB_SOUTH_COAST		= 0;
const WP_GRUB_TOWN				= 1;
const WP_EFFENDON_GROVE			= 2;

// THIS FILE ISN'T MADE REDUNDANT BY "_constantArrays.php"!
// That said, if you add something to build script that replaces
// one of these arrays, make sure you delete the array out of here
// so that we can keep tabs on exactly HOW useful this thing is.

$DIR_opposites = [
	DIR_NORTH	=> DIR_SOUTH	,
	DIR_SOUTH	=> DIR_NORTH	,
	DIR_EAST	=> DIR_WEST		,
	DIR_WEST	=> DIR_EAST		,
];

$DMGDL_constants =
[
	DMGDL_BLUNT		,
	DMGDL_POINT		,
	DMGDL_CUT		,
	DMGDL_MISSILE	,
	DMGDL_LIQUID	,
	DMGDL_VAPOUR	,
	DMGDL_PLASMA	,
];


$DMG_constants =
[
	DMG_TRAUMA		,
	DMG_FIRE		,
	DMG_COLD		,
	DMG_ELECTRIC	,
	DMG_WATER		,
	DMG_POISON		,
	DMG_INFECTION		,
];

$DS_colours =
[
	DS_STRENGTH		=>	'#c00',
	DS_AGILITY		=>	'#0c0',
	DS_MAGIC		=>	'#0cc',
	DS_CHARISMA		=>	'#c0c',
	DS_INTELLECT	=>	'#cc0',
];


$TRG_readable = [
	TRG_ATTACK		=> 'when you attack',
	TRG_MISS		=> 'when you miss',
	TRG_STRIKE		=> 'when you land a hit',
	TRG_KILL		=> 'when you make a kill',

	TRG_DEFEND		=> 'when you are attacked',
	TRG_DEFLECT		=> 'when you deflect an attack',
	TRG_TAKE_HIT	=> 'when you take a hit',
	TRG_DEATH		=> 'when you die',

	TRG_EQUIP		=> 'when equipped',
	TRG_UNEQUIP		=> 'when unequipped',
	TRG_MAP_CHANGE	=> 'when you change area',

	TRG_COLLECT		=> 'when collected',
	TRG_DROP		=> 'when dropped',
	TRG_USE			=> 'when used',

	TRG_IDLE		=> 'when idle',
	TRG_COLLISION	=> 'when it collides with something',
	TRG_REACTION	=> 'when interacted with',
	TRG_ENGAGE		=> 'when engaged',
	TRG_DISENGAGE	=> 'when disengaged',
];

$TRG_array = [
	TRG_ATTACK,
	TRG_MISS,
	TRG_STRIKE,
	TRG_KILL,

	TRG_DEFEND,
	TRG_DEFLECT,
	TRG_TAKE_HIT,
	TRG_DEATH,

	TRG_EQUIP,
	TRG_UNEQUIP,
	TRG_MAP_CHANGE,

	TRG_COLLECT,
	TRG_DROP,
	TRG_USE,

	TRG_IDLE,
	TRG_COLLISION,
	TRG_REACTION,
	TRG_ENGAGE,
	TRG_DISENGAGE,
];

// How does this thing work? Explain it when you know.

$FAC_standing = [
	FAC_PLAYER =>
	[
		FAC_MONSTER => -1,
		FAC_ANIMAL => -1,
	],

	FAC_ANIMAL =>
	[

	],

	FAC_MONSTER =>
	[
		FAC_ANIMAL => -1,
		FAC_PLAYER => -1,
		FAC_NPC_NEUTRAL => -1
	],

	FAC_NPC_NEUTRAL =>
	[

	]
];



// This is an auto-generated file. Don't mess with it.
// If changes must be made, they should be made to tools/buildScripts/createArrayBuilder.php

$DS_names = [
	DS_HANDICAP => 'handicap',
	DS_RANDOMISER => 'randomiser',
	DS_HP_MAX => 'HP max',
	DS_REGENERATION => 'regeneration',
	DS_EP_MAX => 'EP max',
	DS_RECHARGE => 'recharge',
	DS_LUCK => 'luck',
	DS_EXPERIENCE => 'experience',
	DS_ATTACKSPEED => 'attackspeed',
	DS_SPEED => 'speed',
	DS_SPEED_FAST => 'speed fast',
	DS_DAMAGE => 'damage',
	DS_HIT_CHANCE => 'hit_chance',
	DS_CRIT_DAMAGE => 'crit_damage',
	DS_CRIT_CHANCE => 'crit_chance',
	DS_DEFENCE => 'defence',
	DS_DODGE_CHANCE => 'dodge_chance',
	DS_ATTACK_SPEED => 'attack_speed',
	DS_CONSISTENCY => 'consistency',
	DS_ENERGYUSE => 'energyuse',
	DS_DMGDL_BLUNT => 'blunt attack strength',
	DS_DMGDL_POINT => 'point attack strngth',
	DS_DMGDL_CUT => 'cut attack strength',
	DS_DMGDL_MISSILE => 'missile attack strength',
	DS_DMGDL_LIQUID => 'liquid attack strength',
	DS_DMGDL_VAPOUR => 'vapour attack strength',
	DS_DMGDL_PLASMA => 'plasma attack strength',
	DS_DMG_TRAUMA => 'trauma damage',
	DS_DMG_FIRE => 'fire damage',
	DS_DMG_COLD => 'cold damage',
	DS_DMG_ELECTRIC => 'electric damage',
	DS_DMG_WATER => 'water damage',
	DS_DMG_POISON => 'poison damage',
	DS_DMG_INFECTION => 'infection damage',
	DS_STRENGTH => 'strength',
	DS_FORCE => 'force',
	DS_RESILIENCE => 'resilience',
	DS_CONTROL => 'control',
	DS_INERTIA => 'inertia',
	DS_RECOVERY => 'recovery',
	DS_AGILITY => 'agility',
	DS_DEXTERITY => 'dexterity',
	DS_EVASIVENESS => 'evasiveness',
	DS_FINESSE => 'finesse',
	DS_BALANCE => 'balance',
	DS_REACH => 'reach',
	DS_MAGIC => 'magic',
	DS_DISRUPTION => 'disruption',
	DS_DISCIPLINE => 'discipline',
	DS_FOCUS => 'focus',
	DS_INSANITY => 'insanity',
	DS_CHARISMA => 'charisma',
	DS_REPUTATION => 'reputation',
	DS_NOTORIETY => 'notoriety',
	DS_FAME => 'fame',
	DS_DISCOUNT => 'discount',
	DS_BARGAINING => 'bargaining',
	DS_LEADERSHIP => 'leadership',
	DS_INTELLECT => 'intellect',
	DS_TENACITY => 'tenacity',
	DS_KNOWLEDGE => 'knowledge',
	DS_HEURISTICS => 'heuristics',
	DS_JUDGEMENT => 'judgement',
	DS_PRAXIS => 'praxis',
];

$DS_defaults = [
	DS_HANDICAP => 1,
	DS_RANDOMISER => 5,
	DS_HP_MAX => 100,
	DS_REGENERATION => 0.1,
	DS_EP_MAX => 100,
	DS_RECHARGE => 1,
	DS_LUCK => 100,
	DS_EXPERIENCE => 100,
	DS_ATTACKSPEED => 1,
	DS_SPEED => 1,
	DS_SPEED_FAST => 0.4,
	DS_DAMAGE => 0,
	DS_HIT_CHANCE => 0,
	DS_CRIT_DAMAGE => 0,
	DS_CRIT_CHANCE => 0,
	DS_DEFENCE => 0,
	DS_DODGE_CHANCE => 0,
	DS_ATTACK_SPEED => 0,
	DS_CONSISTENCY => 0,
	DS_ENERGYUSE => 0,
	DS_DMGDL_BLUNT => 0,
	DS_DMGDL_POINT => 0,
	DS_DMGDL_CUT => 0,
	DS_DMGDL_MISSILE => 0,
	DS_DMGDL_LIQUID => 0,
	DS_DMGDL_VAPOUR => 0,
	DS_DMGDL_PLASMA => 0,
	DS_DMG_TRAUMA => 0,
	DS_DMG_FIRE => 0,
	DS_DMG_COLD => 0,
	DS_DMG_ELECTRIC => 0,
	DS_DMG_WATER => 0,
	DS_DMG_POISON => 0,
	DS_DMG_INFECTION => 0,
	DS_STRENGTH => 100,
	DS_FORCE => 100,
	DS_RESILIENCE => 100,
	DS_CONTROL => 100,
	DS_INERTIA => 100,
	DS_RECOVERY => 100,
	DS_AGILITY => 100,
	DS_DEXTERITY => 100,
	DS_EVASIVENESS => 100,
	DS_FINESSE => 100,
	DS_BALANCE => 100,
	DS_REACH => 100,
	DS_MAGIC => 100,
	DS_DISRUPTION => 100,
	DS_DISCIPLINE => 100,
	DS_FOCUS => 100,
	DS_INSANITY => 100,
	DS_CHARISMA => 100,
	DS_REPUTATION => 100,
	DS_NOTORIETY => 100,
	DS_FAME => 100,
	DS_DISCOUNT => 100,
	DS_BARGAINING => 100,
	DS_LEADERSHIP => 100,
	DS_INTELLECT => 100,
	DS_TENACITY => 100,
	DS_KNOWLEDGE => 100,
	DS_HEURISTICS => 100,
	DS_JUDGEMENT => 100,
	DS_PRAXIS => 100,
];

$DS_descriptions = [
	DS_HANDICAP => 'DESCRIPTION_MISSING',
	DS_RANDOMISER => 'DESCRIPTION_MISSING',
	DS_HP_MAX => 'DESCRIPTION_MISSING',
	DS_REGENERATION => 'DESCRIPTION_MISSING',
	DS_EP_MAX => 'DESCRIPTION_MISSING',
	DS_RECHARGE => 'DESCRIPTION_MISSING',
	DS_LUCK => 'DESCRIPTION_MISSING',
	DS_EXPERIENCE => 'DESCRIPTION_MISSING',
	DS_ATTACKSPEED => 'DESCRIPTION_MISSING',
	DS_SPEED => 'DESCRIPTION_MISSING',
	DS_SPEED_FAST => 'DESCRIPTION_MISSING',
	DS_DAMAGE => 'DESCRIPTION_MISSING',
	DS_HIT_CHANCE => 'DESCRIPTION_MISSING',
	DS_CRIT_DAMAGE => 'DESCRIPTION_MISSING',
	DS_CRIT_CHANCE => 'DESCRIPTION_MISSING',
	DS_DEFENCE => 'DESCRIPTION_MISSING',
	DS_DODGE_CHANCE => 'DESCRIPTION_MISSING',
	DS_ATTACK_SPEED => 'DESCRIPTION_MISSING',
	DS_CONSISTENCY => 'DESCRIPTION_MISSING',
	DS_ENERGYUSE => 'DESCRIPTION_MISSING',
	DS_DMGDL_BLUNT => 'DESCRIPTION_MISSING',
	DS_DMGDL_POINT => 'DESCRIPTION_MISSING',
	DS_DMGDL_CUT => 'DESCRIPTION_MISSING',
	DS_DMGDL_MISSILE => 'DESCRIPTION_MISSING',
	DS_DMGDL_LIQUID => 'DESCRIPTION_MISSING',
	DS_DMGDL_VAPOUR => 'DESCRIPTION_MISSING',
	DS_DMGDL_PLASMA => 'DESCRIPTION_MISSING',
	DS_DMG_TRAUMA => 'DESCRIPTION_MISSING',
	DS_DMG_FIRE => 'DESCRIPTION_MISSING',
	DS_DMG_COLD => 'DESCRIPTION_MISSING',
	DS_DMG_ELECTRIC => 'DESCRIPTION_MISSING',
	DS_DMG_WATER => 'DESCRIPTION_MISSING',
	DS_DMG_POISON => 'DESCRIPTION_MISSING',
	DS_DMG_INFECTION => 'DESCRIPTION_MISSING',
	DS_STRENGTH => 'DESCRIPTION_MISSING',
	DS_FORCE => 'DESCRIPTION_MISSING',
	DS_RESILIENCE => 'Ability to withstand damage',
	DS_CONTROL => 'Control over physical movement',
	DS_INERTIA => 'Unstoppable force behind attacks',
	DS_RECOVERY => 'DESCRIPTION_MISSING',
	DS_AGILITY => 'DESCRIPTION_MISSING',
	DS_DEXTERITY => 'DESCRIPTION_MISSING',
	DS_EVASIVENESS => 'DESCRIPTION_MISSING',
	DS_FINESSE => 'DESCRIPTION_MISSING',
	DS_BALANCE => 'DESCRIPTION_MISSING',
	DS_REACH => 'DESCRIPTION_MISSING',
	DS_MAGIC => 'DESCRIPTION_MISSING',
	DS_DISRUPTION => 'DESCRIPTION_MISSING',
	DS_DISCIPLINE => 'DESCRIPTION_MISSING',
	DS_FOCUS => 'DESCRIPTION_MISSING',
	DS_INSANITY => 'DESCRIPTION_MISSING',
	DS_CHARISMA => 'DESCRIPTION_MISSING',
	DS_REPUTATION => 'DESCRIPTION_MISSING',
	DS_NOTORIETY => 'DESCRIPTION_MISSING',
	DS_FAME => 'DESCRIPTION_MISSING',
	DS_DISCOUNT => 'DESCRIPTION_MISSING',
	DS_BARGAINING => 'DESCRIPTION_MISSING',
	DS_LEADERSHIP => 'DESCRIPTION_MISSING',
	DS_INTELLECT => 'DESCRIPTION_MISSING',
	DS_TENACITY => 'DESCRIPTION_MISSING',
	DS_KNOWLEDGE => 'DESCRIPTION_MISSING',
	DS_HEURISTICS => 'DESCRIPTION_MISSING',
	DS_JUDGEMENT => 'DESCRIPTION_MISSING',
	DS_PRAXIS => 'DESCRIPTION_MISSING',
];

$DS_typed = [
	100 => DS_STRENGTH,
	101 => DS_FORCE,
	102 => DS_RESILIENCE,
	103 => DS_CONTROL,
	150 => DS_INERTIA,
	151 => DS_RECOVERY,
	200 => DS_AGILITY,
	201 => DS_DEXTERITY,
	202 => DS_EVASIVENESS,
	203 => DS_FINESSE,
	250 => DS_BALANCE,
	251 => DS_REACH,
	300 => DS_MAGIC,
	301 => DS_DISRUPTION,
	302 => DS_DISCIPLINE,
	303 => DS_FOCUS,
	350 => DS_INSANITY,
	400 => DS_CHARISMA,
	401 => DS_REPUTATION,
	402 => DS_NOTORIETY,
	403 => DS_FAME,
	450 => DS_DISCOUNT,
	451 => DS_BARGAINING,
	452 => DS_LEADERSHIP,
	500 => DS_INTELLECT,
	501 => DS_TENACITY,
	502 => DS_KNOWLEDGE,
	503 => DS_HEURISTICS,
	550 => DS_JUDGEMENT,
	551 => DS_PRAXIS,
];

$DS_types = [
	DS_STRENGTH => 	[
		101 => DS_FORCE,
		102 => DS_RESILIENCE,
		103 => DS_CONTROL,
		150 => DS_INERTIA,
		151 => DS_RECOVERY,
	],
	DS_AGILITY => 	[
		201 => DS_DEXTERITY,
		202 => DS_EVASIVENESS,
		203 => DS_FINESSE,
		250 => DS_BALANCE,
		251 => DS_REACH,
	],
	DS_MAGIC => 	[
		301 => DS_DISRUPTION,
		302 => DS_DISCIPLINE,
		303 => DS_FOCUS,
		350 => DS_INSANITY,
	],
	DS_CHARISMA => 	[
		401 => DS_REPUTATION,
		402 => DS_NOTORIETY,
		403 => DS_FAME,
		450 => DS_DISCOUNT,
		451 => DS_BARGAINING,
		452 => DS_LEADERSHIP,
	],
	DS_INTELLECT => 	[
		501 => DS_TENACITY,
		502 => DS_KNOWLEDGE,
		503 => DS_HEURISTICS,
		550 => DS_JUDGEMENT,
		551 => DS_PRAXIS,
	],
];

$DS_types_core = [
	DS_STRENGTH => 	[
		101 => DS_FORCE,
		102 => DS_RESILIENCE,
		103 => DS_CONTROL,
	],
	DS_AGILITY => 	[
		201 => DS_DEXTERITY,
		202 => DS_EVASIVENESS,
		203 => DS_FINESSE,
	],
	DS_MAGIC => 	[
		301 => DS_DISRUPTION,
		302 => DS_DISCIPLINE,
		303 => DS_FOCUS,
	],
	DS_CHARISMA => 	[
		401 => DS_REPUTATION,
		402 => DS_NOTORIETY,
		403 => DS_FAME,
	],
	DS_INTELLECT => 	[
		501 => DS_TENACITY,
		502 => DS_KNOWLEDGE,
		503 => DS_HEURISTICS,
	],
];

$DS_types_subs = [
	DS_STRENGTH => 	[
		150 => DS_INERTIA,
		151 => DS_RECOVERY,
	],
	DS_AGILITY => 	[
		250 => DS_BALANCE,
		251 => DS_REACH,
	],
	DS_MAGIC => 	[
		350 => DS_INSANITY,
	],
	DS_CHARISMA => 	[
		450 => DS_DISCOUNT,
		451 => DS_BARGAINING,
		452 => DS_LEADERSHIP,
	],
	DS_INTELLECT => 	[
		550 => DS_JUDGEMENT,
		551 => DS_PRAXIS,
	],
];

$DS_global = [
	2 => DS_HP_MAX,
	3 => DS_REGENERATION,
	4 => DS_EP_MAX,
	5 => DS_RECHARGE,
	7 => DS_LUCK,
	10 => DS_EXPERIENCE,
];

$DS_prefixes = [
	DS_HANDICAP => 'PREFIX_MISSING',
	DS_RANDOMISER => 'PREFIX_MISSING',
	DS_HP_MAX => 'Life giving',
	DS_REGENERATION => 'Restorative',
	DS_EP_MAX => 'Energizing',
	DS_RECHARGE => 'PREFIX_MISSING',
	DS_LUCK => 'Lucky',
	DS_EXPERIENCE => 'Insightful',
	DS_ATTACKSPEED => 'Swift',
	DS_SPEED => 'PREFIX_MISSING',
	DS_SPEED_FAST => 'PREFIX_MISSING',
	DS_DAMAGE => 'PREFIX_MISSING',
	DS_HIT_CHANCE => 'PREFIX_MISSING',
	DS_CRIT_DAMAGE => 'PREFIX_MISSING',
	DS_CRIT_CHANCE => 'PREFIX_MISSING',
	DS_DEFENCE => 'PREFIX_MISSING',
	DS_DODGE_CHANCE => 'PREFIX_MISSING',
	DS_ATTACK_SPEED => 'PREFIX_MISSING',
	DS_CONSISTENCY => 'PREFIX_MISSING',
	DS_ENERGYUSE => 'PREFIX_MISSING',
	DS_DMGDL_BLUNT => 'PREFIX_MISSING',
	DS_DMGDL_POINT => 'PREFIX_MISSING',
	DS_DMGDL_CUT => 'PREFIX_MISSING',
	DS_DMGDL_MISSILE => 'PREFIX_MISSING',
	DS_DMGDL_LIQUID => 'PREFIX_MISSING',
	DS_DMGDL_VAPOUR => 'PREFIX_MISSING',
	DS_DMGDL_PLASMA => 'PREFIX_MISSING',
	DS_DMG_TRAUMA => 'PREFIX_MISSING',
	DS_DMG_FIRE => 'PREFIX_MISSING',
	DS_DMG_COLD => 'PREFIX_MISSING',
	DS_DMG_ELECTRIC => 'PREFIX_MISSING',
	DS_DMG_WATER => 'PREFIX_MISSING',
	DS_DMG_POISON => 'PREFIX_MISSING',
	DS_DMG_INFECTION => 'PREFIX_MISSING',
	DS_STRENGTH => 'Empowering',
	DS_FORCE => 'Solid',
	DS_RESILIENCE => 'Robust',
	DS_CONTROL => 'Precise',
	DS_INERTIA => 'Heavy',
	DS_RECOVERY => 'Remedial',
	DS_AGILITY => 'PREFIX_MISSING',
	DS_DEXTERITY => 'PREFIX_MISSING',
	DS_EVASIVENESS => 'PREFIX_MISSING',
	DS_FINESSE => 'Fine',
	DS_BALANCE => 'Balanced',
	DS_REACH => 'Long',
	DS_MAGIC => 'PREFIX_MISSING',
	DS_DISRUPTION => 'PREFIX_MISSING',
	DS_DISCIPLINE => 'PREFIX_MISSING',
	DS_FOCUS => 'Mezmerising',
	DS_INSANITY => 'PREFIX_MISSING',
	DS_CHARISMA => 'PREFIX_MISSING',
	DS_REPUTATION => 'PREFIX_MISSING',
	DS_NOTORIETY => 'PREFIX_MISSING',
	DS_FAME => 'Famous',
	DS_DISCOUNT => 'PREFIX_MISSING',
	DS_BARGAINING => 'PREFIX_MISSING',
	DS_LEADERSHIP => 'PREFIX_MISSING',
	DS_INTELLECT => 'Clever',
	DS_TENACITY => 'PREFIX_MISSING',
	DS_KNOWLEDGE => 'Wise',
	DS_HEURISTICS => 'PREFIX_MISSING',
	DS_JUDGEMENT => 'PREFIX_MISSING',
	DS_PRAXIS => 'PREFIX_MISSING',
];

$DS_suffixes = [
	DS_HANDICAP => 'SUFFIX_MISSING',
	DS_RANDOMISER => 'SUFFIX_MISSING',
	DS_HP_MAX => 'SUFFIX_MISSING',
	DS_REGENERATION => 'SUFFIX_MISSING',
	DS_EP_MAX => 'SUFFIX_MISSING',
	DS_RECHARGE => 'SUFFIX_MISSING',
	DS_LUCK => 'SUFFIX_MISSING',
	DS_EXPERIENCE => 'SUFFIX_MISSING',
	DS_ATTACKSPEED => 'SUFFIX_MISSING',
	DS_SPEED => 'SUFFIX_MISSING',
	DS_SPEED_FAST => 'SUFFIX_MISSING',
	DS_DAMAGE => 'SUFFIX_MISSING',
	DS_HIT_CHANCE => 'SUFFIX_MISSING',
	DS_CRIT_DAMAGE => 'SUFFIX_MISSING',
	DS_CRIT_CHANCE => 'SUFFIX_MISSING',
	DS_DEFENCE => 'SUFFIX_MISSING',
	DS_DODGE_CHANCE => 'SUFFIX_MISSING',
	DS_ATTACK_SPEED => 'SUFFIX_MISSING',
	DS_CONSISTENCY => 'SUFFIX_MISSING',
	DS_ENERGYUSE => 'SUFFIX_MISSING',
	DS_DMGDL_BLUNT => 'SUFFIX_MISSING',
	DS_DMGDL_POINT => 'SUFFIX_MISSING',
	DS_DMGDL_CUT => 'SUFFIX_MISSING',
	DS_DMGDL_MISSILE => 'SUFFIX_MISSING',
	DS_DMGDL_LIQUID => 'SUFFIX_MISSING',
	DS_DMGDL_VAPOUR => 'SUFFIX_MISSING',
	DS_DMGDL_PLASMA => 'SUFFIX_MISSING',
	DS_DMG_TRAUMA => 'SUFFIX_MISSING',
	DS_DMG_FIRE => 'SUFFIX_MISSING',
	DS_DMG_COLD => 'SUFFIX_MISSING',
	DS_DMG_ELECTRIC => 'SUFFIX_MISSING',
	DS_DMG_WATER => 'SUFFIX_MISSING',
	DS_DMG_POISON => 'SUFFIX_MISSING',
	DS_DMG_INFECTION => 'SUFFIX_MISSING',
	DS_STRENGTH => 'SUFFIX_MISSING',
	DS_FORCE => 'SUFFIX_MISSING',
	DS_RESILIENCE => 'SUFFIX_MISSING',
	DS_CONTROL => 'SUFFIX_MISSING',
	DS_INERTIA => 'SUFFIX_MISSING',
	DS_RECOVERY => 'SUFFIX_MISSING',
	DS_AGILITY => 'SUFFIX_MISSING',
	DS_DEXTERITY => 'SUFFIX_MISSING',
	DS_EVASIVENESS => 'SUFFIX_MISSING',
	DS_FINESSE => 'SUFFIX_MISSING',
	DS_BALANCE => 'SUFFIX_MISSING',
	DS_REACH => 'SUFFIX_MISSING',
	DS_MAGIC => 'SUFFIX_MISSING',
	DS_DISRUPTION => 'SUFFIX_MISSING',
	DS_DISCIPLINE => 'SUFFIX_MISSING',
	DS_FOCUS => 'SUFFIX_MISSING',
	DS_INSANITY => 'SUFFIX_MISSING',
	DS_CHARISMA => 'SUFFIX_MISSING',
	DS_REPUTATION => 'SUFFIX_MISSING',
	DS_NOTORIETY => 'SUFFIX_MISSING',
	DS_FAME => 'SUFFIX_MISSING',
	DS_DISCOUNT => 'SUFFIX_MISSING',
	DS_BARGAINING => 'SUFFIX_MISSING',
	DS_LEADERSHIP => 'SUFFIX_MISSING',
	DS_INTELLECT => 'SUFFIX_MISSING',
	DS_TENACITY => 'SUFFIX_MISSING',
	DS_KNOWLEDGE => 'SUFFIX_MISSING',
	DS_HEURISTICS => 'SUFFIX_MISSING',
	DS_JUDGEMENT => 'SUFFIX_MISSING',
	DS_PRAXIS => 'SUFFIX_MISSING',
];

$DMGDL_names = [
	DMGDL_BLUNT => 'blunt',
	DMGDL_POINT => 'point',
	DMGDL_CUT => 'cut',
	DMGDL_MISSILE => 'missile',
	DMGDL_LIQUID => 'liquid',
	DMGDL_VAPOUR => 'vapour',
	DMGDL_PLASMA => 'plasma',
];

$DMG_names = [
	DMG_TRAUMA => 'trauma',
	DMG_FIRE => 'fire',
	DMG_COLD => 'cold',
	DMG_ELECTRIC => 'electric',
	DMG_WATER => 'water',
	DMG_POISON => 'poison',
	DMG_INFECTION => 'infection',
];

$DMG_DMGDL_names = [
	DMG_TRAUMA => 'trauma',
	DMG_FIRE => 'fire',
	DMG_COLD => 'cold',
	DMG_ELECTRIC => 'electric',
	DMG_WATER => 'water',
	DMG_POISON => 'poison',
	DMG_INFECTION => 'infection',
	DMGDL_BLUNT => 'blunt',
	DMGDL_POINT => 'point',
	DMGDL_CUT => 'cut',
	DMGDL_MISSILE => 'missile',
	DMGDL_LIQUID => 'liquid',
	DMGDL_VAPOUR => 'vapour',
	DMGDL_PLASMA => 'plasma',
];

$DMG_prefixes = [
	1100 => 'PREFIX_MISSING',
	1101 => 'PREFIX_MISSING',
	1102 => 'PREFIX_MISSING',
	1103 => 'PREFIX_MISSING',
	1104 => 'PREFIX_MISSING',
	1105 => 'PREFIX_MISSING',
	1106 => 'PREFIX_MISSING',
];

$DMG_suffixes = [
	1100 => 'SUFFIX_MISSING',
	1101 => 'SUFFIX_MISSING',
	1102 => 'SUFFIX_MISSING',
	1103 => 'SUFFIX_MISSING',
	1104 => 'SUFFIX_MISSING',
	1105 => 'SUFFIX_MISSING',
	1106 => 'SUFFIX_MISSING',
];

$TEQT_names = [
	TEQT_MELEE => 'melee',
	TEQT_RANGED => 'ranged',
	TEQT_MAGIC => 'magic',
];

$TEQ_names = [
	TEQ_DAMAGE => 'damage',
	TEQ_HIT_CHANCE => 'hit chance',
	TEQ_CRIT_DAMAGE => 'crit damage',
	TEQ_CRIT_CHANCE => 'crit chance',
	TEQ_DEFENCE => 'defence',
	TEQ_DODGE_CHANCE => 'dodge chance',
	TEQ_ATTACK_SPEED => 'attack speed',
	TEQ_CONSISTENCY => 'consistency',
];

$SKLS_values = [
	SKLS_KEY_0 => 0,
	SKLS_KEY_1 => 1,
	SKLS_KEY_2 => 2,
	SKLS_KEY_3 => 3,
	SKLS_KEY_4 => 4,
	SKLS_KEY_5 => 5,
	SKLS_KEY_6 => 6,
	SKLS_KEY_7 => 7,
	SKLS_KEY_8 => 8,
	SKLS_KEY_9 => 9,
	SKLS_CLICK => 100,
	SKLS_RIGHT_CLICK => 200,
];

const SND_CHECKPOINT = 0;
const SND_COMMS = 1;
const SND_DMGDL_BLUNT = 2;
const SND_DMGDL_CUT = 3;
const SND_DMGDL_POINT = 4;
const SND_FROZEN = 5;
const SND_GHOST = 6;
const SND_NEWWAYPOINT = 7;
const SND_RECHARGE = 8;
const SND_RECOVER = 9;
const SND_SWING = 10;
const SND_TELEPORT = 11;
const SND_WOOSHDING = 12;

$SND_files = [
	SND_CHECKPOINT => 'checkpoint.wav',
	SND_COMMS => 'comms.wav',
	SND_DMGDL_BLUNT => 'DMGDL_blunt.wav',
	SND_DMGDL_CUT => 'DMGDL_cut.wav',
	SND_DMGDL_POINT => 'DMGDL_point.wav',
	SND_FROZEN => 'frozen.wav',
	SND_GHOST => 'ghost.wav',
	SND_NEWWAYPOINT => 'newWaypoint.wav',
	SND_RECHARGE => 'recharge.wav',
	SND_RECOVER => 'recover.wav',
	SND_SWING => 'swing.wav',
	SND_TELEPORT => 'teleport.wav',
	SND_WOOSHDING => 'wooshding.wav',
];

const MAP_DEVZOO = 1;
const MAP_DS_GRUBREGION = 2;
const MAP_DS_NEXUS = 3;
const MAP_EFFENDONGROVE = 4;
const MAP_GRUBPONDCAVE = 5;
const MAP_BASILSHOUSE = 6;
const MAP_GRUBHOUSE = 7;
const MAP_GRUBHOUSELOFT = 8;
const MAP_GRUBTOWN = 9;
const MAP_REGGINSHOUSE = 10;
const MAP_YIRRINSHOUSE = 11;
const MAP_GRUBTOWNHALL = 12;
const MAP_LOWERGRUBFIELDS = 13;

$MAP_paths = [
	MAP_DEVZOO => 'debug/devZoo',
	MAP_DS_GRUBREGION => 'dreamscape/ds_grubRegion',
	MAP_DS_NEXUS => 'dreamscape/ds_nexus',
	MAP_EFFENDONGROVE => 'grubRegion/effendonGrove',
	MAP_GRUBPONDCAVE => 'grubRegion/grubPondCave',
	MAP_BASILSHOUSE => 'grubRegion/grubTown/basilsHouse',
	MAP_GRUBHOUSE => 'grubRegion/grubTown/grubHouse',
	MAP_GRUBHOUSELOFT => 'grubRegion/grubTown/grubHouseLoft',
	MAP_GRUBTOWN => 'grubRegion/grubTown/grubTown',
	MAP_REGGINSHOUSE => 'grubRegion/grubTown/regginsHouse',
	MAP_YIRRINSHOUSE => 'grubRegion/grubTown/yirrinsHouse',
	MAP_GRUBTOWNHALL => 'grubRegion/grubTownHall',
	MAP_LOWERGRUBFIELDS => 'grubRegion/lowerGrubFields',
];

$MAP_names = [
	MAP_DEVZOO => 'Debug Menagerie',
	MAP_DS_GRUBREGION => 'Dev Zoo',
	MAP_DS_NEXUS => 'Bent House',
	MAP_EFFENDONGROVE => 'Longhouse',
	MAP_GRUBPONDCAVE => 'Pokey House',
	MAP_BASILSHOUSE => 'The Spider Cave',
	MAP_GRUBHOUSE => 'Old Grub Town',
	MAP_GRUBHOUSELOFT => 'yirrinsHouse',
	MAP_GRUBTOWN => 'regginsHouse',
	MAP_REGGINSHOUSE => 'regginsHouse',
	MAP_YIRRINSHOUSE => 'regginsHouse',
	MAP_GRUBTOWNHALL => 'grubTownHall',
	MAP_LOWERGRUBFIELDS => 'lowerGrubFields',
];



/**
 * Used in functions which use random values. Calling a variable is cheaper than calling a function.
 */
$randMax = mt_getrandmax();

$allowedIPs = [
    '::1',
    '127.0.0.1',
	'120.147.0.24'
];

const DEV_MODE = true;

const PLAYER_SALE_MULTIPLYER = 0.16;

const ATTACK_RAND_MAX = 20;
const ATTACK_RAND_MIN = -60;

const CNS_SYSTEM		= -1;

const CNS_DEFAULT		= 1;
const CNS_ERRORS		= 2;
const CNS_UPDATES		= 3;

const CNS_MAP_INIT		= 10;
const CNS_BEHAVIOUR		= 11;
const CNS_SPRITE		= 12;
const CNS_ATTACK		= 13;
const CNS_ITEMS			= 14;
const CNS_DSs			= 15;
const CNS_SRZ			= 16;

$consoleStreams = [
	CNS_DEFAULT			=> 'Default',
	CNS_ERRORS			=> 'Error Info',
	CNS_UPDATES			=> 'Update Content',
	CNS_MAP_INIT		=> 'Map Initialisation',
	CNS_BEHAVIOUR		=> 'Behaviour',
	CNS_SPRITE			=> 'Sprite Manipulation',
	CNS_ATTACK			=> 'Attack Sata',
	CNS_ITEMS			=> 'Items',
	CNS_DSs				=> 'Dude Stats',
	CNS_SRZ				=> 'Micro-serialization',
];

$consoleStreams_offDefault = [
	CNS_DSs,
	CNS_SRZ,
];

if (!isset($_GET['console']))
{
	$consoleTimeStamp = microtime(true);

	function console_echo ($string, $colour = null, $CNS = null)
	{
		global $consoleTimeStamp;

		$CNS = $CNS ? $CNS : CNS_DEFAULT;

		if (isset($CNS)
			&& isset($_SESSION['console']['streams'])
			&& isset($_SESSION['console']['streams'][$CNS])
			&& !$_SESSION['console']['streams'][$CNS]
		) return;

		if (!DEV_MODE) return;

//		if ($STREAM) $string = "[{$STREAM}] {$string}";

		if (isset($colour))
        {
            for($i = 0; $i < strlen($colour); $i++)
            {
				if (is_numeric($colour[$i])) $colour[$i] = 'a';
			}
		}

		$string = str_replace(
		[
			'<<',
			'>>',
			'<>'
		],
		[
			'<span style="color:',
			';">',
			'</span>',
		],
		$string);

		$string = ($colour ? "<span style=\"color:{$colour};\">{$string}</span>" : $string);

		if (isset($_SESSION['console'][$consoleTimeStamp]['data']))
			$_SESSION['console'][$consoleTimeStamp]['data'] .= "<br>$string";
		else
			$_SESSION['console'][$consoleTimeStamp]['data'] = $string;
	}

	function console_var_dump($var, $colour = null, $CNS = null)
	{
		if (!DEV_MODE) return;

		if (!$colour) $colour = '#aaf';

		ob_start();
		var_dump($var);
		$string = ob_get_clean();
		$string = "<pre>{$string}</pre>";
		console_echo($string, $colour, $CNS);
	}

	function console_stack_trace($colour = '#afa')
	{
		ob_start();
		debug_print_backtrace();
		$trace = ob_get_clean();

		$trace = str_replace("\n", '<br>', $trace);

		console_echo($trace, $colour);
	}

	function console_class_list($array, $colour = '#aff')
	{
		console_var_dump(buildClassList($array), $colour);
	}

	function buildClassList($array)
	{
		$classNames = [];

		foreach ($array as $key => $thing)
		{
			if (is_array($thing))
			{
				$classNames[$key] = buildClassList($thing);
			}
			elseif (is_scalar($thing))
			{
				$thing = (string)($thing);
				if (strlen($thing) > 100) $thing = substr($thing, 0, 100) . '...';
				$classNames[$key] = (string)($thing);

			}
			else
			{
				$classNames[$key] = get_class($thing);
			}
		}

		return $classNames;
	}

	function console_forceScroll()
	{
		global $consoleTimeStamp;

		$_SESSION['console'][$consoleTimeStamp]['FS'] = true;
	}

	function console_swatch($colour)
	{
		return "<span style=\"background-color:{$colour}\">&nbsp;&nbsp;</span> {$colour}";
	}

	function console_sprite(Sprite $sprite)
	{
		$string = '';

		foreach ($sprite->frames as $frame)
		{
			$string .= '<div class="consoleSprite">';
			for ($e = 0; $e < 6; $e++)
			{
				if (isset($frame[$e]))
				{
					$element = $frame[$e];
//					$char = htmlentities($element->char);

					$string .= "<span style=\"color:{$element->fg};";
					$string .= (isset($element->bg) ? "background-color:{$element->bg};" : '');
//					$string .= "\">{$char}</span>";
					$string .= "\">{$element->char}</span>";
				}
				else
				{
					$string .= '&nbsp;';
				}

				if ($e === 2) $string .= '<br>';
			}
			$string .= '</div>';
		}



		return $string;
	}

    function console_errorHander($errno, $errstr, $errfile, $errline)
	{
		global $consoleTimeStamp;

		$errfile = basename($errfile);
		$errmess = "<<#faa>>{$errfile}<> - [<<#fff>>{$errline}<>]:<br>{$errstr}\n";

		foreach(debug_backtrace(null, 10) as $level => $trace)
		{
			if (!$level) continue;

			$function	= isset($trace['function'])	? $trace['function']			: '';
			$line		= isset($trace['line'])		? "[<<#fff>>{$trace['line']}<>]"	: '';
			$file		= '';
			$class		= isset($trace['class'])	? $trace['class']				: '';
			$object		= isset($trace['object'])	? get_class($trace['object'])	: '';
			$type		= isset($trace['type'])		? "<<#faa>>{$trace['type']}<>"	: '';
			$args		= '';

			if (isset($trace['args']))
			{
				foreach ($trace['args'] as $arg)
				{
					if (is_object($arg)) $args .= get_class($arg) . ', ';
					elseif (is_array($arg)) $args .= 'array, ';
					else $args .= $arg . ', ';
				}
				$args = "({$args})";
			}

			if (isset($trace['file']))
			{
//				$file = $trace['file'];
				$file = explode('asciilands', $trace['file'])[1];
				$file = trim($file, '\\/');
				$file = "<<#faa>>{$file}<>";
			}

			$errmess .= "[{$level}]\t{$file}\t{$line}:\t{$object} {$class}{$type}{$function}{$args};\n";


		}

		console_echo($errmess, '#f55', CNS_ERRORS);
		$_SESSION['console'][$consoleTimeStamp]['error'] = true;
		return true;
	}

	function console_toogleStream ($STREAM, $forceState = null)
	{
		if (!$_SESSION['console']['streams'])
		{
			global $consoleStreams;
			global $consoleStreams_offDefault;

			$streams = [];

			foreach ($consoleStreams as $CNS => $val)
			{
				$streams[$CNS] = !in_array($CNS, $consoleStreams_offDefault);
			}

			$_SESSION['console']['streams'] = $streams;
			console_var_dump($streams);
		}

		if ($forceState === null)
		{
			$_SESSION['console']['streams'][$STREAM] = !$_SESSION['console']['streams'][$STREAM];
		}
		else
		{
			$_SESSION['console']['streams'][$STREAM] = $forceState;
		}

		$_SESSION['console']['updateStreams'] = true;
	}

	function console_setFrameTime()
	{
		global $consoleTimeStamp;

		$_SESSION['console'][$consoleTimeStamp]['frameTime'] = round(microtime(true) - $_SERVER['REQUEST_TIME_FLOAT'], 4);
	}

	function console_setWakeTime()
	{
		global $consoleTimeStamp;

		$_SESSION['console'][$consoleTimeStamp]['wakeTime'] = round(microtime(true) - $_SERVER['REQUEST_TIME_FLOAT'], 4);
	}

	function error_eater($errno, $errstr, $errfile, $errline) { }

    function console_update_location()
    {
        if (!DEV_MODE) return;

        global $player;
        $_SESSION['console']['location'] = "{$player->n_offset}:{$player->w_offset}";
    }

	function console_warning ($message)
	{
		trigger_error($message);
	}

	if (DEV_MODE)
	{
		set_error_handler('console_errorHander', -1);
	}
	else
	{
		set_error_handler('error_eater', -1);
	}
}
else
{
	$console = $_GET['console'];

	switch ($console)
	{
		case 'request':
			session_start();

			if (!isset($_SESSION['console'])) EXIT();

			$consoleData = new stdClass();

			if (isset($_SESSION['console']['location']))
			{
				$consoleData->location = $_SESSION['console']['location'];
				unset($_SESSION['console']['location']);
			}
			else
			{
				$consoleData->location = null;
			}

			if (isset($_SESSION['console']['updateStreams']))
			{
				$consoleData->streams = $_SESSION['console']['streams'];
				unset($_SESSION['console']['updateStreams']);
			}

			$consoleData->frameData = $_SESSION['console'];
			unset($consoleData->frameData['streams']);


			echo json_encode($consoleData);

			$streams = isset($_SESSION['console']['streams']) ? $_SESSION['console']['streams'] : [];

			$_SESSION['console'] = [
				'streams' => $streams
			];

			EXIT();
		break;

		case 'window':
			require '../core/constants.php';
			require '../core/config.cfg';
?>

<html>
	<head>
		<style type="text/css">
			*
			{
                padding:0px;
                margin:0px;
				font-family:lucida console, monospace;
				font-size:10px;
			}

			body
			{
				background-color:#000;
			}

			#content
			{
                display:block;
				overflow-y:auto;
				overflow-x:hidden;
                background-color:#000;
				color:#555;
				margin-bottom:<?php echo CHAR_HEIGHT; ?>px;
			}

			.panel:hover
			{
				background-color:#444;
			}

			.consoleSprite
			{
				display:inline-block;
			}

            #header
            {
                background-color:#000;
                color:#fff;
                position:fixed;
                top:0px;
                left:0px;
                right:0px;
            }

			#pinned
			{
				display:none;
				position:fixed;
				top:<?php echo CHAR_HEIGHT; ?>px;
				left:0px;
				right:0px;
				height:auto;
				max-height:<?php echo CHAR_HEIGHT * 3; ?>px;
				color:#668;
				background-color:#223;
				overflow:hidden;
				opacity:0.5;
				transition:max-height 0.3s, opacity 0.3s;
			}

			#pinned:hover
			{
				max-height:80%;
				opacity:0.95;
				overflow:auto;
				z-index:999;
			}

			#iframeContainer
			{
				position:fixed;
				top:<?php echo CHAR_HEIGHT; ?>px;
				right:0px;
				bottom:<?php echo CHAR_HEIGHT; ?>px;
				width:<?php echo CHAR_WIDTH * 10; ?>px;
				opacity:0.5;
				transition:width 0.3s, opacity 0.3s;
			}

			#iframeContainer:hover
			{
				opacity:0.9;
				width:<?php echo CHAR_WIDTH * 95; ?>px;
				z-index:999;
			}

			iframe
			{
				width:100%;
				height:100%;
				border:none;
			}

			#input
			{
				position:fixed;
				bottom:0px;
				left:0px;
				right:0px;
				top:auto;
				height:<?php echo CHAR_HEIGHT; ?>px;
				width:100%;
				border:none;
				background-color:#030;
				color:#afa;
				resize:none;
			}

			#graph
			{
				position:fixed;
				bottom:<?php echo CHAR_HEIGHT; ?>px;
				max-width:<?php echo CHAR_WIDTH * 10; ?>px;
				height:400px;
				overflow:hidden;
				opacity:0.2;
				transition:max-width 0.3s, opacity 0.3s;
			}

			#graph:hover
			{
				max-width:100%;
				opacity:0.8;
				padding-right:<?php echo CHAR_WIDTH * 4; ?>px;
			}

			.graphBar
			{
				border-top-style:solid;
				border-top-width:2px;

				background-color:#fff;
				width:4px;
				float:left;
				bottom:0px;
			}

			.graphBar .wakePoint
			{
				position:absolute;
				height:2px;
				width:4px;
				background-color:#000;
			}

			.graphBar.error { background-color:#f66 !important; }
			.graphBar.pin { background-color:#66f !important; }

			#graph:hover>.graphBar { background-color:#aaa; }
			.graphBar.pin:hover { background-color:#88f !important; }
			.graphBar.error:hover { background-color:#f88 !important; }

			.graphBar:hover
			{
				background-color:#fff !important;
				border-top-width:30px;
			}

			.graphBar.t1 { border-color: #0f0; }
			.graphBar.t2 { border-color: #ff0; }
			.graphBar.t3 { border-color: #f80; }
			.graphBar.t4 { border-color: #f00; }

			#pressedKeyCode
			{
				position:absolute;
				right:0px;
			}

			#mouseButtonCode
			{
				position:absolute;
				right:100px;
			}

			#streams
			{
				position:fixed;
				max-height:<?php echo CHAR_HEIGHT; ?>;
				background-color:#266;
				color:#9dd;
				bottom:<?php echo CHAR_HEIGHT; ?>px;
				right:<?php echo CHAR_WIDTH * 10; ?>px;
				width:<?php echo CHAR_WIDTH * 20; ?>px;
				overflow:hidden;
				opacity:0.5;
				transition:max-height 0.3s, opacity 0.3s;
			}

			#streams:hover
			{
				opacity:0.9;
				max-height:50%;
			}

			.stream
			{
				padding:5px;
			}

			.stream:hover
			{
				color:#fff;
				background-color:#488;
				cursor:pointer;
			}

			.stream.on
			{
				color:#afa;
			}

			.stream.off
			{
				color:#f77;
			}

			#streams span
			{
				display:block;
				background-color:#144;
				padding:3px;
				color:#fff;
			}

			#allStreamsContainer { text-align:center; }

			.allStreams
			{
				color:#266;
				display:inline-block;
				padding:6px;
				margin:6px;
				width: 40px;
				border-radius:6px;
				font-weight:bold;
			}

			.allStreams.on	{ background-color:#afa; }
			.allStreams.off	{ background-color:#f77; }

			.allStreams.on:hover	{ background-color:#dfd; }
			.allStreams.off:hover	{ background-color:#faa; }

		</style>
		<title id="title">Asciilands console</title>
	</head>
	<body>
        <pre id="header"><!--
			--><span id="location"></span><!--
			--><span id="pressedKeyCode"></span><!--
			--><span id="mouseButtonCode"></span><!--
		--></pre>
		<pre id="content">

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;
&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&#x2588;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&#x2588;
&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2584;&nbsp;&nbsp;&#x2588;&#x2588;&#x2580;&nbsp;&#x258c;&#x2580;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&#x2590;&#x2588;&#x2580;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&#x2580;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2580;&nbsp;&#x258c;&#x2580;&#x2588;&#x2588;&#x2588;&#x2580;
&nbsp;&nbsp;&#x2584;&#x2588;&#x2580;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&#x2580;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&nbsp;&#x258c;
&nbsp;&#x2590;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&#x2588;&#x2588;&#x2584;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&#x2588;&#x2588;&#x2584;&nbsp;&#x258c;
&nbsp;&#x2588;&#x2588;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;
&#x2590;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&#x2580;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&#x2580;&#x2588;&#x2588;&#x2584;
&#x2588;&#x2588;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x258c;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x258c;
&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&#x2584;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x258c;&nbsp;&nbsp;&#x2584;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;
&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&#x2588;&#x2580;&nbsp;&#x2590;&#x2588;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x258c;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&nbsp;&#x2588;&#x2580;&nbsp;&#x2590;&#x2588;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;
&#x2588;&#x2588;&#x2588;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&#x2588;&#x2584;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&nbsp;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&#x2584;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&nbsp;&nbsp;&nbsp;&#x2588;&#x2584;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&#x258c;
&#x2590;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2584;&#x258c;&#x2584;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&#x2584;&#x2584;&#x2584;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&nbsp;&#x258c;&nbsp;&nbsp;&#x2590;&#x2588;&#x2580;&#x2584;&#x2584;&#x2588;&#x2584;&#x2584;&#x2584;&#x2584;&#x2584;&#x2584;&#x2588;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&#x258c;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2590;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&#x2588;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&#x258c;&nbsp;&nbsp;&nbsp;&#x2580;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2584;&#x258c;&#x2584;&#x2588;&#x2588;&#x2588;&#x2580;
&nbsp;&#x2588;&#x2588;&#x2588;&#x2584;&#x258c;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&#x2580;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&#x2584;&#x258c;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&#x2584;&#x2588;&#x2588;&#x2588;&#x2588;&#x258c;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2580;
&nbsp;&#x2590;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2590;&#x2588;&#x2588;&#x2588;&#x2588;&#x2584;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;
&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&#x2588;&#x2588;&#x258c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2588;&#x2588;&#x258c;
&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2580;&#x2588;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2588;&#x2580;
		</pre>

		<pre id="pinned"></pre>

		<input id="input" type="text"></input>

		<?php if(!isset($_GET['build']) || $_GET['build'] !== 'false'){ ?>
		<div id="iframeContainer">
			<iframe src="http://localhost:<?php echo $_SERVER['SERVER_PORT']; ?>/tools/build.php?debug"></iframe>
		</div>
		<?php } ?>

		<div id="graph">

		</div>

		<div id="streams">
			<span>STREAMS</span>
			<div id="allStreamsContainer">
				<div class="allStreams on" onclick="toggleStream('allOn');">ON</div>
				<div class="allStreams off" onclick="toggleStream('allOff');">OFF</div>
			</div>
			<?php
				foreach ($consoleStreams as $STREAM => $name)
				{
					echo "<div id=\"stream_{$STREAM}\" onclick=\"toggleStream({$STREAM})\" class=\"stream on\">{$name}</div>";
				}
			?>
		</div>

	</body>
</html>

<script type="text/javascript" src="../../engine/javascript/jvs.notifyServer.php"></script>
<script type="text/javascript">

	var consoleWait = false;
	var content = document.getElementById('content');
	var graph = document.getElementById('graph');
	var title = document.getElementById('title');
    var playerLocation = document.getElementById('location');
    var pressedKeyCode = document.getElementById('pressedKeyCode');
	var autoScroll = false;

	var frameId = 0;

	var panelBg = '#000';
	var locationVals = '';

	var pinnedBar = null;

	var errorInTitle = false;
	var errorInTitleTimer;

	setInterval('getConsoleStream()', 800);

	function getConsoleStream()
	{
		if (consoleWait) return;
		consoleWait = true;

		consoleRequest = new XMLHttpRequest();

		consoleRequest.open("POST","console.php?console=request","true");
		consoleRequest.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		consoleRequest.send();

		consoleRequest.onreadystatechange = function()
		{
			if (consoleRequest.readyState === 4 && consoleRequest.status === 200 && consoleRequest.responseText !== '')
			{
				var consoleData = JSON.parse(consoleRequest.responseText);

				if (consoleData.location !== null) locationVals = consoleData.location;
				playerLocation.innerHTML = '<span style="color:#aaf;">Location:</span> ' + locationVals;

				var frameTime;

				for (var index in consoleData.frameData)
				{
					var data = consoleData.frameData[index];
					var consolePanel = document.createElement('div');
					consolePanel.className = 'panel';

					consolePanel.id = ++frameId + '_p';
					consolePanel.name = frameId + '_p';

					if (data.error === undefined)
					{
						panelBg = (panelBg === '#000' ? '#111' : '#000');
						consolePanel.style.backgroundColor = panelBg;
					}
					else
					{
						consolePanel.style.backgroundColor = '#500';
						errorInTitle = true;
						errorInTitleTimer = setTimeout('errorInTitle = false;', 2000);
					}

					consolePanel.innerHTML = data.data;

					consolePanel.oncontextmenu = function ()
					{
						if (pinnedBar !== null) pinnedBar.className = pinnedBar.className.replace('pin', '');

						var pinnedDiv = document.getElementById('pinned');
						pinnedBar = document.getElementById(this.id.replace('p', 'b'));
						pinnedBar.className = pinnedBar.className + ' pin';

						pinnedDiv.innerHTML = this.innerHTML;
						pinnedDiv.style.display = 'block';

						return false;
					};

					content.appendChild(consolePanel);
					if (content.childNodes.length > 200 && autoScroll)
					{
						while (content.childNodes.length > 200)
						{
							content.removeChild(content.firstChild);
							graph.removeChild(graph.firstChild);
						}
					}

					frameTime = data.frameTime ? data.frameTime : '???';
					wakeTime = data.wakeTime ? data.wakeTime : '???';

					var graphBar = document.createElement('a');
					graphBar.id = frameId + '_b';
					graphBar.title = frameTime + ' secs';
					graphBar.className = 'graphBar' + (data.error === undefined ? '' : ' error');
					graphBar.href = '#'+frameId+'_p';

					if (data.frameTime)
					{
						graphBar.style.height = Math.round(data.frameTime * 2000) + 'px';
					}
					else
					{
						graphBar.style.height = '50px';
						graphBar.style.backgroundColor = '#ff0';
						graphBar.style.borderColor = '#fff';
					}

					graphBar.oncontextmenu = function ()
					{
						document.getElementById(this.id.replace('b', 'p')).oncontextmenu();
						return false;
					};

					if (frameTime < 0.05) { graphBar.className = graphBar.className + ' t1'; }
					else if (frameTime < 0.08) { graphBar.className = graphBar.className + ' t2'; }
					else if (frameTime < 0.1) { graphBar.className = graphBar.className + ' t3'; }
					else { graphBar.className = graphBar.className + ' t4'; }

					graph.appendChild(graphBar);
					graphBar.style.marginTop = (graph.offsetHeight - graphBar.offsetHeight) + 'px';

					var wakePoint = document.createElement('div');

					wakePoint.className = 'wakePoint';

					graphBar.appendChild(wakePoint);

					wakePoint.style.bottom = (wakeTime * 2000) + 'px';

					if (data.FS !== undefined) document.body.scrollTop = document.body.scrollHeight;
				}

				title.innerHTML = locationVals + ' - ' + frameTime + (errorInTitle ? ' ERROR!' : '');

				if (autoScroll) document.body.scrollTop = document.body.scrollHeight;

				if (consoleData.streams !== undefined)
				{
					for (var i in consoleData.streams)
					{
						document.getElementById('stream_' + i).className = consoleData.streams[i] ? 'stream on' : 'stream off';
					}
				}
			}
			consoleWait = false;
		};
	}

	function toggleStream(STREAM)
	{
		notifyServer('console', 'STREAM', STREAM);
	}

	window.onfocus = function() { autoScroll = false; };
	window.onblur = function() { autoScroll = true; };

	document.onkeydown = function(e)
	{
		pressedKeyCode.innerHTML = e.keyCode;

		document.getElementById('input').focus();
		switch (e.keyCode)
		{
//			case 67:
//				content.innerHTML = '';
//				break;

			case 40:
				document.body.scrollTop = document.body.scrollHeight;
				autoScroll = true;
				break;

			case 38:
				autoScroll = false;
				break;

			case 13:
				var input = document.getElementById('input');

				if (input.text !== '')
				{
					notifyServer('console', '<?php echo UIN_TEXT; ?>', input.value);
				}
				break;
		}

	};

	document.onmousedown = function (e)
	{
		document.getElementById('mouseButtonCode').innerHTML = e.button;
	};

	notifyWait = false;

	function notifyServer(key, type, content)
	{
		if (notifyWait) return 0;
		notifyWait = true;

		var rightClick = (rightClick !== undefined && rightClick ? 1 : 0);

		UIEventRequest = new XMLHttpRequest();

		UIEventRequest.open("POST","../../ajax/notifyServer.php","true");
		UIEventRequest.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		UIEventRequest.send('k='+key+'&c='+content+'&t='+type);

		UIEventRequest.onreadystatechange = function()
		{
			notifyWait = false;
			//autoScroll = false;
		};
		return false;
	}

</script>

<?php break; } }


/**
 * Converts the name or key of a direction into an array contating change offset data.
 *
 * @param type $DIR a direction's name or constant value.
 * @return array Associative / numeric array of offset details.
 */
function directionToOffset($DIR)
{
	$n_offset = 0;
	$w_offset = 0;

	if (is_numeric($DIR))
	{
		switch ($DIR)
		{
			case DIR_NORTH:
				$n_offset = -1;
				break;
			case DIR_SOUTH:
				$n_offset = 1;
				break;
			case DIR_WEST:
				$w_offset = -1;
				break;
			case DIR_EAST:
				$w_offset = 1;
				break;
		}
	}
	elseif (is_string($DIR))
	{
		switch(strtolower($DIR[0]))
		{
			case 'n':
				$n_offset = -1;
				break;
			case 's':
				$n_offset = 1;
				break;
			case 'w':
				$w_offset = -1;
				break;
			case 'e':
				$w_offset = 1;
				break;
		}
	}

	// Goddam, this is some ooold shit
	return [0 => $n_offset, 'n' => $n_offset, 'n_change' => $n_offset, 'n_offset' => $n_offset,
			1 => $w_offset, 'w' => $w_offset, 'w_change' => $w_offset, 'w_offset' => $w_offset];
}

/**
 * Returns a direction code from relative offset variables.
 *
 * @param type $n_offset The north change offset.
 * @param type $w_offset The west change offset.
 * @return int Direction constant value.
 */
function offsetToDirection($n_offset, $w_offset)
{
	console_echo("N:{$n_offset}, W:{$w_offset}", '#aff');

	if ($n_offset === 0)
	{
		return ($w_offset > 0 ? DIR_EAST : DIR_WEST);
	}
	else
	{
		return ($n_offset > 0 ? DIR_SOUTH : DIR_NORTH);
	}
}

function addHeader($header, $body)
{
    header("{$header}: {$body}");
}

function shuffle_assoc(&$array)
{
	$keys = array_keys($array);
	$new = [];

	shuffle($keys);

	foreach ($keys as $key)
	{
		$new[$key] = $array[$key];
	}

	$array = $new;
}

function percentageToBool($percentage, $luck = null, $desirable = true)
{
	if (isset($luck) && $luck !== 0)
	{
		if ($luck < 0)
		{
			$desirable = !$desirable;
			$luck = 0 - $luck;
		}

		$tries = floor($luck / 100);
		$extraRollPercentage = $luck % 100;

		for ($try = $tries + 1; $try > 0; $try--)
		{
			if (percentageToBool($percentage) === $desirable) return $desirable;
		}

		if (percentageToBool($extraRollPercentage)) return percentageToBool($percentage);

		return !$desirable;
	}
	else
	{
		$against = 99;

		if ($percentage > 0 && $percentage < 1)
		{
			$against = (int) ($against * (1 / $percentage));
			$percentage = 1;
		}

		return mt_rand(0, $against) < $percentage;
	}
}


function tintByMax($colour, $max)
{
	$splitColour = str_split(trim($colour, '#'));
	foreach ($splitColour as &$char) { $char = hexdec($char); }

//	return tint($colour, $max - max($splitColour));
	return tint($colour, $max);// - max($splitColour));
}

function tint($colour, $amount, $absolute = true)
{
	if ($amount === 0) return $colour;

//	console_echo("Tinting colour by {$amount} " . ($absolute ? 'absolutely.' : 'relatively'));
//	console_echo("BEFORE: " . console_swatch($colour));

	$colour = str_split(trim($colour, '#'));

	foreach ($colour as &$char) { $char = hexdec($char); }

	if ($absolute)
	{
		foreach($colour as &$char)
		{
			$char += $amount;

			if ($char > 15) $char = 15;
			if ($char < 0) $char = 0;

			$char = dechex($char);
		}
	}
	else
	{
		if ($amount > 0)
		{
			$extreme = min($colour);
			$max = 15;
			$multiplier = ($extreme + $amount) / ($extreme <> 0 ? $extreme : 1);
		}
		else
		{
			$extreme = max($colour);
			$max = 0;
			$multiplier = $extreme / ($extreme - $amount <> 0 ? $extreme - $amount : 1);
		}

		foreach ($colour as &$char)
		{
			if ($char === 0 and $amount > 0) $char ++;

			if ($amount > 0)
			{
				$char = $char * $multiplier;
			}
			else
			{
				$char = $char  * $multiplier;
			}

			if ($char > 15) $char = 15;
			if ($char < 0) $char = 0;

			$char = dechex(round($char));

		}
	}

	$colour = '#' . implode($colour);
//	console_echo('AFTER: ' . console_swatch($colour));

	return $colour;
}

function getBetweenColour($col1, $col2)
{
	$col1 = trim($col1, '#');
	$col2 = trim($col2, '#');

	$c11 = hexdec($col1[0]);
	$c12 = hexdec($col1[1]);
	$c13 = hexdec($col1[2]);

	$c21 = hexdec($col2[0]);
	$c22 = hexdec($col2[1]);
	$c23 = hexdec($col2[2]);

	$c1 = (int) (($c11 + $c21) / 2);
	$c2 = (int) (($c12 + $c22) / 2);
	$c3 = (int) (($c13 + $c23) / 2);

	return '#' . implode('', [dechex($c1), dechex($c2), dechex($c3)]);
}

function getLargestIndex($array)
{
	$largestIndex = 0;
	foreach ($array as $index => $value)
	{
		$largestIndex = ($index > $largestIndex ? $index : $largestIndex);
	}
	return $largestIndex;
}

function getNuancedValue($value, $variationPercentage)
{
	$variationPercentage *= 0.01;

	$values = [
		floor($value - ($value * $variationPercentage)),
		ceil($value + ($value * $variationPercentage))
	];

	return mt_rand(min($values),max($values));
}

function getRandomObjectsByClassList ($objects, $classList)
{
	$returnList = [];
	$giveUp = false;

	do
	{
		shuffle ($objects);
		$giveUp = true;

		foreach($objects as $object)
		{
			foreach($classList as $key => $className)
			{
				if (is_a($object, $className))
				{
					$returnList[$key] = $object;
					unset($classList[$key]);
					$giveUp = false;
					break 2;
				}
			}
		}
	}
	while(!$giveUp && !empty($classList));

	if ($giveUp)
	{
		console_echo('Aborting the building of an object list (this is probabaly a materials problem).', '#faa');

//		console_var_dump($objects, '#ffa');
//		console_var_dump($classList, '#faa');

		return false;
	}

	return $returnList;
}

function col($string)
{
	return str_replace(
		[
			'<<',
			'>>',
			'<>'
		],
		[
			'<span style="color:',
			';">',
			'</span>',
		],
		$string);
}

function valueListToValue($valueList)
{
	$baseValue = 0;
	$multiplier = 1;

	foreach ($valueList as $value)
	{
		if (is_string($value))
		{
			$symbol = substr($value, -1, 1);
			if (!is_numeric($symbol)) $value = trim($value, $symbol);

			switch ($symbol)
			{
				case '%':
					$value = $value / 100;
				case '*':
					$multiplier += $value;
					break;
				default:
					$baseValue += $value;
			}
		}
		else
		{
			$baseValue += $value;
		}
	}

	return $baseValue * $multiplier;
}

/**
 * sa (special add)
 * This function allows you to add one number to another in various ways
 * Send the second number as a string with an operator to perform given operator
 * on the first number.
 * Send with a star to add multiples.
 * Send with a percentage sign to add a percentage of the first number to itself.
 *
 * @param type $number - A number
 * @param type $special - A number of string with a '*' or a '%'.
 *
 * @return type
 */
function sa($number, $special)
{
	if (is_string($special))
	{
		$symbol = substr($special, -1, 1);
		if (!is_numeric($symbol)) $special = trim($special, $symbol);
		switch ($symbol)
		{
			case '%':
				$special = 1 + ($special / 100);
				// Note: This only works because there is no 'break' here.
			case '*':
				$number *= $special;
				break;
			default:
				$number += $special;
		}
	}
	else
	{
		$number += $special;
	}

	return $number;
}

const GBC_DEFAULT = 0;
const GBC_PERCENTAGE = 1;
const GBC_DECIMAL = 2;

function getBiasCalculation($biasFor, $biasAgainst, $GBC = 0)
{
	if ($biasFor === 0) return 0;
	if ($biasAgainst === 0) return $biasFor;

	if ($biasFor < 1)
	{
//		console_echo('<<#aaf>>BiasFor<> was too low; noramlising everything to bring it above zero.', '#aaa');
		$biasAgainst += (0 - $biasFor);
		$biasFor = 1;
	}

	if ($biasAgainst < 1)
	{
//		console_echo('<<#fda>>BiasAgainst<> was too low; noramlising everything to bring it above zero.', '#aaa');
		$biasFor += (0 - $biasAgainst);
		$biasAgainst = 1;
	}

//	console_echo("Bias for: <<#fff>>{$biasFor}<>", '#aaf');
//	console_echo("Bias against: <<#fff>>{$biasAgainst}<>", '#fda');

	$result = $biasFor * ($biasFor / ($biasFor + $biasAgainst));

	if ($GBC !== 0)
	{
		$result = ($result / $biasFor);
		if ($GBC == GBC_PERCENTAGE) $result *= 100;
	}

//	console_echo("Result: <<#fff>>{$result}<>", '#afa');

	return $result;
}

function getReadableClass($object, $plural = false)
{
	$className = is_string($object) ? $object : get_class($object);
	$className = explode('_', $className, 2)[1];
	$className = str_split($className);

	$readableClassName = '';

	foreach ($className as $letter)
	{
		if ($letter === strtoupper($letter)) $readableClassName .= ' ';

		$readableClassName .= $letter;
	}

	if ($plural)
	{
		if (substr($readableClassName, -1) == 's') $readableClassName .= 'e';
		$readableClassName .= 's';
	}

	return $readableClassName;
}

function rotatePatternArrayCW($pattern, $_90degX)
{
	if ($_90degX > 3) $_90degX = $_90degX % 4;

	$turn = false;
	$flipX = false;
	$flipY = false;

	switch ($_90degX)
	{
		case 0: return $pattern;
		case 1:
			$turn = true;
			$flipX = true;
			break;
		case 2:
			$flipY = true;
			$flipX = true;
			break;
		case 3:
			$turn = true;
			$flipY = true;
			break;
	}

	$newPattern = [];

	foreach ($pattern as $frame)
	{
		$newFrame = [];

		foreach ($frame as $coOrds)
		{
			$n_offset = $turn ? $coOrds[1] : $coOrds[0];
			$w_offset = $turn ? $coOrds[0] : $coOrds[1];

			$newCoOrds[0] = $flipY ? 0 - $n_offset : $n_offset;
			$newCoOrds[1] = $flipX ? 0 - $w_offset : $w_offset;

			$newFrame[] = $newCoOrds;
		}

		$newPattern[] = $newFrame;
	}

	return $newPattern;
}

function id ($length = 8)
{
	$chars = 'abcdefghijklmnopqrstuvwxyz1234567890';
	$id = '';

	for ($i = 0; $i < $length; $i++)
	{
		$id .= $chars[mt_rand(0, 35)];
	}

	return $id;
}

function intToBinaryBools ($int, $min = null)
{
	$results = [];

	foreach(str_split(decbin($int)) as $a)
	{
		$results[] = $a ? true : false;
	}

	if ($min) $results = array_pad($results, $min, false);

	return $results;
}

function update($UPD, $update)
{
	$updatePreview = htmlspecialchars(json_encode($update, JSON_PRETTY_PRINT));		//XXX
	console_echo("Update sent: {$UPD} - {$updatePreview}", '#aaa', CNS_UPDATES);
	console_echo(">" . (strlen($updatePreview) / 1000) . ' kb', '#fff', CNS_UPDATES);

	// If we have no updates, easy; add the update.
	if (empty($_SESSION['updates'][$UPD]))
	{
		$_SESSION['updates'][$UPD] = $update;
	}
	else // If there is already an update there, less easy; decide how to handle multiple updates in a single transmission.
	{
		switch ($UPD)
		{
			case UPD_STATUS:
				$_SESSION['updates'][$UPD] = $update + $_SESSION['updates'][$UPD];
				break;

			case UPD_CONVERSATION:
				$_SESSION['updates'][$UPD]->lines = array_merge($_SESSION['updates'][$UPD]->lines, $update->lines);
				break;

			case UPD_COMMS:
				$_SESSION['updates'][$UPD] = array_merge($_SESSION['updates'][$UPD], $update);
				break;

			case UPD_SPRITE:
				if (is_array($_SESSION['updates'][$UPD])) $_SESSION['updates'][$UPD][] = $update;
				else $_SESSION['updates'][$UPD] = [$_SESSION['updates'][$UPD], $update];
				break;

			case UPD_COMBAT:
				$_SESSION['updates'][$UPD]->events = array_merge($_SESSION['updates'][$UPD]->events, $update->events);
				break;

			case UPD_PLAYER_STATUS:
				$_SESSION['updates'][$UPD] = array_merge($_SESSION['updates'][$UPD], $update);
				break;

			case UPD_STATS:
				$_SESSION['updates'][$UPD]->shallow = $update->shallow + $_SESSION['updates'][$UPD]->shallow;
				$_SESSION['updates'][$UPD]->deep = $update->deep + $_SESSION['updates'][$UPD]->deep;
				break;

			case UPD_TASKS:
				$_SESSION['updates'][$UPD]->tasks = array_merge($update->tasks, $_SESSION['updates'][$UPD]->tasks);
				break;

			case UPD_ITEMS:
				$_SESSION['updates'][$UPD]->items = array_merge($update->items, $_SESSION['updates'][$UPD]->items);
				break;

			case UPD_SOUNDS:
				$_SESSION['updates'][$UPD]= array_merge($update, $_SESSION['updates'][$UPD]);
				break;

			case UPD_INTERACTIONS:
				if (!is_array($_SESSION['updates'][$UPD])) $_SESSION['updates'][$UPD] = [$_SESSION['updates'][$UPD]];
				$_SESSION['updates'][$UPD][] = $update;
				break;
			default:
				$_SESSION['updates'][$UPD] = $update;
		}
	}
}

function clearPanel($UPD)
{
	$_SESSION['updates'][$UPD] = UPDB_CLEAR;
	console_echo("Update sent: {$UPD} - CLEAR", '#caa');	//XXX
}


function update_text($header, $text, $bg, $fg, $height = null, $width = null)
{
	$update = new stdClass();

	if (is_string($text) && strtolower(substr($text, -4)) == '.tex')
	{
		include "{$GLOBALS['rootPath']}content/text/$text";
	}

	$update->commType = 'text';
	$update->header = $header;
	$update->body = is_array($text) ? $text : [$text];
	$update->bg = $bg;
	$update->fg = $fg;
	$update->height = $height;
	$update->width = isset($width) ? $width : 20;

	update(UPD_COMMS, [$update]);
}


function update_conversation($name, $body, $colour)
{

	$item = new stdClass();

	$item->name = $name;
	$item->commType = 'speech';
	$item->body = $body;
	$item->nameColour = $colour;

	update(UPD_COMMS, [$item]);
}


function update_money()
{
	global $player;
	global $currencies;

	$update = new stdClass();

	$update->currencies = [];

	foreach ($player->wallet->contents as $CUR => $amount)
	{
		$currency = new stdClass();

		$currency->symbol	= $currencies[$CUR]->symbol;
		$currency->name		= $currencies[$CUR]->name;
//		$currency->amount	= number_format($amount, 2);
		$currency->amount	= number_format($amount);

		$update->currencies[] = $currency;
	}

	update(UPD_MONEY, $update);
}


function update_thoughts($thought)
{
	global $player;

	$player->speak($thought);
}

function update_sprite($spriteKey, Sprite $overSprite, $augment = true)
{
	$update = new stdClass();
	$update->key = $spriteKey;
	$update->sprite = $overSprite->getJsonObject();
	$update->augment = $augment;
	update(UPD_SPRITE, $update);
}


function update_items(Item $item = null)
{
	global $player;

	$player->handleEventOfInterest(EOI_INVENTORY);

	$update = new stdClass();

	console_echo('Items have prices? ' . ($player->showItemPrices ? 'true' : 'false'));

	if ($item)
	{
		$update->items = [$item->getAjaxObject()];
	}
	else
	{
		$update->refresh = true;
		$update->items = $player->inventory->getAjaxObjects();
	}

	update(UPD_ITEMS, $update);
}

function update_title($text)
{
	update('title', $text);
}


function update_available(Item $item = null)
{
	global $player;

	$update = new stdClass();

	if (isset($player->engagement->inventory))
	{

		if ($item)
		{
			$update->items = [$item->getAjaxObject()];
		}
		else
		{
			$update->refresh = true;
			$update->items = $player->engagement->inventory->getAjaxObjects();
		}

		$update->header = $player->engagement->name;
		$update->isEmpty = !(count($update->items) > 0);

		update(UPD_AVAILABLE, $update);
	}
}

//function update_itemInfo($string, Sprite $sprite = null)
function update_itemInfo(Item $item)
{
	global $player;
	global $view;

	global $DS_names;

	$update = new stdClass();

	$update->name = $item->name;
	$update->sprite = $view->addClientSprite($item->sprite)->key;
	$update->description = $item->description;
	$update->id = $item->id;

	if ($item->level) $update->level = $item->level;

	if (isset($item->durability))
	{
		$update->dur = $item->durability;
		$update->durMax = $item->durabilityMax;
	}

	$update->behaviours = [];
	foreach ($item->behaviours as $behaviours)
	{
		foreach ($behaviours as $behaviour)
		{
			$update->behaviours[] = $behaviour->description;
		}
	}

	if ($item instanceof Equipment)
	{
		$existingItem = $player->getItemByEQP($item->EQP);

		$update->EQP = $item->EQP;

		if (isset($item->DSs))
		{
			$update->DSs = $item->DSs;

			foreach ($update->DSs as $DS => &$val)
			{
				switch ($DS) // Switch for handling special cases
				{
					case DS_LUCK:
						$val = $val > 0 ? 'lucky' : 'unlucky';
						continue;
				}

				if ($existingItem && isset($existingItem->DSs[$DS]) && $val != $existingItem->DSs[$DS])
				{
					$val = ($existingItem->DSs[$DS] < $val ? '{g}' : '{r}') . $val;
				}
				else
				{
					$val = "{w}{$val}";
				}
			}
		}
		if (isset($item->DSs_req))
		{
			$update->DSs_req = $item->DSs_req;

			foreach ($update->DSs_req as $DS => &$val)
			{
				$val = ($player->$DS_names[$DS] >= $val ? '{g}' : '{r}') . $val;
			}
		}

		if (isset($item->DMGs))
		{
			$update->DMGs = $item->DMGs;

			foreach ($update->DMGs as $DMG => &$val)
			{
				if ($existingItem && isset($existingItem->DMGs[$DMG]) && $val != $existingItem->DMGs[$DMG])
				{
					$val = ($existingItem->DMGs[$DMG] < $val ? '{g}' : '{r}') . $val;
				}
				else
				{
					$val = "{w}{$val}";
				}
			}
		}
		if (isset($item->DMGs_def))
		{
			$update->DMGs_def = $item->DMGs_def;

			foreach ($update->DMGs_def as $DMG => &$val)
			{
				if ($existingItem && isset($existingItem->DMGs_def[$DMG]) && $val != $existingItem->DMGs_def[$DMG])
				{
					$val = ($existingItem->DMGs_def[$DMG] < $val ? '{g}' : '{r}') . $val;
				}
				else
				{
					$val = "{w}{$val}";
				}
			}
		}

		if (isset($item->DMGDL)) $update->DMGDL = $item->DMGDL;
	}

	update(UPD_ITEM_INFO, $update);
}

function update_overlay($colour, $opacity)
{
	$update = new stdClass();

	$update->colour = $colour;
	$update->opacity = $opacity;

	update(UPD_OVERLAY, $update);
}

function update_jvsKeys()
{
	global $map;

	$update = ['tileKey' => $map->tileKeyJson, 'spriteKey' => $map->spriteKeyJson, 'css' => $map->css, 'mapName' => $map->MAP];

	update(UPD_JVS_KEYS, $update);
}

/**
 * Updates the combat panel. The body string is parsed using function col. Adhere to the following standards when sending information here:
 *
 * #fff - Player and enemy names
 * #f00 - damage
 * #0f0 - healing
 * #00f - skills
 *
 * @param type $body - This string will be parsed with funtion col.
 */
function update_combat($body)
{
	$update = new stdClass();
	$update->events = [];

	$event = new stdClass();
	$event->body = col("{$body}");
	$update->events[] = $event;

	update(UPD_COMBAT, $update);
}

function update_playerHp($value = null)
{
	global $player;

	$update = new stdClass();
	$update->hpMax = $player->hp_max;
	$update->hp = isset($value) ? $value : $player->hp;
	$update->hp = round($update->hp, 1);

	update(UPD_HP, $update);
}

function update_playerEp($value = null)
{
	global $player;

	$update = new stdClass();
	$update->epMax = $player->ep_max;
	$update->ep = isset($value) ? $value : $player->ep;
	$update->ep = round($update->ep, 1);

	update(UPD_EP, $update);
}

function update_playerXp($value = null, $lvl = null)
{
	global $player;

	$update = new stdClass();
	$update->xpMax = $player->nextLevel;
	$update->xp = isset($value) ? $value : $player->xp;
	$update->xp = round($update->xp);

	if ($lvl)
	{
		$update->lvl = $lvl;
	}

	update(UPD_XP, $update);
}

function update_stats($stats = null)
{
	global $player;
	global $DS_typed;

	$update = new stdClass();

	$update->shallow	= array_intersect_key($player->getShallowArray('DSs'), $DS_typed);
	$update->deep		= array_intersect_key($player->getDeepArray('DSs'), $DS_typed);

	if (is_array($stats))
	{
		$stats				= array_flip($stats);
		$update->shallow	= array_intersect_key($update->shallow, $stats);
		$update->deep		= array_intersect_key($update->deep, $stats);
		$update->rebuild	= false;
	}
	else
	{
		$update->rebuild	= true;
	}

	update(UPD_STATS, $update);

	update_readiness();
}

function update_readiness()
{
	global $player;

	if (!isset($player->attack)) $player->attack = new Attack($player);

	$DPS = 0;
	$DMGs = $player->attack->base_DMGs;

	$playerBiases = $player->getTEQbiases();
	$cooldown = $player->attack->getcooldown($playerBiases[TEQ_ATTACK_SPEED]);
	$DPS = number_format(array_sum($DMGs) / $cooldown, 1);

	$update = [
		'DMGs'	=> $DMGs,
		'DMGDL'	=> $player->DMGDL,
		'DMGs_def' => $player->DMGs_def,
		'DPS' => $DPS,
		'APS' => round(1 / $cooldown, 1),
	];

	update(UPD_DMG_DEF, $update);
}

function update_opponent()
{
	global $player;
	global $view;

	if ($player->distanceFrom($player->opponent) < 10)
	{
		$update = new stdClass();

		$playerBiases	= $player->getTEQbiases();
		foreach($playerBiases as &$value) $value += $value * (($player->level - $player->opponent->level) * 0.2);
		$opponentBiases	= $player->opponent->getTEQbiases();
//		foreach($opponentBiases as &$value) $value *= $player->opponent->level / $player->level;

		$update->name	= $player->opponent->name;
		$update->hp		= round($player->opponent->hp, 1);
		$update->hpMax	= $player->opponent->hp_Max;
		$update->lvl	= $player->opponent->level;

		$update->hc		= getBiasCalculation($playerBiases[TEQ_HIT_CHANCE], $opponentBiases[TEQ_DODGE_CHANCE], GBC_PERCENTAGE);
		$update->hc		= number_format($update->hc, 1);
		$update->hcB	= $playerBiases[TEQ_HIT_CHANCE];

		$update->dc		= 100 - getBiasCalculation($opponentBiases[TEQ_HIT_CHANCE], $playerBiases[TEQ_DODGE_CHANCE], GBC_PERCENTAGE);
		$update->dc		= number_format($update->dc, 1);
		$update->dcB	= $playerBiases[TEQ_DODGE_CHANCE];

		$update->cc		= getBiasCalculation($playerBiases[TEQ_CRIT_CHANCE], $opponentBiases[TEQ_DODGE_CHANCE], GBC_PERCENTAGE);
		$update->cc		= number_format($update->cc, 1);
		$update->ccB	= $playerBiases[TEQ_CRIT_CHANCE];


		if ($player->opponent->statuses)
		{
			$update->statuses = [];

			foreach ($player->opponent->statuses as $status)
			{
				$upd = new stdClass();
				$upd->spr = $view->addClientSprite($status->sprite)->key;
				$upd->desc = $status->description;

				$update->statuses[] = $upd;
			}
		}

		update(UPD_OPPONENT, $update);
	}
	else
	{
		$player->opponent = null;
		clearPanel(UPD_OPPONENT);
	}
}

function update_statuses()
{
	global $player;

	$player->checkStatuses();
}

function update_quests($quests = null)
{
	global $player;

	$update = new stdClass();

	$update->quests = [];

	$player->getActiveTasks();

	$discardComplete = false;

	if (empty($quests))
	{
		$quests = $player->quests;
		// If we're getting all of them, it's probably because we're populating
		// the quest panel on load, not because something has actually happened
		// so don't notify.
		$update->notify = false;

		$update->completed = [];
		foreach ($player->completedQuests as $name => $timestamp)
		{
			$update->completed[$name] = date('m/d/y', $timestamp);
		}
		$discardComplete = true;
	}
	else
	{
		// We were told to update a specific quest(s); something probabaly
		// actually happened; we should update.
		$update->notify = true;
	}

	foreach ($quests as $key => $quest)
	{
		if ($discardComplete && $quest->complete)
		{
			unset($player->quests[$key]);
			continue;
		}
		if (!$quest->hidden) $update->quests[] = $quest->getAjaxObject();
	}

	update(UPD_QUESTS, $update);
}

function update_task(Task $task)
{
	$update = new stdClass();

	$update->tasks = [];

	$update->tasks[] = $task->getAjaxObject();

	update(UPD_TASKS, $update);
}

function update_skills()
{
	global $player;

//	if ($player instanceof EditorPlayer2)
//	{
//		update_skills_EDITOR();
//		return;
//	}

	$update = [];

	foreach ($player->skills as $index => $skill)
	{
		$s = new stdClass();

		$s->name = $skill->name;
		$s->level = $skill->level;
		if ($skill->SKLS) $s->SKLS = $skill->SKLS;

		$update["{$index}"] = $s;
	}

	update(UPD_SKILLS, $update);
}

function update_passives ()
{
	global $player;

	$update = [];

	foreach ($player->passives as $index => $passive)
	{
		$p = new stdClass();

		$p->name = $passive->name;
		$p->level = $passive->level;

		$update["{$index}"] = $p;
	}

	update(UPD_PASSIVES, $update);
}

function update_skillInfo(Skill $skill)
{
	global $view;

	$update = new stdClass();

	$update->name	= $skill->name;
	$update->desc	= $skill->getDescription();

	$update->sprite	= $view->addClientSprite($skill->sprite)->key;

	$update->level	= $skill->level;
	$update->id		= $skill->key;

	if ($skill->epCost)		$update->ep			= $skill->epCost;
	if ($skill->hpCost)		$update->hp			= $skill->hpCost;
	if ($skill->cooldown)	$update->cooldown	= $skill->cooldown;
	if ($skill->range)		$update->range		= $skill->range;

	update(UPD_SKILL_INFO, $update);
}

function update_passiveInfo(Passive $passive)
{
	global $view;

	$update = new stdClass();

	$update->name	= $passive->name;
	$update->desc	= $passive->getDescription();

	$update->sprite	= $view->addClientSprite($passive->sprite)->key;

	$update->level	= $passive->level;
	$update->id		= $passive->key; //get_class($skill);

	if ($passive->cooldown)	$update->cooldown	= $passive->cooldown;

	update(UPD_PASSIVE_INFO, $update);
}

function update_bindings()
{
	global $player;
	global $view;

	$update = [];

	foreach ($player->bindings as $SKLS => $binding) // $action will be a skill or (eventually) an item
	{
		$b = new stdClass();
		$action = $binding->getSubject();

		if ($view) $b->sprite = $view->addClientSprite($action->sprite)->key;
		$b->desc = isset($action->description) ? $action->description : $action->getDescription();

		$update[$SKLS] = $b;
	}

	update(UPD_BINDINGS, $update);
}

function update_technique ()
{
	global $player;

	$update = [
		TEQT_MELEE		=> $player->getTEQbiases(TEQT_MELEE,	true),
		TEQT_RANGED	=> $player->getTEQbiases(TEQT_RANGED,	true),
		TEQT_MAGIC		=> $player->getTEQbiases(TEQT_MAGIC,	true),
	];

	update(UPD_TECHNIQUE, $update);
}

function update_boons ()
{
	global $player;

	$update = new stdClass();

	$update->boons = [];
	$update->pending = $player->pendingBoonCount;

	foreach ($player->pendingBoons as $index => $boon)
	{
		$update->boons[] = [
			'key' => $index,
			'name' => $boon->name,
			'desc' => $boon->description,
		];
	}

	update(UPD_BOONS, $update);
}

function update_sound ($SND)
{
	update(UPD_SOUNDS, func_get_args());
}

class SpriteElement
{
    public $bg;
    public $fg;
    public $char;

    function __construct($background, $foreground, $character)
    {
//		if (is_object($background)) console_warning('Fucked up sprite element!');	//XXX
//		if (is_object($foreground)) console_warning('Fucked up sprite element!');	//XXX

        $this->bg = $background;
        $this->fg = $foreground;
		if (!$character) $character = '&nbsp;';
        $this->char = $character === ' ' ? '&nbsp;' : $character;
    }

    function __toString()
    {
        return '<span style=\'' .
                (isset($this->bg) ? "background-color:{$this->bg};" : null) .
                (isset($this->fg) ? "color:{$this->fg};" : null) .
                "'>{$this->char}</span>";
    }

	function equals(SpriteElement $compare)
	{
		return $this->bg === $compare->bg
			&& $this->fg === $compare->fg
			&& $this->char === $compare->char;
	}
}

class Sprite
{
    public $key;
	public $frames = [];

//	public $jsonObject;

    function __construct($frames)
    {
		if (is_array(current($frames))) $this->frames = $frames;
		else $this->frames[] = $frames;

		foreach ($this->frames as $index => $frame) $this->frames[$index] = array_filter($frame);

//		foreach ($this->frames as $frame)
//		{
//			foreach ($frame as $element)
//			{
//				if (!($element instanceof SpriteElement))
//				{
//					console_echo('WTF IS THIS DOING IN HERE???', '#faa');
//					console_var_dump($element, '#faa');
//				}
//			}
//		}


    }

	function getHTML()
	{
		$html = '<div style="display:inline-block;">';

		$html .= isset($this->frames[0][0]) ? $this->frames[0][0] : '&nbsp;';
		$html .= isset($this->frames[0][1]) ? $this->frames[0][1] : '&nbsp;';
		$html .= isset($this->frames[0][2]) ? $this->frames[0][2] : '&nbsp;';
		$html .= '<br>';
		$html .= isset($this->frames[0][3]) ? $this->frames[0][3] : '&nbsp;';
		$html .= isset($this->frames[0][4]) ? $this->frames[0][4] : '&nbsp;';
		$html .= isset($this->frames[0][5]) ? $this->frames[0][5] : '&nbsp;';

		return $html . '</div>';
	}

	function getJS()
	{
		return "var spr_{$this->key}=" . json_encode($this->getJsonObject()) . ";";
	}

	function getJsonObject()
	{
		$jsonObject = new stdClass();

		$jsonObject->f = 0;

		foreach($this->frames as $fIndex => $frame)
		{
			$jsonObject->{"f{$fIndex}"} = new stdClass();

			foreach ($frame as $eIndex => $element)
			{
				$jsonObject->{"f{$fIndex}"}->{"e{$eIndex}"} = "{$element}"; // Terrible
			}
			$jsonObject->f++;
		}

		return $jsonObject;
	}

	function getBodyColour()
	{
		if(isset($this->frames[0][4]->fg))
			return $this->frames[0][4]->fg;

		console_echo('Couldn\'t find an appropriate body colour for this sprite:'. console_sprite($this), '#faa');
		return '#fff';
	}

	public function augment($overSprite)
	{
		$osFrames = count($overSprite->frames);
		$hostFrames = count($this->frames);

		$frames = $osFrames > $hostFrames ? $osFrames : $hostFrames;

		$newSpriteFrames = [];

		for ($f = 0; $f < $frames; $f++)
		{
			for ($e = 0; $e <= 5; $e++)
			{
				if (isset($overSprite->frames[$f % $osFrames][$e]))
				{
					$newSpriteFrames[$f][$e] = $overSprite->frames[$f % $osFrames][$e];
				}
				elseif (isset($this->frames[$f % $hostFrames][$e]))
				{
					$newSpriteFrames[$f][$e] = $this->frames[$f % $hostFrames][$e];
				}
			}
		}

		return new Sprite($newSpriteFrames);
	}

	function change(Sprite $sprite, $augment = true)
	{
		update_sprite($this->key, $sprite, $augment);
		$this->frames = $sprite->frames;
	}

	function getMainColour()
	{
		$vote = [];
		foreach ($this->frames as $frame)
		{
			foreach ($frame as $element)
			{
				if (isset($element->bg))
				{
					if (isset($vote[$element->bg]))
					{
						$vote[$element->bg] += 2;
					}
					else
					{
						$vote[$element->bg] = 2;
					}
				}

				if (isset($element->fg))
				{
					if (isset($vote[$element->fg]))
					{
						$vote[$element->fg] += 1;
					}
					else
					{
						$vote[$element->fg] = 1;
					}
				}
			}
		}

		//console_echo( 'Main sprite colour: ' . array_search(max($vote), $vote));

		return array_search(max($vote), $vote);
	}

	function equals(Sprite $sprite)
	{

		foreach ($this->frames as $frameNo => $frame)
		{
			if (array_keys($frame) !== array_keys($sprite->frames[$frameNo])) return false;

			foreach ($frame as $index => $element)
			{

				if (!$sprite->frames[$frameNo][$index]->equals($element)) return false;
			}
		}
		return true;
	}

	function __clone()
	{
		$frames = [];

		foreach ($this->frames as $frame => $elements)
		{
			foreach ($elements as $index => $element)
			{
				$frames[$frame][$index] = clone $element;
			}
		}

		$this->frames = $frames;
	}

	public function __debugInfo()
	{
		return [
			'key'		=> $this->key,
			'frames'	=> console_sprite($this)
		];
	}

//	public function __toString()
//	{
//		console_var_dump($this);
//		return '';
//	}
}

function flipSprite (Sprite $sprite)
{
	$frames		= [];
	$frameNo	= 0;
	foreach ($sprite->frames as $frame)
	{
		foreach ($frame as $index => $element)
		{
			$frames[$frameNo][$index + ($index > 2 ? -3 : 3)] = $element;
		}
		$frameNo++;
	}

	return new Sprite($frames);
}

function paintSprite (Sprite $sprite, $colour)
{
//	$sprite = clone $sprite;

	$new_frames = [];

	foreach ($sprite->frames as $frame)
	{
		$new_frame = [];

		foreach ($frame as $index => $element)
		{
//			if (isset($element->bg)) $element->bg = $colour;
//			if (isset($element->fg)) $element->fg = $colour;

			$new_frame[$index] = new SpriteElement(
				isset($element->bg) ? $colour : null,
				isset($element->fg) ? $colour : null,
				$element->char);
		}

		$new_frames[] = $new_frame;
	}

	return new Sprite($new_frames);
}

function halveSprite(Sprite $sprite, $takeTop = true)
{
	$sprite = clone $sprite;
	if ($takeTop)
	{
		foreach ($sprite->frames as &$frame)
		{
			unset($frame[3]);
			unset($frame[4]);
			unset($frame[5]);
		}
	}
	else
	{
		foreach ($sprite->frames as &$frame)
		{
			unset($frame[0]);
			unset($frame[1]);
			unset($frame[2]);
		}
	}

	console_echo('Halved sprite: ' . console_sprite($sprite), '#afa');

	return new Sprite($sprite->frames);
}

function tileToSprite (Tile $tile)
{
	if (count($tile->chars) === 6)
	{
		return new Sprite([
			new SpriteElement($tile->bg, $tile->fg, $tile->chars[0]),
			new SpriteElement($tile->bg, $tile->fg, $tile->chars[1]),
			new SpriteElement($tile->bg, $tile->fg, $tile->chars[2]),
			new SpriteElement($tile->bg, $tile->fg, $tile->chars[3]),
			new SpriteElement($tile->bg, $tile->fg, $tile->chars[4]),
			new SpriteElement($tile->bg, $tile->fg, $tile->chars[5]),
		]);
	}
	else
	{
		$frames = [];

		for ($i = 0; $i <= 3; $i++)
		{
			$frame = [];

			for ($j = 0; $j <= 5; $j ++)
			{
				$frame[$j] = new SpriteElement($tile->bg, $tile->fg, $tile->chars[array_rand($tile->chars)]);
			}

			$frames[] = $frame;
		}

		return new Sprite($frames);
	}
}

// These sprites are used and called from all over the place. This keeps them
// central without having to cehck for prior inclusion.

///////////////////////////////////
// FIRE
///////////////////////////////////

$col_fire		= '#fc0';

$slm_fire_1		= new SpriteElement(null, $col_fire, ')');
$slm_fire_2		= new SpriteElement(null, $col_fire, '(');

$ospr_fire	= new Sprite([
	[
		0 => $slm_fire_1,
		2 => $slm_fire_1,
	],
	[
		0 => $slm_fire_2,
		2 => $slm_fire_2,
	]
]);

$spr_fireEffect = new Sprite([
	[
		0 => $slm_fire_1,
		5 => $slm_fire_1,
	],
	[
		1 => $slm_fire_2,
		3 => $slm_fire_2,
	],
	[
		2 => $slm_fire_1,
		4 => $slm_fire_2,
	],
]);

$spr_fireIcon = new Sprite([
	0 => new SpriteElement(null, $col_fire, '('),
	1 => new SpriteElement(null, $col_fire, '('),
	3 => new SpriteElement(null, $col_fire, '('),
	4 => new SpriteElement(null, $col_fire, '&#x25b2;'),
	5 => new SpriteElement(null, $col_fire, ')'),
]);

///////////////////////////////////
// COLD
///////////////////////////////////

$col_cold		= '#fff';

$slm_cold_1		= new SpriteElement(null, $col_cold, '*');
$slm_cold_2		= new SpriteElement(null, $col_cold, '+');
$slm_cold_3		= new SpriteElement(null, $col_cold, '.');

$ospr_cold	= new Sprite([
	[
		0 => $slm_cold_1,
		2 => $slm_cold_3,
	],
	[
		0 => $slm_cold_2,
	],
	[
		0 => $slm_cold_3,
		2 => $slm_cold_1,
	],
	[
		2 => $slm_cold_2,
	],
]);

$spr_coldEffect = new Sprite([
	[
		0 => $slm_cold_1,
		4 => $slm_cold_3,
	],
	[
		0 => $slm_cold_2,
		2 => $slm_cold_1,
	],
	[
		0 => $slm_cold_3,
		4 => $slm_cold_1,
		2 => $slm_cold_2,
	],
	[
		4 => $slm_cold_2,
		2 => $slm_cold_3,
	],
]);


$spr_coldIcon = new Sprite([
	0 => new SpriteElement(null, $col_cold, '&#x25b2;'),
	1 => new SpriteElement(null, $col_cold, '&#x25bc;'),
	2 => new SpriteElement(null, $col_cold, '&#x25b2;'),
	3 => new SpriteElement(null, $col_cold, '&#x25bc;'),
	4 => new SpriteElement(null, $col_cold, '&#x25b2;'),
	5 => new SpriteElement(null, $col_cold, '&#x25bc;'),
]);

///////////////////////////////////
// POISON
///////////////////////////////////

$col_poison		= '#0d0';

$slm_poison_1	= new SpriteElement(null, $col_poison, '&deg;');
$slm_poison_2	= new SpriteElement(null, $col_poison, '&bull;');
$slm_poison_3	= new SpriteElement(null, $col_poison, 'o');

$ospr_poison	= new Sprite([
	[
		0 => $slm_poison_1,
		2 => $slm_poison_2,
	],
	[
		0 => $slm_poison_2,
		2 => $slm_poison_3,
	],
	[
		0 => $slm_poison_3,
		2 => $slm_poison_2,
	],
	[
		0 => $slm_poison_2,
		2 => $slm_poison_1,
	],
]);

$spr_poisonEffect = new Sprite([
	[
		0 => $slm_poison_3,
		5 => $slm_poison_1,
	],
	[
		4 => $slm_poison_1,
		5 => $slm_poison_2,
	],
	[
		0 => $slm_poison_1,
		4 => $slm_poison_2,
		5 => $slm_poison_3,
	],
	[
		0 => $slm_poison_2,
		4 => $slm_poison_3,
	],
]);

$spr_poisonIcon = new Sprite([
	1 => new SpriteElement(null, $col_poison, '&#x2640;'),
	4 => new SpriteElement(null, $col_poison, 'X'),
]);

///////////////////////////////////
// ELECTRIC
///////////////////////////////////

$col_electric	= '#0df';

$slm_electric_0	= new SpriteElement(null, $col_electric, '&mdash;');
$slm_electric_l	= new SpriteElement(null, $col_electric, '>');
$slm_electric_r	= new SpriteElement(null, $col_electric, '<');

$ospr_electric	= new Sprite([
	[
		0 => $slm_electric_0,
		2 => $slm_electric_0,
	],
	[
		0 => $slm_electric_l,
		2 => $slm_electric_r,
	],
]);

$spr_electricEffect = new Sprite([
	[
		1 => $slm_electric_l,
		2 => $slm_electric_0,
		3 => $slm_electric_r,
	],
	[
		0 => $slm_electric_0,
		1 => $slm_electric_r,
		5 => $slm_electric_l,
	],
]);

$spr_electricIcon = new Sprite([
	1 => new SpriteElement(null, $col_electric, '\\'),
	4 => new SpriteElement(null, $col_electric, '/'),
	5 => new SpriteElement(null, $col_electric, '&#x03bb;'),
	]);

///////////////////////////////////
// WATER
///////////////////////////////////

$col_water		= '#8af';

$slm_water_1	= new SpriteElement(null, $col_water, '&deg;');
$slm_water_2	= new SpriteElement(null, $col_water, '&bull;');
$slm_water_3	= new SpriteElement(null, $col_water, '.');

$ospr_water		= new Sprite([
	[
		0 => $slm_water_1,
		2 => $slm_water_3,
	],
	[
		0 => $slm_water_2,
	],
	[
		0 => $slm_water_3,
		2 => $slm_water_1,
	],
	[
		2 => $slm_water_2,
	],
]);

$spr_waterEffect = new Sprite([
	[
		1 => $slm_water_3,
		5 => $slm_water_1,
	],
	[
		3 => $slm_water_1,
		5 => $slm_water_2,
	],
	[
		1 => $slm_water_1,
		3 => $slm_water_2,
		5 => $slm_water_3,
	],
	[
		1 => $slm_water_2,
		3 => $slm_water_3,
	],
]);

$spr_waterIcon = new Sprite([
	0 => new SpriteElement(null, $col_water, '&#x2591;'),
	1 => new SpriteElement(null, $col_water, '&#x2591;'),
	2 => new SpriteElement(null, $col_water, '&#x2591;'),
	3 => new SpriteElement(null, $col_water, 'H'),
	4 => new SpriteElement(null, $col_water, '&#x00b2;'),
	5 => new SpriteElement(null, $col_water, 'O'),
]);

///////////////////////////////////
// TRAUMA
///////////////////////////////////

$col_trauma		= '#c00';

//$slm_trauma_1	= new SpriteElement(null, $col_trauma, '&deg;');
//$slm_trauma_2	= new SpriteElement(null, $col_trauma, '&bull;');
//$slm_trauma_3	= new SpriteElement(null, $col_trauma, '.');

$slm_trauma_1	= new SpriteElement(null, $col_trauma, '&#x0387');
$slm_trauma_2	= new SpriteElement(null, $col_trauma, '&bull;');
$slm_trauma_3	= new SpriteElement(null, $col_trauma, '&#x263c;');
$slm_trauma_4	= new SpriteElement(null, $col_trauma, 'O');

$ospr_trauma	= new Sprite([
	[
		0 => $slm_trauma_1,
		2 => $slm_trauma_3,
	],
	[
		0 => $slm_trauma_2,
		2 => $slm_trauma_4,
	],
	[
		0 => $slm_trauma_3,
		2 => $slm_trauma_1,
	],
	[
		0 => $slm_trauma_4,
		2 => $slm_trauma_2,
	],
]);

$spr_traumaEffect = new Sprite([
	[
		1 => $slm_trauma_4,
		5 => $slm_trauma_1,
	],
	[
		3 => $slm_trauma_1,
		5 => $slm_trauma_2,
	],
	[
		1 => $slm_trauma_1,
		3 => $slm_trauma_2,
		5 => $slm_trauma_3,
	],
	[
		1 => $slm_trauma_2,
		5 => $slm_trauma_4,
		3 => $slm_trauma_3,
	],
	[
		1 => $slm_trauma_3,
		3 => $slm_trauma_4,
	],
]);

$spr_traumaIcon = new Sprite([
	0 => new SpriteElement(null, $col_trauma, '&#x25bc;'),
	1 => new SpriteElement(null, $col_trauma, '&#x25bc;'),
	2 => new SpriteElement(null, $col_trauma, '&#x25bc;'),
	3 => new SpriteElement(null, $col_trauma, '&#x25b2;'),
	4 => new SpriteElement(null, $col_trauma, '&#x25b2;'),
	5 => new SpriteElement(null, $col_trauma, '&#x25b2;'),
]);

///////////////////////////////////
// INFECTION
///////////////////////////////////

$col_infection		= '#ff0';

$slm_infection_1	= new SpriteElement(null, $col_infection, '&#x03be;');
$slm_infection_2	= new SpriteElement(null, $col_infection, '&#x03c2;');
$slm_infection_3	= new SpriteElement(null, $col_infection, 'S');

$ospr_infection		= new Sprite([
	[
		0 => $slm_infection_1,
		2 => $slm_infection_2,
	],
	[
		0 => $slm_infection_2,
		2 => $slm_infection_3,
	],
	[
		0 => $slm_infection_3,
		2 => $slm_infection_1,
	]
]);

$spr_infectionEffect	= new Sprite([
	[
		0 => $slm_infection_1,
		2 => $slm_infection_2,
		4 => $slm_infection_3,
	],
	[
		0 => $slm_infection_2,
		2 => $slm_infection_3,
		4 => $slm_infection_1,
	],
	[
		0 => $slm_infection_3,
		2 => $slm_infection_1,
		4 => $slm_infection_2,
	]
]);

$spr_infectionIcon = new Sprite([	// This is shit and garbage; change it.
	1 => new SpriteElement(null, $col_infection, 'V'),
	3 => new SpriteElement(null, $col_infection, '>'),
	4 => new SpriteElement(null, $col_infection, '&bull;'),
	5 => new SpriteElement(null, $col_infection, '<'),
]);


$DMG_osprs = [
	DMG_COLD		=> $ospr_cold,
	DMG_ELECTRIC	=> $ospr_electric,
	DMG_FIRE		=> $ospr_fire,
	DMG_POISON		=> $ospr_poison,
	DMG_WATER		=> $ospr_water,
	DMG_TRAUMA		=> $ospr_trauma,
	DMG_INFECTION	=> $ospr_infection,
];

$DMG_effects = [
	DMG_COLD		=> $spr_coldEffect,
	DMG_ELECTRIC	=> $spr_electricEffect,
	DMG_FIRE		=> $spr_fireEffect,
	DMG_POISON		=> $spr_poisonEffect,
	DMG_WATER		=> $spr_waterEffect,
	DMG_TRAUMA		=> $spr_traumaEffect,
	DMG_INFECTION	=> $spr_infectionEffect,
];

$DMG_icons = [
	DMG_COLD		=> $spr_coldIcon,
	DMG_ELECTRIC	=> $spr_electricIcon,
	DMG_FIRE		=> $spr_fireIcon,
	DMG_POISON		=> $spr_poisonIcon,
	DMG_WATER		=> $spr_waterIcon,
	DMG_TRAUMA		=> $spr_traumaIcon,
	DMG_INFECTION	=> $spr_infectionIcon,
];

$DMG_colours = [
	DMG_COLD => $col_cold,
	DMG_ELECTRIC => $col_electric,
	DMG_FIRE => $col_fire,
	DMG_POISON => $col_poison,
	DMG_WATER => $col_water,
	DMG_TRAUMA => $col_trauma,
	DMG_INFECTION => $col_infection,
];

///////////////////////////////////
// DSs
///////////////////////////////////

function spr_DS_boost($DS)
{
	global $DS_names;
	global $DS_colours;

	$letter = strtoupper(substr($DS_names[$DS], 0, 1));
	$DS_base = $DS - ($DS % 100);

	$spe_letter = new SpriteElement(null, '#fff', $letter);
	$spe_solid = new SpriteElement(null, $DS_colours[$DS_base], '&#x25b2;');
//	$spe_hollow = new SpriteElement(null, $DS_colours[$DS_base], '&Delta;');
	$spe_hollow = new SpriteElement(null, $DS_colours[$DS_base], '&#x039b;');

	return new Sprite([
		[ 3 => $spe_solid,	4 => $spe_letter ],
		[ 0 => $spe_hollow,	4 => $spe_letter ],
		[ 4 => $spe_letter ],
		[ 5 => $spe_solid,	4 => $spe_letter ],
		[ 2 => $spe_hollow,	4 => $spe_letter ],
		[ 4 => $spe_letter ],
	]);
}

function spr_DS_lower($DS)
{
	global $DS_names;
	global $DS_colours;

	$letter = strtoupper(substr($DS_names[$DS], 0, 1));
	$DS_base = $DS - ($DS % 100);

	$spe_letter = new SpriteElement(null, '#fff', $letter);
	$spe_solid = new SpriteElement(null, $DS_colours[$DS_base], '&#x25bc;');
	$spe_hollow = new SpriteElement(null, $DS_colours[$DS_base], 'V');

	return new Sprite([
		[ 0 => $spe_solid,	1 => $spe_letter ],
		[ 3 => $spe_hollow,	1 => $spe_letter ],
		[ 1 => $spe_letter ],
		[ 2 => $spe_solid,	1 => $spe_letter ],
		[ 5 => $spe_hollow,	1 => $spe_letter ],
		[ 1 => $spe_letter ],
	]);
}

class Scenery
{
    public $key;
    public $sprite;

	public $TPL_borders;

	public $minimap;

    function __construct($sprite, $TPL_borders = null, $minimap = null)
    {
        $this->sprite = $sprite;
		if (is_numeric($TPL_borders))
		{
			$this->TPL_borders = [
				DIR_NORTH	=> $TPL_borders,
				DIR_SOUTH	=> $TPL_borders,
				DIR_EAST	=> $TPL_borders,
				DIR_WEST	=> $TPL_borders,
			];
		}
		elseif (is_array($TPL_borders))
		{
			$this->TPL_borders = $TPL_borders;
		}
		else
		{
			$this->TPL_borders = [];
		}

		$this->minimap = isset($minimap) ? $minimap : array_search(TPL_HIGHOBSTACLE, $this->TPL_borders) !== false;
    }

    function getJS()
    {
        return $this->sprite->getJS();
    }
}




class Tile
{
    public $key;

    public $bg;
    public $fg;
    public $chars;
    public $static;

	public $TPL;

    public $canEnter;
	public $overPlayer;
	public $scatterDilution;

	public $jsonObject;

	public $singular;


    function __construct($bg, $chars, $TPL = null, $fg_disparity = null, $overPlayer = null, $scatterDilution = null)
    {
		if (!isset($TPL)) $TPL = TPL_OPENGROUND;
		if (!isset($fg_disparity)) $fg_disparity = 2;

		if (!isset($overPlayer) || !isset($TPL)) $overPlayer = false;

        $this->bg		= $bg;
        $this->fg		= is_int($fg_disparity) ? tint($bg, $fg_disparity, true) : $fg_disparity;
        $this->chars	= $chars;
        $this->static	= count($chars) == 6;

		if (is_bool($TPL))
		{
			$this->TPL = $TPL ? TPL_OPENGROUND : TPL_LOWOBSTACLE;
		}
		else
		{
			$this->TPL			= $TPL;
		}
		$this->overPlayer		= $overPlayer;
		$this->scatterDilution	= $scatterDilution ? $scatterDilution : count($this->chars);

		$this->jsonObject = new stdClass();
		$this->jsonObject->c = $this->chars;
		$this->jsonObject->d = $this->scatterDilution;

		if ($overPlayer && ($GLOBALS['player'] instanceof EditorPlayer ||$GLOBALS['player'] instanceof EditorPlayer2)) $this->fg = '#f0f';
    }

	function __clone()
	{
//		$this->bg = $this->tint($this->bg, -1);
//		$this->fg = $this->tint($this->fg, -1);
	}

	public function tint($amount = -1)
	{
		$newTile = clone $this;

		$newTile->bg = tint($this->bg, $amount, true);
		$newTile->fg = tint($this->fg, $amount, true);

		return $newTile;
	}

    function render($id)
    {
        echo "<div class=\"$this->key\" id=\"t$id\">";
        if ($this->static)
        {
            for ($c = 0; $c <= 5; $c++)
            {
                echo $this->chars[$c];
                if ($c == 2) echo '<br>';
            }
        }
        else
        {
            for ($c = 0; $c <= 5; $c++)
            {
                echo $this->chars[mt_rand(0,count($this->chars) - 1)];
                if ($c == 2) echo '<br>';
            }
        }
        echo '</div>';
    }

    function getCSS()
    {
		$css = ".$this->key { background-color:{$this->bg}; color:{$this->fg}; } ";
		if ($this->overPlayer) $css .= ".$this->key span { background-color:{$this->bg} !important; color:{$this->fg} !important; } ";

        return $css;
    }

    function getJS()
    {
//		return "var rt_{$this->key} = " . json_encode($this->chars);
		return "var rt_{$this->key} = " . json_encode($this->jsonObject);
    }

//    public function collide()
//    {
//        return $this->canEnter;
//    }
}




class Inventory
{
	private	$owner;

	public $contents	= [];
	public $locked		= false;

	public $lootable = false;
	public $CUR = null;

	public $TFI = null;

	public function __construct(AsObject &$owner)
	{
		$this->owner = $owner;
	}

	public function getItemCount($matchItem = null, $matchProperties = null)
	{
		if (!isset($matchItem)) return count($this->contents);

		$count = 0;

		if ($matchItem instanceof Item)
		{
			$matchItem = new Mask($matchItem, $matchProperties);
		}

		foreach ($this->contents as $item)
		{
			if ($matchItem->compare($item)) $count += $item->quantity;
		}
		return $count;
	}

	public function hasItem ($itemOrMask)
	{
		if ($itemOrMask instanceof Item)
		{
			$itemOrMask = new Mask($itemOrMask);
		}

		foreach ($this->contents as $item)
		{
			if ($itemOrMask->compare($item))
			{
				return true;
			}
		}

		return false;
	}

	public function getItemByIndex($index)
	{
//		console_echo('getting item by index');		//XXX
		if (isset($this->contents[$index]))
		{
			return $this->contents[$index];
		}
		else
		{
			console_echo("Attempting to access item at index {$index} of {$this->owner->name}'s inventory but this index does not exist.", '#faa', CNS_ITEMS);		//XXX
			return false;
		}
	}

	public function add($item, $forceMoneyItem = false)
	{
		if (!($item instanceof Item))
		{
			console_echo('Trying to add non-item to an inventory.', '#faa', CNS_ITEMS);
			return;
		}

		global $player;

		$item->finish();

		console_echo("Adding <<#fff>>{$item->name}<> to inventory of <<#fff>>{$this->owner->name}<>.", '#aaf', CNS_ITEMS);


		if ($this->locked)
		{
			console_echo("Attempting add to locked inventory of {$this->owner->name}.", '#faa', CNS_ITEMS);
			return;
		}

		if ($this->owner instanceof Player)
		{
			update_thoughts("Found {$item->name}!");
		}

		// Does this inventory transform stuff?
		if ($this->TFI)
		{
			console_echo('Looks like this inveotry is going to transform some stuff.', '#ffa', CNS_ITEMS);
			// Transform the item in the appropriate way
			$transformedItems = $item->onTransform($this->TFI);
			if (!is_array($transformedItems)) $transformedItems = [$transformedItems];

			// Remove the transformation function of this inventory so that we
			// can add the new items without having them transform again.
			$heldTFI = $this->TFI;
			$this->TFI = null;

			foreach ($transformedItems as $tItem)
			{
				console_echo("We got a <<#fff>>{$tItem->name}<> from that <<#fff>>{$item->name}<>.", '#afa', CNS_ITEMS);
				$this->add($tItem);
			}

			// Reinstate the transformation property
			$this->TFI = $heldTFI;
			return;
		}

		if (isset($this->owner->wallet) && $item instanceof itm_money && !$forceMoneyItem)
		{
			console_echo('Sending money item to the wallet.', '#ccc', CNS_ITEMS);
			$this->owner->wallet->addmoney($item);
			return;
		}

		console_echo("{$this->owner->name} collected {$item->name} [{$item->quantity}].", '#fca', CNS_ITEMS);

        $itemLocation = $this->findItem($item);

        if ($itemLocation !== false)
        {
            $this->contents[$itemLocation]->quantity += $item->quantity;
			$item = $this->contents[$itemLocation];
            if ($this->owner instanceof Player) console_echo("Duplicate item: {$item->name}");
        }
        else
        {
            $this->contents[$item->id] = $item;
			$item->owner = $this->owner;
        }

        $item->onCollect();
		console_echo('Before onGainItem');
		$this->owner->onGainItem($item);
		console_echo('After onGainItem');

		if ($this->owner === $player)
		{
//			update_items($item, $item->quantity < 1);
			update_items($item);
		}
		elseif ($this->lootable && $this->owner === $player->engagement)
		{
			update_available($item);
		}

		return $item;
	}

    public function pullItem($item = null, $quantity = null)
    {
		global $player;

		if ($this->locked)
		{
			console_echo("Attempting to pull from locked inventory of {$this->owner->name}.", '#faa', CNS_ITEMS);
			return;
		}

		$itemLocation = false;

		if (isset($this->contents[$item->id]))
		{
			$itemLocation = $item->id;
		}
		elseif (empty($item))
		{
			$itemLocation = array_rand($this->contents);
		}
		elseif (is_int($item))
		{
			$itemLocation = (array_key_exists($item, $this->contents) ? $item : false);
		}
		elseif ($item instanceof Item)
		{
			$itemLocation = $this->findItem($item);
		}


		if ($itemLocation !== false && isset($this->contents[$itemLocation]))
		{
			$item = $this->contents[$itemLocation];
			if ($this->contents[$itemLocation]->cantLose)
			{
				$item = $this->contents[$itemLocation];
				console_echo("Attempting to remove an unlosable item <<#fff>>\"{$item->name}\"<> from the inventory of <<#fff>>{$this->owner->name}<>", null, CNS_ITEMS);
				update_thoughts("I'd better hold onto this {$item->name} for now.");
				return false;
			}

            if (isset($this->contents[$itemLocation]->isEquipped) && $this->contents[$itemLocation]->isEquipped)
			{
				$this->contents[$itemLocation]->unequip();
			}

			$pulledItem = clone $this->contents[$itemLocation];

			if (isset($quantity) && $quantity <= $this->contents[$itemLocation]->quantity)
			{
				console_echo("Pulling {$quantity}x {$pulledItem->name} from {$this->owner->name}'s inventory.", null, CNS_ITEMS);
				$this->contents[$itemLocation]->quantity -= $quantity;
				$pulledItem->quantity = $quantity;
			}
			else
			{
				$pulledItem->quantity = $this->contents[$itemLocation]->quantity;
				$this->contents[$itemLocation]->quantity = 0;
			}

			console_echo('Before onLoseItem');
			$this->owner->onLoseItem($item);
			console_echo('After onLoseItem');

			if ($this->owner === $player)
			{
//				update_items($item, $item->quantity < 1);
				update_items($item);
			}
			elseif ($this->owner === $player->engagement)
			{
//				update_available($item, $item->quantity < 1);
				update_available($item);
			}

			if ($this->contents[$itemLocation]->quantity < 1)
			{
				console_echo("Pulling {$pulledItem->name} from {$this->owner->name}'s inventory.", null, CNS_ITEMS);
				console_echo("Item binding slot: {$pulledItem->SKLS}", '#aaf', CNS_ITEMS);
				if ($this->owner === $player && $this->contents[$itemLocation]->SKLS !== null)
				{
					console_echo('Unbinding a bound inventory item before it gets removed.', '#faf', CNS_ITEMS);
					$player->bindings[$this->contents[$itemLocation]->SKLS]->unbind();
					update_bindings();
				}
				unset($this->contents[$itemLocation]);
			}

			return $pulledItem;
		}
		console_echo('Trying to remove a ' . get_class($item) . " from the inventory of {$this->owner->name} but it doesn't have one. Look into that.", '#faa', CNS_ITEMS);
//		console_var_dump($this->contents);
		return false;
    }

	public function findItem(Item $item)
	{
		foreach ($this->contents as $key => $invItem)
		{
			if ($item->equals($invItem))
			{
				return $key;
			}
		}
		return false;
	}

	public function findItemByType($type)
	{
		foreach ($this->contents as $key => $item)
		{
			if (strtolower(get_class($item)) == strtolower($type))
			{
				return $key;
			}
		}
		return false;
	}

	public function sell($item, Dude $buyer, $CUR, $quantity = 1, $sa_priceMod = null)
	{
		global $player;

		if (is_integer($item)) $item = $this->getItemByIndex($item);

		if (!($item instanceof Item)) return false;

		if ($item->cantLose)
		{
			update_thoughts("I really shouldn't sell this {$item->name} right now.");
			return false;
		}

//		$price = $item->getPrice($this->CUR) * $quantity;
		$price = $item->getPrice($CUR, $sa_priceMod) * $quantity;

		if ($buyer === $player)
		{
//			if (!isset($buyer->wallet->contents[$this->CUR]) || $buyer->wallet->contents[$this->CUR] < $price) return false;
//			$buyer->wallet->contents[$this->CUR] -= $price;
			if (!isset($buyer->wallet->contents[$CUR]) || $buyer->wallet->contents[$CUR] < $price) return false;
			$buyer->wallet->contents[$CUR] -= $price;
		}

		if ($item = $this->pullItem($item, $quantity))
		{
			$buyer->inventory->add($item);
		}
		else
		{
			return false;
		}

		if ($this->owner === $player)
		{
//			if (isset($player->wallet->contents[$this->CUR]))
			if (isset($player->wallet->contents[$CUR]))
//				$player->wallet->contents[$this->CUR] += $price;
				$player->wallet->contents[$CUR] += $price;
			else
//				$player->wallet->contents[$this->CUR] = $price;
				$player->wallet->contents[$CUR] = $price;
		}

		update_money();

		return true;
	}

	public function getAjaxObjects($CUR = null, $sa = null, Mask $mask = null)
	{
		$ajaxObjects = [];

		foreach ($this->contents as $item)
		{
			if (isset($mask) && !($mask->compare($item))) continue;
			$ajaxObjects[] = $item->getAjaxObject($CUR, $sa);
		}

		return $ajaxObjects;
	}

	public function initialiseLoot ($lootArray)
	{
		console_echo("Initialising loot for <<#fff>>{$this->owner->name}<>!", '#0f0', CNS_ITEMS);

		foreach ($lootArray as $odds => $stuff)
		{
			$vars = explode(':', "{$odds}");

			$odds = $vars[0];
			$max = isset($vars[1]) ? $vars[1] : 1;

			shuffle($stuff);

			$got = 0;

			foreach ($stuff as $thing)
			{
				if (percentageToBool($odds))
				{
					if (!is_array($thing)) $thing = [$thing];

					foreach ($thing as $item)
					{
						console_echo($item->id, null, CNS_ITEMS);
						$item->finished = false;
						$this->add(clone $item, true);
					}

					$got++;
				}

				if ($got >= $max) break;
			}
		}

		console_echo('Intialise loot complete.', '#0f0', CNS_ITEMS);
	}

	function __debugInfo ()
	{
		return [
			'owner' => $this->owner ? $this->owner->name : '### NO OWNER ###',
			'contents' => $this->contents,
			'CUR'	=> $this->CUR ? $GLOBALS['currencies'][$this->CUR]->name : '## NONE ##',
			'TFI'	=> $this->TFI,
		];
	}
}

class Wallet
{
	private $owner;
	public $contents = [];

	public function __construct(AsObject &$owner)
	{
		$this->owner = $owner;
	}

	public function add($amount, $CUR)
	{
		$amount = floor($amount);

		if ($amount < 0) return false;

		if (isset($this->contents[$CUR]))
		{
			$this->contents[$CUR] += $amount;
		}
		else
		{
			$this->contents[$CUR] = $amount;
		}
		if ($this->owner === $GLOBALS['player']) update_money();

		return true;
	}

	public function addmoney(itm_money $money)
	{
		$this->add($money->amount, $money->CUR);
	}

	public function remove($amount, $CUR)
	{
		if (!isset($this->contents[$CUR]) || $this->contents[$CUR] < $amount)
		{
//			console_echo("Attempting to take {$amount} {$GLOBALS['currencies'][$CUR]} from {$this->owner->name} but it only has {$this->contents[$CUR]}.", '#faa', CNS_ITEMS);
			return false;
		}
		$this->contents[$CUR] -= $amount;
		if ($this->contents[$CUR] < 1) unset($this->contents[$CUR]);
		return true;
	}

	public function getAmount($CUR, $formatted = false)
	{
		$amount = isset($this->contents[$CUR]) ? $this->contents[$CUR] : 0;

		if ($formatted)
		{
			return getFormattedAmount($amount, $CUR);
		}
		else
		{
			return $amount;
		}
	}

	public function getWalletString()
	{
		if (empty($this->contents)) return;
		$walletString = '';

		foreach ($this->contents as $CUR => $amount)
		{
			if ($amount == 0) continue;
			if (empty($walletString)) $walletString = getFormattedAmount($amount, $CUR, true);
			else $walletString .= '<br>' . getFormattedAmount($amount, $CUR, true);
		}
		return $walletString;
	}

	public function dumpIntoInventory()
	{
		if (!isset($this->owner->inventory)) return false;

		console_echo('Dumping wallet into inventory.', null, CNS_ITEMS);

		foreach ($this->contents as $CUR => $amount)
		{
			$this->owner->inventory->add(new itm_money($CUR, $amount, true), true);
		}

		return true;
	}
}


abstract class Boon
{
	public $name;
	public $description;

	public function __construct ($name, $description)
	{
		$this->name			= $name;
		$this->description	= $description;
	}

	abstract function deliver(Player &$player);
}

class boon_skill extends Boon
{
	public $skill;

	public function __construct (SkillInterface $skill)
	{
		$name = "Practice {$skill->name}";
		$plural = $skill->level > 1 ? 's' : '';
		$description = "Gain {$skill->level} level{$plural} of {$skill->name}";
		$this->skill = $skill;

		parent::__construct($name, $description);
	}

	public function deliver(Player &$player)
	{
		if (!$player->addSkill($this->skill))
		{
			console_echo("Already had skill <<#fff>>\"{$this->skill->name}\"<> so we'll just level it up instead", '#fda');
			console_echo($this->skill->key);

			$player->upgradeSkill($this->skill);
		}

		if ($this->skill instanceof Passive)	update_passives();
		else									update_skills();
	}
}

//class boon_passive extends Boon
//{
//	public $passive;
//
//	public function __construct (Passive $passive)
//	{
//		$name = "Learn {$passive->name}";
//		$plural = $passive->level > 1 ? 's' : '';
//		$description = "Gain {$passive->level} level{$plural} of {$passive->name}";
//		$this->passive = $passive;
//
//		parent::__construct($name, $description);
//	}
//
//	public function deliver(Player &$player)
//	{
//		if (!$player->addPassive($this->passive))
//		{
//			$player->passive[$this->passive->key]->level += $this->passive->level;
//		}
//
//		update_passives();
//	}
//}

class boon_stats extends Boon
{
	public $DSs;

	public function __construct($DSs)
	{
		global $DS_names;
		$this->DSs = $DSs;

		$max = max($DSs);
		$maxIndex = array_search($max, $DSs);

		$name = "+{$max} to {$DS_names[$maxIndex]}";

		$description = [];

		foreach ($this->DSs as $DS => $amount)
		{
			$description[] = "+{$amount} to {$DS_names[$DS]}";
		}

		$description = 'Grants ' . implode(', ', $description);

		parent::__construct($name, $description);
	}

	public function deliver(Player &$player)
	{
		global $DS_names;

		foreach ($this->DSs as $DS => $amount)
		{
//			$player->DSs[$DS] += $amount;
			$player->{$DS_names[$DS]} += $amount;
		}

		update_stats(array_keys($this->DSs));

		$thought = [];
		foreach ($this->DSs as $DS => $amount)
		{
			$thought[] = "+{$amount} to {$DS_names[$DS]}";
		}
		$thought = 'Granted ' . implode(', ', $thought);

		update_thoughts($thought);
	}
}


abstract class Behaviour
{
	public $owner;
	public $description;

	public $key;
	public $keySuffix;

	public $cooldown;
	public $readyTime;

	public $expiaryTime = null;

	public $spriteSet = [];

	public $onRegister	= null;
	public $onRemove	= null;

	public function __construct($description, $key, $cooldown = 0, $expiary = 0)
	{
		$this->description = $description;
		$this->key = isset($key) ? $key : get_class($this);
		$this->key .= (isset($this->keySuffix) ? "_{$this->keySuffix}" : '');

		$this->cooldown = $cooldown;
		if ($cooldown < 0.00001) $cooldown = 0.00001;
		$this->readyTime = 0;

		if ($expiary) $this->expireInSeconds($expiary);
	}

	public function triggercooldown()
	{
		if ($this->readyTime > $_SERVER['REQUEST_TIME_FLOAT']) return;
		$this->readyTime = $_SERVER['REQUEST_TIME_FLOAT'] + $this->cooldown;
		$this->readyTime -= READY_TIME_CORRECTION;
	}

	public function can($TRG)
	{
		// Delete the behaviour if it has expired.
		if ($this->expiaryTime && $this->expiaryTime < $_SERVER['REQUEST_TIME_FLOAT']) $this->delete();

		// Allow the behaviour to be triggered if it is switched on and ready.
		return isset($this->$TRG) && $this->$TRG && $this->readyTime <= $_SERVER['REQUEST_TIME_FLOAT'];
	}

	public function extendcooldown($seconds)
	{
		$this->readyTime += $seconds;
	}

	public function expireInSeconds($seconds)
	{
		$this->expiaryTime = $_SERVER['REQUEST_TIME_FLOAT'] + $seconds;
	}

	public function delete()
	{
		$this->owner->removeBehaviour($this);
	}

	public function equals(Behaviour $behaviour)
	{
		return get_class($this)		=== get_class($behaviour)
			&& $this->description	=== $behaviour->description
			&& $this->key			=== $behaviour->key
			&& $this->spriteSet		=== $behaviour->spriteSet
			;
	}

	public function onRegister() { }
	public function onRemove() { }

	public function __debugInfo ()
	{
		return [
			'owner' => $this->owner ? $this->owner->name : '### NO OWNER ###',
			'description' => $this->description,
			'key' => $this->key,
			'keySuffix' => $this->keySuffix,
			'cooldown' => $this->cooldown,
			'readyTime' => $this->readyTime,
			'expiaryTime' => $this->expiaryTime,
		];
	}
}

// Anything that has behaviours needs this trait.
trait BehaviourCapability
{
	public $behaviours = [];

	function addBehaviour(Behaviour $behaviour)
	{
		if (isset($this->behaviours[$behaviour->key])) console_class_list($this->behaviours[$behaviour->key], '#f00');

		$newBehaviours = func_get_args();

		foreach ($newBehaviours as $behaviour)
		{
			$behaviour->owner = $this;

			if (isset($this->behaviours[$behaviour->key]))
			{
				console_class_list($this->behaviours[$behaviour->key], '#fff');
				$this->behaviours[$behaviour->key][] = $behaviour;
				console_class_list($this->behaviours[$behaviour->key]);
			}
			else
			{
				$this->behaviours[$behaviour->key] = [$behaviour];
			}
			console_echo("Behaviour with key \"{$behaviour->key}\" has been registered.");

			if ($this->finished && $behaviour->onRegister) $behaviour->onRegister();
		}
	}

	function addBehaviourExclusive(Behaviour $behaviour)
	{
		$newBehaviours = func_get_args();

		foreach ($newBehaviours as $behaviour)
		{
			$behaviour->owner = $this;

			foreach ($this->behaviours[$behaviour->key] as $bhv)
			{
				$bhv->delete();
			}

			$this->behaviours[$behaviour->key] = [$behaviour];

			console_echo("Behaviour with key \"{$behaviour->key}\" has been registered EXCLUSIVELY.");

			if ($this->finished && $behaviour->onRegister) $behaviour->onRegister();
		}
	}

	function executeBehaviours($TRG, $arg1 = null, $arg2 = null, $arg3 = null)
	{
		foreach ($this->behaviours as $behaviour)
		{
			$behaviour = end($behaviour);

			if (!($behaviour instanceof Behaviour))
			{
				global $TRG_readable;
				console_echo($this->name, '#faf');

				console_echo($TRG_readable[$TRG], '#fff');

				foreach ($this->behaviours as $name => $behaviour)
				{
					$behaviour = end($behaviour);
					console_echo($name . ' => ' . get_class($behaviour), '#fff');
				}
			}

			if ($behaviour->can($TRG))
			{
				$behaviour->$TRG($arg1, $arg2, $arg3);
				$behaviour->triggercooldown();
			}
		}

		if ($this instanceof Player) $this->executePassives($TRG, $arg1, $arg2, $arg3);

		if (isset($this->NPCIs))
		{
			console_echo('This thing has NPCIs');
			$this->executeNPCIbehaviours($TRG, $arg1, $arg2, $arg3);
		}
	}

	function hasBehaviour($BHVK)
	{
		return isset($this->behaviours[$BHVK]);
	}

	function removeBehaviour(Behaviour $behaviour)
	{
		$BHVK = $behaviour->key;

		if (!isset($this->behaviours[$BHVK]))
		{
			console_echo("Attempting to remove behaviour with key <<#fff>>\"{$BHVK}\"<> from <<#ffa>>{$this->name}<> but no behaviour was found there.", '#fda', CNS_BEHAVIOUR);
			return;
		}

		foreach ($this->behaviours[$BHVK] as $pos => $bhv)
		{
			if ($behaviour->equals($bhv))
			{
				if ($this->behaviours[$BHVK][$pos]->onRemove)
				{
					console_echo('========== ON REMOVE ===========', '#afa');
					$this->behaviours[$BHVK][$pos]->onRemove();
				}
				else
				{
					console_echo('========== NO ON REMOVE ===========', '#faa');
				}

				unset($this->behaviours[$BHVK][$pos]);
				if (empty($this->behaviours[$BHVK])) unset($this->behaviours[$BHVK]);
				break;
			}
		}
	}

	function behaviour__clone()
	{
		$clonedBehaviours = [];
		foreach ($this->behaviours as $behaviours)
		{
			foreach ($behaviours as $behaviour)
			{
				$clonedBehaviours[] = clone $behaviour;
			}
		}

		$this->behaviours = [];

		foreach ($clonedBehaviours as $behaviour)
		{
			$this->addBehaviour($behaviour);
		}
	}

	function registerBehaviour()
	{
		foreach ($this->behaviours as $behavoiurs)
		{
			foreach ($behavoiurs as $behaviour)
			{
				if (!($behaviour instanceof Behaviour))
				{
					console_var_dump($behaviour, '#faa');
				}

				$behaviour->owner = $this;
				$behaviour->onRegister();
			}
		}
	}
}

class Mask
{
	public function __construct($thing = null, $properties = null)
	{
		if (!$thing) $thing = new stdClass();

		if ($thing instanceof Item) $thing->finish();

		if (!isset($properties))
		{
			$properties = array_keys(get_object_vars($thing));
//			$properties[] = 'class';

			$unwantedVars = [
				'quantity',
				'id'
			];

			$properties = array_diff($properties, $unwantedVars);

			$lazy = true;
			console_echo('Making a lazy mask using all properties. Just letting you know because you should probabaly never do this.', '#faa');
		}
		else
		{
			$lazy = false;
		}

		console_echo('Making a mask with the following properties:', '#afa');
		foreach ($properties as $property)
		{
			switch ($property)
			{
				case 'class':
					$this->class = [get_class($thing)];
					break;
				default:
					if (isset($thing->$property) || $lazy)
					{
						$this->$property = $thing->$property;
					}
					else
					{
						console_echo("Trying to make a dodgy mask. Something lacks a property <<#fff>>\"{$property}\"<>.", '#faa');
					}
			}
			console_echo($property, '#aff');
		}
	}

	public function compare($otherThing)
	{
		$properties = get_object_vars($this);

		if (!$properties) console_echo('Dude, you\'re comparing a <<#fff>>' . get_class($otherThing) . '<> to a mask with no properties; this will always pass.', '#f00');

		foreach ($properties as $property => $value)
		{
			$pass = false;
			switch ($property)
			{
				case 'class':
					$thingClass = get_class($otherThing);
					if (is_array($this->class))
					{
						if (in_array($thingClass, $this->class)) $pass = true;
					}
					else
					{
						if ($thingClass === $value) $pass = true;
					}
					break;
				case 'sprite':
					if ($value->equals($otherThing->$property)) $pass = true;
					break;
				case 'spriteSet':
					$pass = true;
					break;
				case 'materials':
					$pass = count(array_diff($value, $otherThing->$property)) === 0;
					break;
				case 'name':
				case 'description:':
					if (strtolower($otherThing->$property) === strtolower($value)) $pass = true;
					break;

				default:
					if ($otherThing->$property === $value) $pass = true;
			}

			if (!$pass)
			{
				// All this console error checking shit is probabaly a bit over the top but when you're trying to track down
				// something that's going wrong with a mask comparison, you'll be glad its here.

				if (!isset($otherThing->$property)) $otherThingValue = 'NOTHING';														//XXX
				elseif (is_scalar($otherThing->$property)) $otherThingValue = $otherThing->$property;									//XXX
				elseif (is_object($otherThing->$property)) $otherThingValue = 'AsObject(' . get_class($otherThing->$property) . ')';		//XXX
				elseif (is_array($otherThing->$property)) $otherThingValue = 'Array[' . count($otherThing->$property) . ']';			//XXX
				else $otherThingValue = '???';																							//XXX


				if (is_scalar($value)) $value = $value;										//XXX
				elseif (is_object($value)) $value = 'AsObject(' . get_class($value) . ')';	//XXX
				elseif (is_array($value)) $value = 'Array[' . count($value) . ']';			//XXX
				else $value = '???';														//XXX

				console_echo("Mask comparison failed on property <<#fff>>\"{$property}\"<> which had the value <<#afa>>\"{$value}\"<> instead of <<#faf>>\"{$otherThingValue}\"<>.", '#ffa');

				return false;
			}
		}
		return true;
	}
}

abstract class Binding
{
	public $index;
	public $owner;
	public $SKLS;

	public function __construct($owner, $index, $SKLS)
	{
		$this->owner	= $owner;
		$this->index	= $index;
		$this->SKLS		= $SKLS;
	}

	public function bind()
	{
		if (isset($this->owner->bindings[$this->SKLS]))
		{
			$this->owner->bindings[$this->SKLS]->unbind();
		}
		$this->owner->bindings[$this->SKLS] = $this;

		$subject = $this->getSubject();

		if ($subject->SKLS)
		{
			$this->owner->bindings[$subject->SKLS]->unbind();
		}

		$subject->SKLS = $this->SKLS;

		console_class_list($this->owner->bindings, '#afa');
	}

	public function unbind()
	{
		$this->getSubject()->SKLS = null;
		unset($this->owner->bindings[$this->SKLS]);

		console_class_list($this->owner->bindings, '#fda');
	}

	public abstract function &getSubject();
}

class ItemBinding extends Binding
{
	public function &getSubject()
	{
		return $this->owner->inventory->contents[$this->index];
	}

	public function bind()
	{
		parent::bind();
		update_items($this->getSubject());
	}
}

class SkillBinding extends Binding
{
	public function &getSubject()
	{
		return $this->owner->skills[$this->index];
	}

	public function bind()
	{
		parent::bind();
		update_skills();
	}
}

abstract class AsObject

{
	use behaviourCapability;
	use spriteManipulation;

	public $name;
	public $id;		// Uh-oh, this is getting weird now.

	// Sprite stuff is below in the SpriteManipulation trait.

	public $n_offset;
	public $w_offset;

	public $layer;
	public $TPL_passables = [TPL_OPENGROUND];

	public $constituents;

	public $lastUpdated;

	public $engagement	= null;
	public $enagedAt	= null; // Time of engagement

	public $permitEntryDefault = false;
	public $permitEntry;

	public $stationary	= false;
	public $invisible	= false;

	public $finished	= true;

	// SRZs is a list of variable names that need to be re-zipped at the end of the frame.
	public $SRZs = [];

	function __construct($name, $spriteSet, $layer)
	{
		$this->name	= ucwords($name);
		$this->id = id(8);

		if (!$spriteSet)
		{
			$spriteSet = [new Sprite([])];
			$this->invisible = true;
		}

		if ($spriteSet instanceof Sprite) $spriteSet = [$spriteSet];

		$this->spriteSet = $spriteSet;
		if (!isset($this->spriteSet[SPRI_DEFAULT])) $this->spriteSet[SPRI_DEFAULT] = reset($spriteSet);

		$this->sprite = $this->spriteSet[SPRI_DEFAULT];

		$this->layer = $layer;

		$this->lastUpdated = $_SERVER['REQUEST_TIME_FLOAT'];

//		$this->registerBehaviour();

		if ($this->constituents)
		foreach ($this->constituents as &$constituents)
		{
			foreach ($constituents as &$constituent)
			{
				$constituent->owner = $this;
			}
		}

        $type = get_class($this);		//XXX
        console_echo("Placing <<#afa>>{$type}<> -> <<#aff>>{$this->name}<>",'#fff');		//XXX
//		foreach ($this->behaviours as $behaviour)				//XXX
//		{														//XXX
////			console_echo(" - {$behaviour->description}");		//XXX
//		}														//XXX
	}

	public function __toString()
	{
		return $this->name;
	}


	function __clone()
	{
		$this->id = id();

		if (isset($this->inventory))
		{
			$this->inventory = new Inventory($this);
		}

		if (isset($this->constituents))
		{
			$this->constituent__clone();
		}

		$this->behaviour__clone();
	}

	public function __get($name)
	{
		if (isset($this->$name))
		{
			return $this->$name;
		}
		else
		{
			$SRZ = "SRZ_{$name}";

			if (isset($this->$SRZ))
			{
				$this->$name = unserialize($this->$SRZ);
				$this->SRZs[] = $name;
			}
		}
	}

//	public function __sleep()
//	{
//		foreach ($this->SRZs as $var)
//		{
//			console_echo("Putting {$this->name}'s {$name} variable to sleep.", '#afa', CNS_SRZ);
//			$SRZ = "SRZ_{$name}";
//			$this->$SRZ = serialize($this->$var);
//		}
//
//		$this->SRZs = [];
//
//		return array_keys(get_object_vars($this));
//	}

	public function collide(AsObject $target, $DIR)
	{
		$target->permitEntry = $target->permitEntryDefault;
		$this->onCollision($target, $DIR);
		$target->onReaction($this, $DIR);

		console_echo ("{$this->name} has collided with {$target->name}.");		//XXX

		// Objects will be assumed solid unless otherwise noted. Denting access
		// by default is always going to be the safer option.
		$permitEntry = $target->permitEntry;
		return $permitEntry;
	}

	/**
	 * Call destroy on an object if you just want it gone.
	 * No behaviours, no nothing.
	 */
	public function destroy()
	{
		global $map;

		$map->destroyObject($this);
	}

	/**
	 * An object-centric shortcut to the map's object movement method.
	 * @param type $n_offset The new north offset for the object
	 * @param type $w_offset The new west offset for the object
	 * @param type $force Allows the movement to over-ride normal object collision rules (does not over-ride stationary boolean)
	 * @return type <b>TRUE</b> if moved, <b>FALSE</b> if not.
	 */
	public function move($n_offset, $w_offset, $force = false)
	{
		if ($this->stationary) return;

		global $map;

		return $map->moveObject($this, $n_offset, $w_offset, $force);
	}

	function moveInDirection($DIR)
	{
		if (isset($this->spriteSet[$DIR]))
		{
			$this->setSPRI($DIR);
		}

		$offsets = directionToOffset($DIR);
		return $this->move(
			$this->n_offset + $offsets[0],
			$this->w_offset + $offsets[1]
		);
	}

	public function changeTo($newObject)
	{
		global $map;

		$newObject->n_offset = $this->n_offset;
		$newObject->w_offset = $this->w_offset;

		if ($this->constituents)
		{
			foreach ($this->constituents as $constituents)
			{
				foreach ($constituents as $constituent)
				{
					$constituent->owner = $newObject;
				}
			}
		}

		$newObject->constituents = $this->constituents;

		$map->replaceObject($this->n_offset, $this->w_offset, $this->layer, $newObject);
	}

	public function pause($seconds)
	{
		$this->nextIdleAction += $seconds;
	}

	public function changeLayer($layer)
	{
		global $map;

		if ($this->constituents) $this->constituentClear();

		$this->layer = $layer;

		if ($this->constituents) $this->constituentPlace();

		$map->resortObjectLayers($this->n_offset, $this->w_offset);
	}

//	public function engage(Player $player)
	public function engage()
	{
		global $player;
		// See if this is ready to engage with a player or if it is otherwise occupied
		if ($this->engagement !== null && $this->engagement !== $player)
		{
			update_thoughts("{$this->name} is not available right now.");
			console_echo($this->engagement->name);
			return;
		}

		if ($player->engagement !== null)
		{
			$player->engagement->disengage();
		}

		console_echo("{$player->name} has engaged {$this->name}.", '#aaa');		//XXX
		// Establish engagement at both ends
		$player->engagement = $this;
		$this->engagement = $player;
		$this->enagedAt = $_SERVER['REQUEST_TIME_FLOAT'];
		// Run engagement behaviours after enagagement has been established
		$this->onEngage($player);
	}

	public function disengage()
	{
		global $player;

		if (!$this->engagement)
		{
			console_echo("{$this->name} is attempting to disengage from literally nothing.");		//XXX
			return;
		}

		if ($this->enagedAt == $_SERVER['REQUEST_TIME_FLOAT'])
		{
			console_echo('Discarding disengagement in same turn as engagement.');		//XXX
			return;
		}
		console_echo("{$this->engagement->name} has disengaged {$this->name}.", '#aaa'); //XXX
		// Run behaviours before terminating engagement
		$this->onDisengage($player);
		// Terminate engagement at both ends
		$this->engagement->engagement = null;
		$this->engagement = null;

		console_echo('On disengage complete', '#faa');
	}

	public function isAdjacentTo(AsObject $object)
	{
		$n_disparity = $object->n_offset - $this->n_offset;
		$w_disparity = $object->w_offset - $this->w_offset;

		$n_disparity = ($n_disparity < 0 ? 0 - $n_disparity : $n_disparity);
		$w_disparity = ($w_disparity < 0 ? 0 - $w_disparity : $w_disparity);

		console_echo("{$this->name} is " . (($n_disparity + $w_disparity <= 1) ? '' : 'not ') . "adjacent to {$object->name}", '#acc');		//XXX

		return ($n_disparity + $w_disparity <= 1);
	}

	public function distanceFrom(AsObject $object)
	{
		if (empty($object)) return INF;

		$n_disparity = $object->n_offset - $this->n_offset;
		$w_disparity = $object->w_offset - $this->w_offset;

		$n_disparity = ($n_disparity < 0 ? 0 - $n_disparity : $n_disparity);
		$w_disparity = ($w_disparity < 0 ? 0 - $w_disparity : $w_disparity);

		console_echo("{$this->name} is " . ($n_disparity + $w_disparity) . " paces from {$object->name}", '#aca');		//XXX

		return $n_disparity + $w_disparity;
	}

	public function equals(AsObject $object)
	{
		return
		$object->name == $this->name &&
		$object->sprite == $this->sprite &&
		get_class($object) == get_class($this);
	}

	public function cEquals(AsObject $object, $properties)
	{
		console_echo("Running cEquals on {$object->name} and {$this->name}:", '#afa');
		foreach ($properties as $property)
		{
			if ($property === 'class')
			{
				if (get_class($object) !== get_class($this)) //return false;
				{
					console_echo('class doesn\'t match.', '#aaa');
					return false;
				}
			}
			else
			{
				if (!isset($this->$property, $object->$property))
				{
					console_echo("{$property} not present in both", '#aaa');
					return false; // Oosenupt - not sure about this.
				}
				if ($this->$property !== $object->$property)
				{
					console_echo("{$property} not equal in both", '#aaa');
					return false;
				}
			}
		}
		console_echo('Objects are cEqual!', '#afa');
		return true;
	}

	public function constituentPlace()
	{
		global $map;

		foreach ($this->constituents as $rel_n_offset => $constituents)
		{
			foreach ($constituents as $rel_w_offset => $constituent)
			{
				$map->objects[$this->n_offset + $rel_n_offset][$this->w_offset + $rel_w_offset][$this->layer] = $constituent;
			}
		}
	}

	public function constituentClear()
	{
		global $map;

		foreach ($this->constituents as $rel_n_offset => $constituents)
		{
			foreach ($constituents as $rel_w_offset => $constituent)
			{
				unset($map->objects[$this->n_offset + $rel_n_offset][$this->w_offset + $rel_w_offset][$this->layer]);
			}
		}
	}

	public function constituentCollide($n_offset, $w_offset)
	{
		global $map;

		foreach ($this->constituents as $rel_n_offset => $constituents)
		{
			foreach ($constituents as $rel_w_offset => $constituent)
			{
				if (!$map->collideByLocation($constituent, $n_offset + $rel_n_offset, $w_offset + $rel_w_offset))
				{
					return false;
				}
			}
		}
		return true;
	}

	public function constituent__clone()
	{
		$newConstituents = [];
		foreach ($this->constituents as $rel_n_offset => $constituents)
		{
			$newConstituents[$rel_n_offset] = [];
			foreach ($constituents as $rel_w_offset => $constituent)
			{
				$newConstituents[$rel_n_offset][$rel_w_offset] = clone $constituent;
				$newConstituents[$rel_n_offset][$rel_w_offset]->owner = $this;
			}
		}
		$this->constituents = $newConstituents;
	}

	public function __debugInfo()
	{
		return [
			'name' => $this->name,
			'sprite' => $this->sprite,
			'spriteSet' => $this->spriteSet,
			'n_offset' => $this->n_offset,
			'w_offset' => $this->w_offset,
			'constituents' => $this->constituents,
			'behaviours' => $this->behaviours,
		];
	}

	function onIdle()								{ $this->executeBehaviours(__FUNCTION__); }
	function onCollision(AsObject $receiver, $DIR)	{ $this->executeBehaviours(__FUNCTION__, $receiver,		$DIR); }
	function onReaction(AsObject $instigator, $DIR)	{ $this->executeBehaviours(__FUNCTION__, $instigator,	$DIR); }

	function onEngage(Player $player)				{ $this->executeBehaviours(__FUNCTION__, $player); }
	function onDisengage(Player $player)			{ $this->executeBehaviours(__FUNCTION__, $player); }

	function onMove($new_n_offset, $new_w_offset)	{ $this->executeBehaviours(__FUNCTION__, $new_n_offset, $new_w_offset); }

	function onLoseItem(Item $item)					{ $this->executeBehaviours(__FUNCTION__, $item); }
	function onGainItem(Item $item)					{ $this->executeBehaviours(__FUNCTION__, $item); }
}

abstract class ObjectBehaviour extends Behaviour
{
	public $onIdle		= null;
	public $onCollision	= null;
	public $onReaction	= null;
	public $onEngage	= null;
	public $onDisengage	= null;
	public $onMove		= null;

	public function onIdle		() { }
	public function onCollision	(AsObject $receiver,		$DIR)	{ }
	public function onReaction	(AsObject $instigator,	$DIR)	{ }

	public function onEngage	(Player $player) { }
	public function onDisengage	(Player $player) { }

	public function onMove	($new_n_offset, $new_w_offset) { }

	public function onLoseItem (Item $item) { }
	public function onGainItem (Item $item) { }
}

class ObjectConstituent
{
	use spriteManipulation;

	public $owner;

	public function __construct ($spriteSet)
	{
		if (!$spriteSet)
		{
			$spriteSet = [new Sprite([])];
			$this->invisible = true;
		}

		$this->spriteSet = $spriteSet;
		$this->sprite = isset($spriteSet[SPRI_DEFAULT]) ? $spriteSet[SPRI_DEFAULT] : reset($spriteSet);
	}

	public function __get($name)
	{
		if (isset($this->owner->$name))
		{
			return $this->owner->$name;
		}
	}

	public function __debugInfo()
	{
		return [
			'sprite' => $this->sprite,
			'spriteSet' => $this->spriteSet,
		];
	}
}

trait spriteManipulation
{
	public $sprite;
	public $spriteSet = [];
	public $currentSPRI = SPRI_DEFAULT;

	public $effects = [];
	public $spriteSet_effects = [];

	public $spriteSetAnnex = [];
	public $invisible = false;


	public function setSPRI($SPRI)
	{
		if ($SPRI === $this->currentSPRI)
		{
			console_echo("Cancelling sprite change by index (\"{$SPRI}\") on {$this->name} because it was the current SPRI.", null, CNS_SPRITE);
			return;
		}

		if (isset($this->constituents) && $this->constituents)
		{
			foreach ($this->constituents as $constituents)
			{
				foreach ($constituents as $constituent)
				{
					console_echo('Changing sprite of a constituent', '#fff', CNS_SPRITE);
					$constituent->setSPRI($SPRI);
				}
			}
		}

		if (isset($this->spriteSet[$SPRI]))
		{
			if ($this->effects)
			{
				console_echo('Effects detected.', null, CNS_SPRITE);
				if (isset($this->spriteSet_effects[$SPRI]))
				{
					console_echo('Effect augmented sprite found in effect sprite array.', null, CNS_SPRITE);
					$newSprite = $this->spriteSet_effects[$SPRI];
				}
				else
				{
					console_echo('Creating new effect augmented sprite.', null, CNS_SPRITE);
					$newSprite = $this->applyEffectsToSprite($this->spriteSet[$SPRI]);
					console_echo(console_sprite($newSprite));
					$this->spriteSet_effects[$SPRI] = $newSprite;
				}
			}
			else
			{
				$newSprite = $this->spriteSet[$SPRI];
			}

			unset($this->sprite);
			$this->sprite = $newSprite;
			$this->currentSPRI = $SPRI;
			console_echo('Changed sprite to ' . console_sprite($this->sprite), null, CNS_SPRITE);
		}
		else console_echo('Failed to find sprite in sprite index. Doing nothing.', null, CNS_SPRITE);
	}


	public function addSpriteEffect ($effect)
	{
		if ($effect instanceof Sprite)	//XXX
		{		//XXX
			console_echo("Adding effect sprite to <<#fff>>{$this->name}<>" . console_sprite($effect), '#aaa', CNS_SPRITE);
		}		//XXX
		else	//XXX
		{		//XXX
			console_echo("Adding effect colour to <<#fff>>{$this->name}<>" . console_swatch($effect), '#aaa', CNS_SPRITE);
		}		//XXX

		$this->deleteSpriteEffect($effect);
		array_unshift($this->effects, $effect);

		$this->spriteSet_effects = [];

		$SPRI = $this->currentSPRI;
		$this->currentSPRI = null;
		$this->setSPRI($SPRI);
	}

	public function removeSpriteEffect ($effect)
	{
		if ($effect instanceof Sprite)	//XXX
		{		//XXX
			console_echo("Removing effect sprite to <<#fff>>{$this->name}<>" . console_sprite($effect), '#aaa', CNS_SPRITE);
		}		//XXX
		else	//XXX
		{		//XXX
			console_echo("Removing effect colour to <<#fff>>{$this->name}<>" . console_swatch($effect), '#aaa', CNS_SPRITE);
		}		//XXX

		$this->deleteSpriteEffect($effect);

		$this->spriteSet_effects = [];

		$SPRI = $this->currentSPRI;
		$this->currentSPRI = null;
		$this->setSPRI($SPRI);
	}

	/***
	 * Not to be confused with removeEffect()!
	 *
	 * This function is only for deleting whereas removeEffect will also do other
	 * sprite management stuff. Note that deleteSprite is also called from inside
	 * addEffect() to make sure added effects are always on top and without
	 * duplicates.
	 */
	protected function deleteSpriteEffect($effect)
	{
		if ($effect instanceof Sprite)
		{
			foreach ($this->effects as $key => $exEffect)
			{
				if ($exEffect instanceof Sprite && $effect->equals($exEffect))
				{
					unset($this->effects[$key]);
					return;
				}
			}
		}
		else
		{
			foreach ($this->effects as $key => $exEffect)
			{
				if ($effect === $exEffect)
				{
					unset($this->effects[$key]);
					return;
				}
			}
		}
	}

	public function applyEffectsToSprite(Sprite $sprite)
	{
		global $view;

		$painted = false;
		$augmented = false;

		foreach ($this->effects as $effect)
		{
			if ($effect instanceof Sprite)
			{
				if (!$augmented)
				{
					$sprite = $sprite->augment($effect);
					$augmented = true;
					continue;
				}
			}
			elseif (is_string($effect) && !$painted)
			{
				$sprite = paintSprite($sprite, $effect);
				$painted = true;
				continue;
			}
			break;
		}

//		return $sprite;
		return $view->addClientSprite($sprite); // Oosenupt?
	}
}

class Effect
{
	public $sprite;
	public $n_offset;
	public $w_offset;
	public $frames;
	public $layer;

	public function __construct($sprite, $n_offset, $w_offset, $frames = null, $LAYER = null)
	{
		global $view;

		$this->sprite = $view->addClientSprite($sprite);
		$this->n_offset = $n_offset;
		$this->w_offset = $w_offset;

		$this->frames = $frames ? $frames : count($sprite->frames);
		$this->layer = isset($LAYER) ? $LAYER : LAYER_PROJECTILE;
	}

	public function tick()
	{
		if ($this->frames-- < 0) $this->delete();
	}

	public function delete()
	{
		global $map;

		if (isset($map->effects[$this->n_offset][$this->w_offset]) &&
			$map->effects[$this->n_offset][$this->w_offset] === $this)
		{
			unset($map->effects[$this->n_offset][$this->w_offset]);
		}
	}
}

abstract class Skill implements SkillInterface
{
	public $key; // Oosenupt - may be able to get away with not having this in the future.

	public $name;
	public $sprite;
	public $level	= 1;
	public $exp;

	public $requiredLevel	= 1;

	public $epCost	= 0;
	public $hpCost	= 0;
	public $cooldown;
	public $readyTime;

	// Owner of the skill
	public $owner;
	public $SKLS;

	public $range;

	public function __construct($name, Sprite $sprite)
	{
		$this->name			= $name;
		$this->sprite		= $sprite;
		$this->key			= get_class($this);

		$this->onChangeLevel();
	}

//	public abstract function getDescription ();
	public abstract function onUse($n_offset, $w_offset);

	/*
	 * onChangeLevel will be called every time the skill changes level. It should
	 * be used to alter level-dependant aspects of the skill. Registration should
	 * not be presumed.
	 */
//	public abstract function onChangeLevel();

	/*
	 * the onRegister function is used to initialise parts of the skill that
	 * require access to the skill's owner.
	 */
	public function onRegister (Dude $owner)
	{
		$this->owner = $owner;
	}

	public function inspect() { update_skillInfo($this); }

//	public function getRelatedSkills () { return []; }

	public function __debugInfo()
	{
		return [
			'name' => $this->name,
			'description' => $this->getDescription(),
			'sprite' => $this->sprite,
		];
	}
}

interface SkillInterface
{
	public function getDescription		();
	public function getRelatedSkills	();
	public function onChangeLevel		();
}

trait SkillCapability
{
	public $skills = [];
	public $passives = [];

	public $used_skills = [];

	public function addSkill(SkillInterface $skill)
	{
		if ($skill instanceof Passive) return $this->addPassive($skill);

		console_echo($skill->key);

		if (isset($this->skills[$skill->key])) return false;
		$skill->onRegister($this);
		$this->skills[$skill->key] = $skill;
		return true;
	}

	public function addPassive(Passive $passive)
	{
		if (isset($this->passives[$passive->key])) return false;
		if ($passive->onRegister) $passive->onRegister($this);
		$passive->owner = $this;
		$this->passives[$passive->key] = $passive;

		return true;
	}

	public function upgradeSkill(SkillInterface $skill)
	{
		if ($skill instanceof Passive) return $this->upgradePassive($skill);

		$this->skills[$skill->key]->level += $skill->level;
		$this->skills[$skill->key]->onChangeLevel();

		return true;
	}

	public function upgradePassive(Passive $passive)
	{
		$this->passives[$passive->key]->level += $passive->level;
		$this->passives[$passive->key]->onChangeLevel();

		return true;
	}

	public function getSkillByBinding($SKLS)
	{

	}

	public function useSkill($SKLSorKey, $n_offset = null, $w_offset = null)
	{
		/**************************************************\
		 Is the skill being used via binding or via key?
		\**************************************************/

		if (is_numeric($SKLSorKey))
		{
			/**************************************\
			 Is there a skill bound to this slot?
			\**************************************/

			if (!isset($this->bindings[$SKLSorKey]))
			{
				console_echo("<<#fff>>{$this->name}<> doesn't have a skill in slot <<#fff>>{$SKLSorKey}<>", '#faa');
				return;
			}

			$skill = $this->bindings[$SKLSorKey]->getSubject();
		}
		else
		{
			/**************************************\
			 Is there a skill with the given key?
			\**************************************/

			if (!isset($this->skills[$SKLSorKey]))
			{
				console_echo("<<#fff>>{$this->name}<> doesn't have a skill with key <<#fff>>{$SKLSorKey}<>", '#faa');
				return;
			}

			$skill = $this->skills[$SKLSorKey];
		}

		/**************************************\
		 Can we cast it?
		\**************************************/

		if ($skill->readyTime && $skill->readyTime > $_SERVER['REQUEST_TIME_FLOAT'])
		{
			$timeLeft = round($skill->readyTime - $_SERVER['REQUEST_TIME_FLOAT'] + 0.4, 0, PHP_ROUND_HALF_UP); // Add 0.4 to make it always round up. Does that even work?
			update_thoughts("Can't use {$skill->name} for another {$timeLeft} seconds.");
			return;
		}

		if (isset($skill->range))
		{
			if (!isset($n_offset, $w_offset))
			{
				update_thoughts("Target needed for {$skill->name}!");
				return;
			}

			$n_dist = $this->n_offset - $n_offset;
			if ($n_dist < 0) $n_dist = 0 - $n_dist;

			$w_dist = $this->w_offset - $w_offset;
			if ($w_dist < 0) $w_dist = 0 - $w_dist;

			$distance = $n_dist + $w_dist;

			if ($skill->range < $distance)
			{
				update_thoughts("Can't use {$skill->name} at this distance! ({$skill->range} < {$distance})");
				return;
			}
		}

		if ($skill->hpCost && $this->hp < $skill->hpCost)
		{
			update_thoughts("Not enough health to use {$skill->name}. (" . round($this->hp, 1) . " < {$skill->hpCost})");
			return;
		}

		if ($skill->epCost && $this->ep < $skill->epCost)
		{
			update_thoughts("Not enough energy to use {$skill->name}. (" . round($this->ep, 1) . " < {$skill->epCost})");
			return;
		}

		/**************************************\
		 Yes! Use the skill.
		\**************************************/

		if ($skill->onUse($n_offset, $w_offset))
		{
			/**************************************\
			 Did it work? If so, incur costs.
			\**************************************/

			if ($skill->hpCost) $this->alterHp(0 - $skill->hpCost);
			if ($skill->epCost) $this->alterEp(0 - $skill->epCost);

			if ($skill->cooldown) $skill->readyTime = $_SERVER['REQUEST_TIME_FLOAT'] + $skill->cooldown;

			// Skills with higher cooldowns will have greater weighting per use
			// so that spammy skills don't ALWAYS dominate.
			if (isset($this->used_skills[$skill->key]))
			{
				$this->used_skills[$skill->key] += $skill->cooldown ? $skill->cooldown : 1;
			}
			else
			{
				$this->used_skills[$skill->key] = $skill->cooldown ? $skill->cooldown : 1;
			}
		}
		else
		{
			update_thoughts("{$skill->name} failed!");
		}
	}

	public function executePassives ($TRG, $arg1 = null, $arg2 = null, $arg3 = null)
	{
		foreach ($this->passives as $passive)
		{
			if (!($passive instanceof Passive))
			{
				global $TRG_readable;
				console_echo($this->name, '#faf');

				console_echo($TRG_readable[$TRG], '#fff');
			}

			if ($passive->can($TRG))
			{
				$passive->$TRG($arg1, $arg2, $arg3);
				$passive->triggercooldown();
			}
		}
	}
}



class Status
{
	public $key;

	public $name;
	public $description;
	public $sprite;
	public $duration;
	public $canStack;

	public $expiry;

	public $DSs			= [];
	public $DMGs		= [];
	public $DMGs_def	= [];

	public $behaviours;
	public $spriteEffects	= [];


	public function __construct($name, $description, $sprite, $duration, $canStack = null, $DSs = null, $DMGs = null, $DMGs_def = null, $behaviours = null)
	{
		$this->name			= $name;
		$this->description	= $description;
		$this->duration		= $duration;
		$this->sprite		= $sprite;
		$this->canStack		= isset($canStack) ? $canStack : false;

		$this->DSs		= is_array($DSs) ? $DSs : [];
		$this->DMGs		= is_array($DMGs) ? $DMGs : [];
		$this->DMGs_def	= is_array($DMGs_def) ? $DMGs_def : [];

		if (isset($behaviours))
		{
			if (is_array($behaviours))
			{
				$this->behaviours = $behaviours;
			}
			else
			{
				$this->behaviours = [$behaviours];
			}
		}
	}

	public function deferExpiry($duration)
	{
		$this->expiry += $duration;
	}

	public function equals(Status $dudeStatus)
	{
		return
			$this->name				== $dudeStatus->name
//			&& $this->description	== $dudeStatus->description
//			$this->DSs		== $dudeStatus->DSs			&&
//			$this->DMGs		== $dudeStatus->DMGs		&&
//			$this->DMGs_def	== $dudeStatus->DMGs_def
			;
	}

	public function getGoldValue()
	{
		return 5; //oosenupt
	}
}

trait StatusCapability
{
	public $statuses		= [];
	public $nextStatusCheck = INF;

	function addStatus(Status $status)
	{
		global $player;

		console_echo("Adding status <<#fff>>{$status->name}<> to <<#fff>>{$this->name}<>.", '#aaa');
		$status->expiry = $_SERVER['REQUEST_TIME_FLOAT'] + $status->duration;

		$clash = false;
		foreach ($this->statuses as $index => $existingStatus)
		{
			if ($status->equals($existingStatus))
			{
				$clash = !$status->canStack;
				console_echo('Clash found!', '#fcc');

				if ($clash)
				{
//					$this->statuses[$index]->expiry = $status->expiry;
					$this->removeStatus($this->statuses[$index]);
					console_echo('Replacing status with extended version.', '#fda');
				}
			}
		}

//		if (!$clash)
//		{
			$this->statuses[] = $status;
			console_echo('Adding new status.', '#fcc');

			if ($status->behaviours)
			{
				foreach ($status->behaviours as $status_behaviour)
				{
					$this->addBehaviour($status_behaviour);
				}
			}

			if ($status->spriteEffects)
			{
				foreach ($status->spriteEffects as $spriteEffect)
				{
					$this->addSpriteEffect($spriteEffect);
				}
			}

			if ($this === $player)
			{
				update_stats(array_keys($status->DSs));
				if ($status->DMGs || $status->DMGs_def) update_readiness();
			}
//		}

		if ($status->expiry < $this->nextStatusCheck) $this->nextStatusCheck = $status->expiry;

		if ((isset($status->DSs[DS_SPEED]) || isset($status->DSs[DS_SPEED_FAST])) && isset($this->behaviours[BHVK_MOVEMENT]))
		{
			foreach ($this->behaviours[BHVK_MOVEMENT] as &$behaviour) $behaviour->onRegister();
		}
	}

	function removeStatus(Status $status)
	{
		console_echo("Removing status <<#fff>>{$status->name}<> from <<#afa>>{$this->name}<>.");

		global $player;

		if ($isPlayer = $this === $player) // On purpose
		{
			$update = [];
			$affectedDSs = [];
			$refreshReadiness = false;
		}

		$key = array_search($status, $this->statuses);

		unset($this->statuses[$key]);

		if ((isset($status->DSs[DS_SPEED]) || isset($status->DSs[DS_SPEED_FAST])) && isset($this->behaviours[BHVK_MOVEMENT]))
		{
			foreach ($this->behaviours[BHVK_MOVEMENT] as &$behaviour) $behaviour->onRegister();
		}

		if ($status->behaviours)
		{
			foreach ($status->behaviours as $status_behaviour)
			{
				$this->removeBehaviour($status_behaviour);
			}
		}

		if ($status->spriteEffects)
		{
			foreach ($status->spriteEffects as $spriteEffect)
			{
				$this->removeSpriteEffect($spriteEffect);
			}
		}

		if ($isPlayer)
		{
			$affectedDSs = $affectedDSs + $status->DSs;
			if (!$refreshReadiness && (!empty($status->DMGs) || !empty($status->DMGs_def))) $refreshReadiness = true; // Oosenupt - this is fucked

			update_stats(array_keys($affectedDSs));
			if ($refreshReadiness) update_readiness();
			update(UPD_STATUS, $update);
		}
	}

	function hasStatus(Status $status)
	{

	}

	function checkStatuses()
	{
		global $player;
		global $view;

		if ($isPlayer = $this === $player) // On purpose
		{
			$update = [];
			$affectedDSs = [];
			$refreshReadiness = false;
		}

		$this->nextStatusCheck = INF;

		foreach ($this->statuses as $key => $status)
		{
			if ($status->expiry <= $_SERVER['REQUEST_TIME_FLOAT'])
			{

				$this->removeStatus($status);

//				unset($this->statuses[$key]);
//
//				if ((isset($status->DSs[DS_SPEED]) || isset($status->DSs[DS_SPEED_FAST])) && isset($this->behaviours[BHVK_MOVEMENT]))
//				{
//					foreach ($this->behaviours[BHVK_MOVEMENT] as &$behaviour) $behaviour->onRegister();
//				}
//
//				if ($status->behaviours)
//				{
//					foreach ($status->behaviours as $status_behaviour)
//					{
//						$this->removeBehaviour($status_behaviour);
//					}
//				}
//
//				if ($isPlayer)
//				{
//					$affectedDSs = $affectedDSs + $status->DSs;
//					if (!$refreshReadiness && (!empty($status->DMGs) || !empty($status->DMGs_def))) $refreshReadiness = true; // Oosenupt - this is fucked
//				}
			}
			else
			{
				if ($isPlayer)
				{
					$upd = new stdClass();

					$upd->sprite = $view->addClientSprite($status->sprite)->key;
					$upd->description = $status->description;

					$update[] = $upd;
				}

				if ($status->expiry < $this->nextStatusCheck) $this->nextStatusCheck = $status->expiry;
			}
		}

		if ($isPlayer)
		{
			update_stats(array_keys($affectedDSs));
			if ($refreshReadiness) update_readiness();
			update(UPD_STATUS, $update);
		}
	}
}

abstract class Dude extends AsObject
{
	use			SkillCapability;
	use			StatusCapability;

    public		$hp			= 100;
	public		$ep			= 100;

	public		$level		= 1;

	public		$FAC;

    public		$gender		= null;
	public		$speechFile;
	public		$nextSpeak	= 0;

//    private		$inventory;
    public		$inventory;
//	public		$SRZ_inventory;
	public		$wallet;

	public		$equipped	= [];

	protected	$DSs;
	protected	$DMGs			= [DMG_TRAUMA => 5];
	protected	$DMGs_def		= [];

	public		$lvl_DSs		;
	public		$lvl_DMGs		;
	public		$lvl_DMG_defs	;

	public		$default_DMGDL	= DMGDL_BLUNT;
	public		$DMGDL			= DMGDL_BLUNT;

	public		$attack;

	public		$canPush		= false;
	public		$canOpenDoors	= false;

	public		$speechColour;

	// HANDLE WITH CARE!
	// In order to empower the SPE files, this variable was added to house objects that
	// might be needed during interactions.
	// Exmaples of use: Stick a quest in here so that the quest object is ready to be assigned.
	// The quest might involve recieving an item. Put that in here, too then grab it out in the SPE.
	// Basically, if you need something to exist in the SPE file but don't know where to put it, put it
	// in here with a unique and descriptive key (e.g., "spiderScourgeQuest").
	// If this ends up being a giant fuckup, I'll get rid of this variable.
	public		$speAnnex		= [];

	public		$TEQT		= TEQT_MELEE;
	public		$TEQT_def	= TEQT_MELEE;

	public		$technique = [];

	public		$TPL_passables =
	[
		TPL_OPENGROUND,
		TPL_STAIRS
	];


	private $default_technique = [
		TEQT_MELEE => [
			TEQ_DAMAGE		=> [DS_STRENGTH => 0.6, DS_FORCE => 0.5],
			TEQ_HIT_CHANCE	=> [DS_CONTROL => 1],
			TEQ_CRIT_DAMAGE	=> [DS_FORCE => 1, DS_FINESSE => 1],
			TEQ_CRIT_CHANCE	=> [DS_DEXTERITY => 0.2],
			TEQ_DEFENCE		=> [DS_RESILIENCE => 1],
			TEQ_DODGE_CHANCE	=> [DS_EVASIVENESS => 0.2, DS_AGILITY => 0.2],

			TEQ_ATTACK_SPEED	=> [DS_STRENGTH => 0.7, DS_FINESSE => 0.3, DS_INERTIA => -0.3],
			TEQ_CONSISTENCY	=> [DS_FINESSE => 0.4, DS_CONTROL => 0.4],
		],
		TEQT_MAGIC => [
			TEQ_DAMAGE		=> [DS_MAGIC => 0.8, DS_DISRUPTION => 0.5],
			TEQ_HIT_CHANCE	=> [DS_DISCIPLINE => 1],
			TEQ_CRIT_DAMAGE	=> [DS_FOCUS => 0.5],
			TEQ_CRIT_CHANCE	=> [DS_DISCIPLINE => 0.5, DS_DISRUPTION => 0.7],
			TEQ_DEFENCE		=> [DS_FOCUS => 1],
			TEQ_DODGE_CHANCE	=> [DS_FOCUS => 1],

			TEQ_ATTACK_SPEED	=> [DS_MAGIC => 1],
			TEQ_CONSISTENCY	=> [DS_FOCUS => 0.8],
		],
		TEQT_RANGED => [
			TEQ_DAMAGE		=> [DS_DEXTERITY => 0.8, DS_AGILITY => 0.5, DS_CONTROL => 0.4],
			TEQ_HIT_CHANCE	=> [DS_BALANCE => 0.5, DS_DEXTERITY => 0.5, DS_HEURISTICS => 0.2],
			TEQ_CRIT_DAMAGE	=> [DS_FINESSE => 0.5, DS_KNOWLEDGE => 0.4],
			TEQ_CRIT_CHANCE	=> [DS_INTELLECT => 0.5, DS_FINESSE => 0.7],
			TEQ_DEFENCE		=> [DS_AGILITY => 0.5, DS_RESILIENCE => 0.5],
			TEQ_DODGE_CHANCE	=> [DS_AGILITY => 1],

			TEQ_ATTACK_SPEED	=> [DS_FINESSE => 0.3, DS_CONTROL => 0.4],
			TEQ_CONSISTENCY	=> [DS_CONTROL => 0.5],
		]
	];

	private $TEQbiasCache = [];

	public function __construct($name, $spriteSet, $GND = null, $speechFile = null, $dudeStats = null)
	{
		global $DS_defaults;

		// This DS code looks like shit but I can't think how to improve it right now.
		if (!is_array($dudeStats)) $dudeStats = [];

		if (isset($this->DSs)) $dudeStats = $dudeStats + $this->DSs;

		$this->DSs = $dudeStats + $DS_defaults;

		if ($this->handicap !== null)
		{
			$handicap = $this->handicap;
			$randomiser = $this->randomiser / 100;

			$extraDSs = [
				DS_HP_MAX,
				DS_EP_MAX,
				DS_EXPERIENCE
			];

			foreach ($this->DSs as $DS => &$value)
			{
				if (($DS >= 100 || in_array($DS, $extraDSs)) && !isset($dudeStats[$DS]))
				{
					$value = ($value * $handicap) + mt_rand(0 - $value * $randomiser, $value * $randomiser);
				}
			}
		}

		$this->technique = $this->technique + $this->default_technique;
		foreach ($this->default_technique as $TEQT => $technique)
		{
			$this->technique[$TEQT] = $this->technique[$TEQT] + $technique;
		}

		unset($this->default_technique);

		$this->gender		= isset($GND) ? $GND : GND_MALE;

		$this->hp			= $this->DSs[DS_HP_MAX];

		$speechFileName = strtolower(str_replace(' ', '_', $name));
		if (isset($speechFile))
		{
			$this->speechFile = str_replace('.spe', '', $speechFile);
			console_echo("<<#afa>>{$name}<> is using the speech file <<#aaf>>\"{$this->speechFile}.spe\"<> on account of explicit assignment.", '#fff');
		}
		elseif(file_exists("{$GLOBALS['rootPath']}content/speech/{$speechFileName}.spe"))
		{
			$this->speechFile = $speechFileName;
			console_echo("<<#afa>>{$name}<> is using the speech file <<#aaf>>\"{$this->speechFile}.spe\"<> on account of name alloction.", '#fff');
		}
		else
		{
			$this->speechFile = '_default';
			console_echo("<<#afa>>{$name}<> is using the speech file <<#aaf>>\"{$this->speechFile}.spe\"<> because it wasn't given anything else.", '#fff');
		}

		$this->inventory	= new Inventory($this);
		$this->SRZs[]		= 'inventory';

		$this->wallet		= new Wallet($this);

		$this->attack		= new Attack($this);

		$this->default_DMGDL = $this->DMGDL;


		if ($spriteSet instanceof Sprite)
		{
			$spriteSet = [$spriteSet];
		}
		if (!is_array($spriteSet)) $spriteSet = [];


//		if (!isset($spriteSet[SPRI_DEFAULT]))	$spriteSet[SPRI_DEFAULT]	= self::getDudeSprite($GND);
		if (!$spriteSet)
		{
			$spriteSet = [];
			$spriteSet[SPRI_DEFAULT]	= self::getDudeSprite($GND);
		}
		if (!isset($spriteSet[SPRI_DEFAULT]))
		{
			$spriteSet[SPRI_DEFAULT] = reset($spriteSet);
		}
		if (!isset($spriteSet[SPRI_CORPSE]))	$spriteSet[SPRI_CORPSE]		= self::getCorpseSprite($spriteSet[SPRI_DEFAULT]);

		parent::__construct($name, $spriteSet, LAYER_DUDE);


		$this->speechColour	= tintByMax($this->spriteSet[SPRI_DEFAULT]->getBodyColour(), 10); // This function doesn't even fucking work
	}


	public function __get($name)
	{
		if (isset($this->$name))
		{
			if (is_array($this->$name))
			{
				return $this->getDeepArray($name);
			}
			else
			{
				return parent::__get($name);
			}
		}
		else
		{
			return $this->getDS($name);
		}
	}

	public function __set($name, $value)
	{
		console_echo("Attepmting SET on a <<#fff>>{$this->name}'s {$name}<>.", '#afd');

		if (isset($this->$name))
		{
			$this->$name = $value;
		}
		else
		{
			$upname = str_replace(' ', '_', strtoupper($name));
			$DS_name = "DS_{$upname}";

			console_echo("constant: {$DS_name}");

			if (defined($DS_name))
			{
				$constant = constant($DS_name);

				$this->DSs[$constant] = $value;
				global $DS_names; console_echo("Setting <<#fff>>{$this->name}'s {$DS_names[$constant]}<> to {$value}.", '#afd');
			}
			else	//XXX
			{		//XXX
				console_echo("There's no dude stat bound to the constant <<#fff>>\"{$DS_name}\"<>!", '#faa');
				console_echo("Setting <<#fff>>\"{$name}\"<> as a normal variable.", '#fda');
				$this->$name = $value;
			}		//XXX
		}
	}

	public function __clone()
	{
		parent::__clone();
	}

	public function getDS ($DS_name, $shallow = false)
	{
		console_echo("Attempting GET on a dude ({$DS_name})", '#fda', CNS_DSs);

		if (is_numeric($DS_name))
		{
			$constant = $DS_name;
			if (!isset($this->DSs[$constant]))
			{
				console_echo("<<#f55>>There is no DS assigned to number {$constant}!<>");
				return null;
			}
		}
		else
		{
			$upname = str_replace(' ', '_', strtoupper($DS_name));
			$constant = constant("DS_{$upname}");
		}

		console_echo("constant: {$constant}", null, CNS_DSs);

		if (isset($constant) && isset($this->DSs[$constant]))
		{

			$value = $this->DSs[$constant];
			$values = [$value];

			if (!$shallow)
			{
				if (isset($this->lvl_DSs[$constant])) $values[] = $this->lvl_DSs[$constant] * $this->level;

				foreach($this->equipped as $index)
				{
					$equipment = $this->inventory->getItemByIndex($index);
					if (isset($equipment->DSs[$constant]))
					{
						$values[] = $equipment->DSs[$constant];
					}
				}

				foreach ($this->statuses as $arrayKey => $status)
				{
					if (isset($status->DSs[$constant]))
					{
						console_echo("Sourcing <<#fff>>{$DS_name}<> from a status.", '#faf', CNS_DSs);
						$values[] = $status->DSs[$constant];
					}
				}

				return valueListToValue($values);
			}

			return $value;
		}
		else
		{
			console_echo("<<#f55>>There is no DS_{$upname}!<>");
			return null;
		}

	}

	public function getDeepArray($name)
	{
		$shallowArray = $this->$name;

			$deepArrays = [];

			$lvl_array = "lvl_{$name}";
			if (isset($this->$lvl_array))
			{
				$lvl_array = $this->$lvl_array;
			}
			else
			{
				$lvl_array = [];
			}

			foreach ($shallowArray as $key => $val)
			{
				if (isset($lvl_array[$key])) $val += $lvl_array[$key] * $this->level;

				$deepArrays[$key][] = $val;
			}

			foreach($this->equipped as $index)
			{
				$equipment = $this->inventory->getItemByIndex($index);

				// Make sure it exists before you try to use it.
				if (isset($equipment->$name))
				{
					$eqpArray = $equipment->$name;

					foreach ($eqpArray as $key => $val)
					{
						$deepArrays[$key][] = $val;
					}
				}
			}


			foreach ($this->statuses as $arrayKey => $status)
			{
				foreach ($status->$name as $key => $val)
				{
					$deepArrays[$key][] = $val;
				}
			}

			$aggregatedArray = [];
			foreach ($deepArrays as $key => $val)
			{
				$aggregatedArray[$key] = valueListToValue($deepArrays[$key]);
			}

			console_echo($name, '#fda', CNS_DSs);

			return $aggregatedArray;
	}

	public function getShallowArray($name)
	{
		if (isset($this->$name) && is_array($this->$name)) return $this->$name;
	}

	public function collide(AsObject $target, $DIR)
	{
		global $FAC_standing;

		if (
			$target instanceof Dude &&
			isset($FAC_standing[$this->FAC][$target->FAC]) &&
			$FAC_standing[$this->FAC][$target->FAC] < 0
		)
		{
			$this->doAttack($target);
		}

		return parent::collide($target, $DIR);
	}


	public function hasItem($item)
	{
		return $this->inventory->hasItem($item) !== false;
	}

	function equip($equipment)
	{
		global $DS_names;

		if ($equipment instanceof Equipment)
		{
			$inv_slot = $this->inventory->findItem($equipment);
		}
		elseif (is_integer($equipment))
		{
			$inv_slot = $equipment;
			$equipment = $this->inventory->getItemByIndex($inv_slot);
		}

		$notMet = [];

		foreach ($equipment->DSs_req as $DS => $min)
		{
			if ($this->$DS_names[$DS] < $min) $notMet[] = $DS_names[$DS];
		}

		if (!empty($notMet))
		{
			update_thoughts('Insufficient '. implode(', ', $notMet). " to equip {$equipment->name}!");
			return false;
		}

		if (isset($this->equipped[$equipment->EQP])) $this->unequip($equipment->EQP);

		$this->equipped[$equipment->EQP] = $inv_slot;

		$equipment->isEquipped = true;

		if (isset($equipment->spriteSet[SPRI_OVERSPRITE]))
		{
			$this->updateEquipmentSprite();
			$this->setSPRI(SPRI_GEAR);
		}
		else	//XXX
		{		//XXX
			console_echo("No oversprite for {$equipment->name}", '#fda');
		}		//XXX

		$updateStats		= false;
		$updateReadiness	= false;

		if (isset($equipment->DMGDL))
		{
			$this->DMGDL = $equipment->DMGDL;
			$updateReadiness = true;
		}

		$equipment->onEquip();

//		update_stats(); // Oosenupt - fix this; trim down the number of stats updated


		update_thoughts("{$equipment->name} equipped!");

		$this->attack = new Attack($this);

		if ($this === $GLOBALS['player'])
		{
			console_echo('Equipment change on player detected.', '#afa');
			update_items($equipment);
			update_stats(array_keys($equipment->DSs));
			update_readiness();
			update_playerHp();
			update_playerEp();

			if ($equipment->EQP === EQP_HAND || $equipment->EQP === EQP_OFFHAND)
			{
				console_echo('update_technique');
				update_technique();
			}
		}
		console_echo('Equipment change complete.', '#aff');
	}


	function unequip($EQP)
	{
		if ($EQP instanceof Equipment) $EQP = $EQP->EQP;
		$equipment = $this->getItemByEQP($EQP);

		unset($this->equipped[$EQP]);

		$equipment->isEquipped = false;
		if (isset($equipment->spriteSet[SPRI_OVERSPRITE]))
		{
			$this->updateEquipmentSprite();
			$this->setSPRI(SPRI_GEAR);
		}

		$updateReadiness = false;

		if (isset($equipment->DMGDL))
		{
			$this->DMGDL = $this->default_DMGDL;
			$updateReadiness = true;
		}

		$equipment->onUnequip();

		if ($updateReadiness) update_readiness();

		update_thoughts("{$equipment->name} unequipped.");

		$this->attack = new Attack($this);

		if ($this === $GLOBALS['player'])
		{
			update_items($equipment);
			update_stats(array_keys($equipment->DSs));
			update_readiness();
			update_playerHp();
			update_playerEp();

			if ($equipment->EQP === EQP_HAND || $equipment->EQP === EQP_OFFHAND)
			{
				update_technique();
			}
		}
	}

	function getItemByEQP($EQP)
	{
		if (isset($this->equipped[$EQP]))
		{
			return $this->inventory->getItemByIndex($this->equipped[$EQP]);
		}
		else return false;
	}

	function updateEquipmentSprite ()
	{
		global $view;

		console_echo('Updating EQP sprite', null, CNS_SPRITE);		//XXX
		$sprite = new Sprite($this->spriteSet[SPRI_DEFAULT]->frames);
		foreach ($this->equipped as $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);
			if (isset($equipment->spriteSet[SPRI_OVERSPRITE]))
			{
				$sprite = $sprite->augment($equipment->spriteSet[SPRI_OVERSPRITE]);
				console_echo('Applying this overSprite: ' . console_sprite($equipment->spriteSet[SPRI_OVERSPRITE]), null, CNS_SPRITE);
			}
			else	//XXX
			{		//XXX
				console_echo("No oversprite for {$equipment->name}", null, CNS_SPRITE);
			}		//XXX
		}

		if (isset($this->spriteSet[SPRI_GEAR]) && $this->spriteSet[SPRI_GEAR]->equals($sprite))
		{
			console_echo('Old gear sprite is identical to new gear sprite. Pretend nothing happened.', null, CNS_SPRITE);
			console_echo(console_sprite($sprite) . ' === ' . console_sprite($this->spriteSet[SPRI_GEAR]), null, CNS_SPRITE);
			return;
		}

		console_var_dump($sprite);

		unset($this->spriteSet[SPRI_GEAR]);
		$this->spriteSet[SPRI_GEAR] = $view->addClientSprite($sprite);


		console_var_dump($this->spriteSet[SPRI_GEAR]);

		$this->currentSPRI = null;

//		return $this->spriteSet[SPRI_GEAR];
//		return $sprite;
	}

	function alterHp($amount)
	{
		$hpMax = $this->__get('hp_max'); // Annoying

//		$this->hp += $amount;
		$this->hp = sa($this->hp, $amount);
		if ($this->hp > $hpMax) $this->hp = $hpMax;
		if ($this->hp <= 0) $this->hp = 0;

		return $this->hp > 0;
	}

	function alterEp($amount, $reduceToZero = false)
	{
		$epMax = $this->__get('ep_max'); // Annoying
		$amount = $amount;

		$this->ep += $amount;
		if ($this->ep > $epMax) $this->ep = $epMax;
		if ($this->ep <= 0)
		{
			if (!$reduceToZero) $this->ep -= $amount;
			return false;
		}
		return true;
	}

	function regenerate ()
	{
		$hp = $this->__get('regeneration') * ($_SERVER['REQUEST_TIME_FLOAT'] - $this->lastUpdated);
		$this->alterHp($hp);

		$ep = $this->__get('recharge') * ($_SERVER['REQUEST_TIME_FLOAT'] - $this->lastUpdated);
		$this->alterEp($ep);
	}




	function doAttack (Dude $target)
	{
		$this->attack->attacker = $this;
		$this->attack->execute($target);
	}

	function speak ($speech_or_SPSI, $context = null, $force = false)
	{
		global $rootPath;
		global $player;
		global $map;

		if ($this->speAnnex)
		{
			console_echo('What\'s in the speAnnex?', '#faf');
			console_class_list($this->speAnnex, '#faa');
			console_echo('Let\'s hope it\'s all in there with good reason, ey?', '#faf');
		}

		if ($_SERVER['REQUEST_TIME_FLOAT'] < $this->nextSpeak && !$force) return;

		if (is_numeric($speech_or_SPSI))
		{
			$SPSI = $speech_or_SPSI;

			if (is_array($context))
			{
				foreach ($context as $name => $val)
				{
					console_echo("{$name}: <<#fff>>{$val}<>");
					$$name = $val;
				}
			}

			$speech = [];

			include "{$rootPath}content/speech/{$this->speechFile}.spe";

			if (empty($speech)) include "{$GLOBALS['rootPath']}content/speech/_default.spe";

			$compiledSpeech = '';
			// $speech is set inside the .spe file
			// The nomclature in this section sucks ass. My apologies.
			if (!empty($speech))
			{
				$phrase = $speech[array_rand($speech)];

				foreach ($phrase as $line)
				{
					$compiledSpeech .= (is_array($line) ? $line[array_rand($line)] : $line);
				}
			}
			else
			{
				$compiledSpeech = 'Oh dear, I\'ve completely forgotten what I was going to say...';
				console_echo("Missing speech file \"{$this->speechFile}\" for {$this->name}", '#faa');		//XXX
			}
		}
		else
		{
			$compiledSpeech = $speech_or_SPSI;
		}

		$displayName = '';
		if ($this->gender !== null)
		{
			$displayName = ($this->gender == GND_MALE ? '&#x2642; ' : '&#x2640; ');
		}
		$displayName .= $this->name;

		update_conversation($displayName, $compiledSpeech, $this->speechColour);
		$this->nextSpeak = $_SERVER['REQUEST_TIME_FLOAT'] + SPEECH_DELAY;
	}




	public function getTEQbiases($TEQT = null, $forUpdate = false)
	{
		global $DS_names;
		global $TEQ_names;

		$values = [];

		if (!isset($TEQT)) $TEQT = TEQT_MELEE;

		if (!$forUpdate && isset($this->TEQbiasCache[$_SERVER['REQUEST_TIME_FLOAT']]))
		{
			if (isset($this->TEQbiasCache[$_SERVER['REQUEST_TIME_FLOAT']][$TEQT]))
			{
				console_echo('Returning cached TEQ biases!', '#afa');
				return $this->TEQbiasCache[$_SERVER['REQUEST_TIME_FLOAT']][$TEQT];
			}
		}
		else
		{
			console_echo('No TEQ biases have been cached <<#faa>>:(<>', '#fda');
			$this->TEQbiasCache = [];
		}

		$TEQTs = ['default' => $this->technique[$TEQT]];

		$hand = $this->getItemByEQP(EQP_HAND);
		$offHand = $this->getItemByEQP(EQP_OFFHAND);

		if ($hand && isset($hand->technique[$TEQT]))		$TEQTs[get_class($hand)]	= $hand->technique[$TEQT];
		if ($offHand && isset($offHand->technique[$TEQT]))	$TEQTs[get_class($offHand)] = $offHand->technique[$TEQT];

		// For every aspect of a technique (damage, accuracy etc.), we need to
		// search for how to source its values and then get the values themselves.
		foreach ($TEQ_names as $TEQ => $name)
		{
			if (!$forUpdate) $values[$TEQ] = 0;

			// There are three (and a half) potential sources of technique: item in hand, item
			// in off hand and the base dude. A dude can also have its own technique points that only
			// work for specific item classes.
			foreach ($TEQTs as $className => $TEQTarray)
			{
				// If the TechniqueType that we're examining contribues to this Technique aspect,
				// get all its values out.
				if (isset($TEQTarray[$TEQ]))
				{
					// For every stat inside the Technique aspect that is used to source its bias value,
					// pull it out, pmultiply it by the relevant dude stat and add it to the finished array.
					foreach ($TEQTarray[$TEQ] as $DS => $multiplier)
					{
						if ($forUpdate)
						{
							if (!isset($values[$DS])) $values[$DS] = [];
							$values[$DS][$TEQ] = isset($values[$DS][$TEQ]) ? $values[$DS][$TEQ] + $multiplier : $multiplier;
						}
						else
						{
							$values[$TEQ] += ($this->__get($DS_names[$DS]) * $multiplier);
						}
					}

					// This is where we check if the dude we're currently evaluating has an item-specific
					// set of technique contributors.
					if (isset($this->technique[$className]) && isset($this->technique[$className][$TEQT]))
					{
						$classTEQT = $this->technique[$className][$TEQT];
					}

					// If they do, treat them in much the same way.
					if (isset($classTEQT))
					{
						foreach ($classTEQT[$TEQ] as $DS => $multiplier)
						{
							if ($forUpdate)
							{
								if (!isset($values[$DS])) $values[$DS] = [];
								$values[$DS][$TEQ] = isset($values[$DS][$TEQ]) ? $values[$DS][$TEQ] + $multiplier : $multiplier;
							}
							else
							{
								$values[$TEQ] += ($this->__get($DS_names[$DS]) * $multiplier);
							}
						}
					}

					if (isset($values[$TEQ]))
					{
						$finalMultiplier = $this->__get($TEQ_names[$TEQ]);

						if ($finalMultiplier)
						{
							$values[$TEQ] = sa($values[$TEQ], "{$finalMultiplier}%");
						}

//						console_echo("Oosenupt - <<#fff>>{$finalMultiplier}<>", '#aaf');
					}
				}
			}
		}
		// Fuck me, what an abortion of a loop.

		$this->TEQbiasCache[$_SERVER['REQUEST_TIME_FLOAT']][$TEQT] = $values;

		return $values;
	}

	////////////////////////////
	//
	//		STATIC SPRITE FUNCTIONS
	//
	////////////////////////////

	public static function getDudeSprite($GND = null, $char_head = null, $char_body = null, $col_head = null, $col_body = null)
	{
		if (!$GND === null)
		{
			$genders = [GND_MALE, GND_FEMALE];
			$GND = $genders[array_rand($genders)];
		}

		if (!$char_head)
		{
			if ($GND === GND_MALE)
			{
				$headChars = ['o', 'c', 'e', 'Q', 'b', 'd', 'O', '6', '&#x03b4;', '&#x03c3;'];
			}
			else
			{
				$headChars = ['g', 'p', 'q', '9'];
			}

			$char_head = $headChars[array_rand($headChars)];
		}

		if (!$char_body)
		{
			if ($GND === GND_MALE)
			{
				$bodyChars = ['X', 'n', '&Pi;', '&Omega;', '&#x2229;', '&#x041f;', '&#x039b;', '&#x005e;'];
			}
			else
			{
				$bodyChars = ['&#x0434;', '&#x0414;', 'A', '&#x0394;'];
			}

			$char_body = $bodyChars[array_rand($bodyChars)];
		}

		if (!$col_head)
		{
			$skinReducer = rand(1, 5);
			$r = (dechex(15 - $skinReducer));
			$g = (dechex(15 - (2 * $skinReducer)));
			$b = (dechex(15 - (3 * $skinReducer)));
			$col_head = "#{$r}{$g}{$b}";
		}

		if (!$col_body)
		{
			if ($GND === GND_MALE)
			{
				$col_body = '#' . dechex(rand(0, 6)) . dechex(rand(0, 6)) . dechex(rand(0, 10));
			}
			else
			{
				$col_body = '#' . dechex(rand(5, 15)) . dechex(rand(5, 15)) . dechex(rand(0, 9));
			}
		}

		return new Sprite(
			array(
				1 => new SpriteElement(null, $col_head, $char_head),

				3 => new SpriteElement(null, $col_head, '&deg;'),
				4 =>new SpriteElement(null, $col_body, $char_body),
				5 =>new SpriteElement(null, $col_head, '&deg;')
			)
		);
	}

	public static function getCorpseSprite(Sprite $sprite = null, $col_blood = null)
	{
		if (!$col_blood)	$col_blood = '#f00';

		if ($sprite)
		{
			$spr_person = clone $sprite;
		}
		else
		{
			$spr_person = self::getDudeSprite();
		}

		if (isset($spr_person->frames[0][1]))
		{
			$head = $spr_person->frames[0][1];
		}
		else
		{
			$index = array_rand($spr_person->frames[0]);

			$head = $spr_person->frames[0][$index];
			unset($spr_person->frames[0][$index]);
		}

		if (isset($spr_person->frames[0][4]))
		{
			$body = $spr_person->frames[0][4];
		}
		else
		{
			$index = array_rand($spr_person->frames[0]);

			$body = $spr_person->frames[0][$index];
			unset($spr_person->frames[0][$index]);
		}

		$entrailsChars = [
			'~',
			'&#x03c9;',
			'&#x03be;',
			'&#x03b6;',
			'&#x2665;',
		];

		$blood = [
			'.',
			':',
			'&bull;',
			'&#x0387;',
		];

		$headPos = rand(0,1);

		return new Sprite([
			new SpriteElement(null, $col_blood, $blood[array_rand($blood)]),
			new SpriteElement(null, $col_blood, $blood[array_rand($blood)]),
			new SpriteElement(null, $col_blood, $blood[array_rand($blood)]),

			($headPos ? $head : $body ),
			new SpriteElement(null, $col_blood, $entrailsChars[array_rand($entrailsChars)]),
			($headPos ? $body : $head ),
		]);
	}

	////////////////////////////
	// These are the events as they will be called from outside. These can be
	// altered but at this time, I can't think why they should.
	////////////////////////////

	function attack(Attack $attack)
	{
		$this->onAttack($attack);

		foreach ($this->equipped as $EQP => $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);
			$equipment->onAttack($attack);
		}
	}

	function miss(Attack $attack)
	{
		$this->onMiss($attack);

		foreach ($this->equipped as $EQP => $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);
			$equipment->onMiss($attack);
		}
	}

	function strike(Attack $attack)
	{
		$this->onStrike($attack);

		foreach ($this->equipped as $EQP => $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);
			$equipment->onStrike($attack);
		}
	}

	function kill(Attack $attack)
	{
		$this->onKill($attack);

		foreach ($this->equipped as $EQP => $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);
			$equipment->onKill($attack);
		}
	}

	function defend(Attack $attack)
	{
		$this->onDefend($attack);

		foreach ($this->equipped as $EQP => $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);
			$equipment->onDefend($attack);
		}
	}

	function deflect(Attack $attack)
	{
		$this->onDeflect($attack);

		foreach ($this->equipped as $EQP => $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);
			$equipment->onDeflect($attack);
		}
	}

	function takeHit(Attack $attack)
	{
		$this->onTakeHit($attack);

		foreach ($this->equipped as $EQP => $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);
			$equipment->onTakeHit($attack);
		}
	}

    function death(Attack $attack)
	{
		if ($this instanceof Player)
		{
			return; // Oosenupt - This whole function will probably be overridden in Player class anyway
		}
		else
		{
			$this->wallet->dumpIntoInventory();
		}

		console_echo('Before onDeath');
		$this->onDeath($attack);
		console_echo('After onDeath');

		foreach ($this->equipped as $EQP => $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);
			$equipment->onDeath($attack);
		}

		console_echo("Before death's destroy. ID:{$this->id}");
		$this->destroy();
		console_echo('After death\'s destroy');
	}

	///////////////////////////////////////////////////////
	// If anything needs to intercept any of these events, it should happen in
	// the functions above, not the "on" functions. They should all be the same
	// as each other.
	///////////////////////////////////////////////////////

	final function onAttack		(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	final function onMiss		(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	final function onStrike		(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	final function onKill		(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }

	final function onDefend		(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	final function onDeflect	(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	final function onTakeHit	(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	final function onDeath		(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
}

abstract class DudeBehaviour extends ObjectBehaviour
{
	public $onAttack			= null;
	public $onMiss				= null;
	public $onStrike			= null;
	public $onKill				= null;

	public $onDefend			= null;
	public $onDeflect			= null;
	public $onTakeHit			= null;
	public $onDeath				= null;

	public function onAttack	(Attack $attack) { }
	public function onMiss		(Attack $attack) { }
	public function onStrike	(Attack $attack) { }
	public function onKill		(Attack $attack) { }

	public function onDefend	(Attack $attack) { }
	public function onDeflect	(Attack $attack) { }
	public function onTakeHit	(Attack $attack) { }
	public function onDeath		(Attack $attack) { }
}

abstract class Enemy extends Dude
{
	public $obhv_awarenessRange;
	public $obhv_chaseRange;

	public function __construct($name, $spriteSet, $gender = null, $speechFile = null, $dudeStats = null)
	{
		global $player;

		$this->FAC		= FAC_MONSTER;
		$this->canPush	= false;

		parent::__construct($name, $spriteSet, $gender, $speechFile, $dudeStats);

		$this->initialiseLoot();

		$obhv_chase = new obhv_chase($player, 1);

		$this->addBehaviour(
			new obhv_wander(),
			new obhv_addBehaviourOnProximity(null, $obhv_chase, $this->obhv_awarenessRange, $this->obhv_chaseRange),
			new dbhv_leaveLootableCorpse($this->spriteSet)
		);

		unset($this->obhv_awarenessRange);
		unset($this->obhv_chaseRange);
	}

	public function __clone()
	{
		parent::__clone();

		$this->initialiseLoot();
	}

	/**
	* A loot array should look like this(-ish):
	*	$lootArray => [
	*		$oddsOfAppearing => [
	*			$exclusiveItem,
	*			$exclusiveItem,
	*			[
	*				$getAllTheseItems,
	*				$getAllTheseItems,
	*				$getAllTheseItems,
	*			],
	*			$exclusiveItem,
	*		],
	*		$oddsOfAppearing => [
	*			$exclusiveItem,
	*			$exclusiveItem,
	*		]
	*	];
	*
	* Where the odds of appearing a rolled separately for each item but if it's an
	* array, the whole array of items is given together.
	*/
	abstract function getLootArray();

	public function initialiseLoot ()
	{
		$lootArray = $this->getLootArray();

		foreach ($lootArray as $odds => $stuff)
		{
			$vars = explode(':', "{$odds}");

			$odds = $vars[0];
			$max = isset($vars[1]) ? $vars[1] : 1;

			shuffle($stuff);

			$got = 0;

			foreach ($stuff as $thing)
			{
				if (percentageToBool($odds))
				{
					if (!is_array($thing)) $thing = [$thing];

					foreach ($thing as $item)
					{
						$item->finish();
						console_echo($item->id, null, CNS_ITEMS);
						$this->inventory->add(clone $item, true);
					}

					$got++;
				}

				if ($got >= $max) break;
			}
		}
	}
}

abstract class NPC extends Dude
{
	public $NPCIs = [];

	function __construct($name, $spriteSet, $gender = null, $speechFile = null)
	{
		$this->FAC = FAC_NPC_NEUTRAL;

		parent::__construct($name, $spriteSet, $gender, $speechFile);

		// If something weird is going on, try moving these behaviours before the parent constructor. I changed it without testing it because I'm a BADASS.
		// Knowing what I know now, there is no way this shit should ever be before the parent constructor.
		$this->addBehaviour(
			new dbhv_leaveLootableCorpse($this->spriteSet), // Had to change this from $spriteSet to $this->spriteSet nearly a year later because I'm not as much of a BADASS as I thought.
			new dbhv_fleeWhenAttacked(10),
			new dbhv_speak()
		);

		$newNPCIs = [];
		foreach ($this->NPCIs as $NPCI)
		{
			$NPCI->owner = $this;
			$newNPCIs[$NPCI->key] = $NPCI;
		}
		$this->NPCIs = $newNPCIs;
	}

	public function addNPCI (NPCInteraction $NPCI)
	{
		$NPCI->owner = $this;
		$this->NPCIs[$NPCI->key] = $NPCI;
	}

	public function onEngage(Player $player)
	{
		parent::onEngage($player);

		$update = new stdClass();
		$update->type = 'init';
		$update->NPCIs = [];

		foreach ($this->NPCIs as $key => $NPCI)
		{
			$updateNPCI = new stdClass();

			$updateNPCI->name = $NPCI->name;
			$updateNPCI->desc = $NPCI->description;
			$updateNPCI->key = $NPCI->key;

			$update->NPCIs[] = $updateNPCI;
		}

		update(UPD_INTERACTIONS, $update);
	}

	public function onDisengage(Player $player)
	{
		parent::onDisengage($player);

		clearPanel(UPD_INTERACTIONS);
	}

	public function executeNPCIbehaviours ($TRG, $arg1 = null, $arg2 = null, $arg3 = null)
	{
		console_echo('Running NPCIs as behaviours');
		foreach ($this->NPCIs as $NPCI)
		{
			if ($NPCI->can($TRG))
			{
				$NPCI->$TRG($arg1, $arg2, $arg3);
				$NPCI->triggercooldown();
			}
		}
	}
}

abstract class Passive extends DudeBehaviour implements SkillInterface
{
	public $key;

	public $name;
	// Behaviour class has a description variable already.
	public $sprite;
	public $level = 1;

	public $requiredLevel = 1;

	public function __construct($name, Sprite $sprite)
	{
		$this->name		= $name;
		$this->sprite	= $sprite;

		$this->key		= get_class($this);

		parent::__construct(null, null);
	}

//	public abstract function getDescription ();

	public function inspect() { update_passiveInfo($this); }

	public function __debugInfo()
	{
		return [
			'name' => $this->name,
			'description' => $this->getDescription(),
			'sprite' => $this->sprite,
			'level' => $this->level,
			'owner' => $this->owner->name,
		] + parent::__debugInfo();
	}
}

class Quest
{
	public $owner;			// Dude doing the quest
	public $name;			// Name of the quest
	public $id;
	public $description;	// Description of the quest

	/** This should be a nested array with a structure as follows:

	$tasks =
	[
		$taskInSeries,
		$taskInSeries,
		[
			$taskInParallel,
			$taskInParallel,
			$taskInParallel,
		],
		[
			$taskInParallel,
			$taskInParallel,
		],
		$taskInSeries,
		$taskInSeries,
		[
			$taskInParallel,
			$taskInParallel,
		],
		...ETC
	]

	This way, quests can be arranged with a number of tasks that can be
	completed in any order and other tasks that must be completed in order.
	*/
	public $tasks;

	public $reward;
	public $penalty;

	public $complete = false;
	public $failed = false;

	public $hidden = false;
	public $taskNumber = 0;

	public $retryDelayHours = 1;

	public function __construct($name, $description, $tasks, $reward = null, $penalty = null)
	{
		$this->name			= $name;
		$this->id			= id();
		$this->description	= $description;

		foreach ($tasks as &$task)
		{
			if (!is_array($task))
			{
				$task = [$task];
			}

			foreach ($task as &$t)
			{
				$t->quest = $this;
				$t->number = $this->taskNumber++;
			}
		}

		if ($reward)	$this->reward	= is_array($reward)		? $reward	: [$reward];
		if ($penalty)	$this->penalty	= is_array($penalty)	? $penalty	: [$penalty];

		$this->tasks = $tasks;
	}

	public function getAjaxObject()
	{
		$ajaxObj = new stdClass();

		$ajaxObj->name	= $this->name;
		$ajaxObj->desc	= $this->description;
		$ajaxObj->id	= $this->id;

		if ($this->reward)
		{
			$ajaxObj->rwd	= '';

			foreach ($this->reward as $reward)
			{
				if (!$reward->hidden) $ajaxObj->rwd .= "{$reward->description} ";
			}
		}

		if ($this->penalty)
		{
			$ajaxObj->pnlt	= '';

			foreach ($this->penalty as $penalty)
			{
				if (!$penalty->hidden) $ajaxObj->pnlt .= $penalty->description;
			}
		}

		if ($this->complete)	$ajaxObj->complete	= true;
		if ($this->failed)		$ajaxObj->failed	= true;

		$ajaxObj->tasks	= [];

		foreach ($this->tasks as $phase)
		{
			foreach ($phase as $task)
			{
				if (!$task->hidden) $ajaxObj->tasks[] = $task->getAjaxObject();
			}
		}

		return $ajaxObj;
	}

	public function getActiveTasks()
	{
		if ($this->complete || $this->failed) return [];

		$activeTasks = [];
		foreach ($this->tasks as $phase)
		{
			$allFailing = true;

			foreach ($phase as $task)
			{
				if ($task->complete)
				{
					if ($task->failureCondition)
					{
						$this->fail();
						return [];
					}
					continue;
				}

				if (!isset($activeTasks[$task->EOI])) $activeTasks[$task->EOI] = [];
				if (!$task->active) $task->onActivate();

				if ($task->complete) continue; // We have to check this a second time in case the quest was complete by the onActivate() function.

				$task->active = true;

				console_echo("Activating a task with the description: {$task->description}", '#fff');

				if ($allFailing && !$task->failureCondition) $allFailing = false;

				$activeTasks[$task->EOI][] = $task;
			}
			// Put something in here to make sure there aren't ONLY failing conditions left.
			if ($allFailing)
			{
				foreach ($activeTasks as $phase)
				{
					foreach ($phase as $task)
					{
						console_echo("Deactivating task \"{$task->description}\"");
						$task->active = false;
					}
				}

				$activeTasks = [];
			}

			if (!empty($activeTasks)) break;
		}

		if (empty($activeTasks))
		{
			$this->complete();
		}

		return $activeTasks;
	}

	public function complete()
	{
		$this->complete = true;
		if ($this->reward)
		{
			foreach ($this->reward as $reward)
			{
				$reward->deliver($this->owner);
			}
		}
//		$this->owner->completedQuests[$this->name] = $_SERVER['REQUEST_TIME_FLOAT'];
		$this->owner->completedQuests = [$this->name => $_SERVER['REQUEST_TIME_FLOAT']] + $this->owner->completedQuests;
	}

	public function fail()
	{
		foreach ($this->tasks as $phase)
			foreach ($phase as $task)
			{
				$task->active = false;
			}
		$this->failed = true;
		if ($this->penalty)
		{
			foreach ($this->penalty as $penalty)
			{
				$penalty->deliver($this->owner);
			}
		}

		$retryDelaySeconds = $this->retryDelayHours * 3600;

		$this->owner->failedQuests[$this->name] = $_SERVER['REQUEST_TIME_FLOAT'] + $retryDelaySeconds;
	}
}

trait QuestCapability
{
	// TODO: Implement quest abandoning. Abandoned quests should deliver their
	// penalties unless abandoned in a town but delay time for re-attempt should
	// be halved or abolished (if too short).

	// Array of current quests. Format should be {name} => {quest object}.
	public $quests = [];

	public $activeTasks = [];

	// Array of completed quests. Format should be {name of quest} => {completion timestamp}.
	public $completedQuests = [];

	// Array of failed/abandoned quests. Format should be {name of quest} => {timestamp when re-attempt is allowed}.
	public $failedQuests = [];
	public $abandonedQuests = [];

	/**
	 *
	 * @param Quest $quest - The qust to be added to the quest list of the dude.
	 * @return string - Returns a QS variable that describes the status of the quest passed in.
	 */
	public function addQuest(Quest $quest)
	{
		if (isset($this->completedQuests[$quest->name])) return QS_COMPLETE;

		if (isset($this->failedQuests[$quest->name]))
		{
			if ($this->failedQuests[$quest->name] > $_SERVER['REQUEST_TIME_FLOAT']) return QS_FAILED;
		}

		if (isset($this->abandonedQuests[$quest->name]))
		{
			if ($this->abandonedQuests[$quest->name] > $_SERVER['REQUEST_TIME_FLOAT']) return QS_ABANDONED;
		}

		if (isset($this->quests[$quest->name]))
		{
			if ($this->quests[$quest->name]->failed)
			{
				console_echo("Overwriting failed quest \"<<#faa>>{$quest->name}<>\".", '#ffa');
				unset($this->quests[$quest->name]);
			}
			else
			{
				console_echo("Attempting to add quest \"<<#ffa>>{$quest->name}<>\" to someone who already has that quest.", '#faa');
				return QS_IN_PROGRESS;
			}
		}
		$quest->owner = $this;

		$this->quests[$quest->name] = $quest;

		update_quests([$quest]);

		return QS_NOT_STARTED;
	}

	public function getQS($quest)
	{
		if (!is_string($quest)) $quest = $quest->name;

		if (isset($this->quests[$quest]))			return QS_IN_PROGRESS;
		if (isset($this->completedQuests[$quest]))	return QS_COMPLETE;
		if (isset($this->failedQuests[$quest]))		return QS_FAILED;
		if (isset($this->abandonedQuests[$quest]))	return QS_ABANDONED;

		return QS_NOT_STARTED;
	}

	public function getActiveTasks()
	{
		$activeTasks = [];

		foreach ($this->quests as $quest)
		{
			$questActiveTasks = $quest->getActiveTasks();
			foreach ($questActiveTasks as $EOI => $tasks)
			{
				if (isset($activeTasks[$EOI]))
				{
					$activeTasks[$EOI] = array_merge($activeTasks[$EOI], $tasks);
				}
				else
				{
					$activeTasks[$EOI] = $tasks;
				}
			}
		}
		$this->activeTasks = $activeTasks;

		return $activeTasks;
	}

	public function handleEventOfInterest($EOI)
	{
		if (isset($this->activeTasks[$EOI])) console_echo('Handling event of interest: ' . $EOI . ' count: '.count($this->activeTasks[$EOI]), '#faf');

		$completedTasks = [];

		if (!isset($this->activeTasks[$EOI])) return;

		$args = func_get_args();
		array_shift($args);				// Gets rid of the $EOI value.
		$args = array_values($args);	// Rebase the array at 0.

		$questsForRefresh = [];
		foreach ($this->activeTasks[$EOI] as $task)
		{
			$task->check($args);

			if ($task->complete)
			{
				$questsForRefresh[] = $task->quest;
				$completedTasks[] = $task;
			}
		}

		if ($questsForRefresh) update_quests($questsForRefresh);

		return $completedTasks;
	}
}

abstract class QuestResult
{
	public $description;
	public $hidden		 = false;

	public function __construct($description)
	{
		$this->description = $description;
	}

	abstract function deliver (Player $recipient);
}

abstract class Task
{
	public $quest;				// Link to owning quest
	public $description;		// Description of the task
	public $number;				// Number of the task within the quest

	public $EOI;				// Event of interest

	public $failureCondition = false;	// If true, completion of this task will cause the quest to fail.

	public $active		= false;
	public $complete	= false;	// Completion status of the task

	public $hidden		= false;

	// $args will differ depending on the triggering event.
	// If the task criteria have been met, compelte() sould be called from within
	// this function.
	public abstract function check($args);

	// If you need to run some shit when the task first becomes active, override
	// this function and put it in there.
	// (e.g., checking if you already have the item that you're fetching)
	public function onActivate() { }

	final public function complete()
	{
		console_echo($this->description . ' has been completed!', '#afa');

		$this->complete = true;
		$this->active = false;

		if ($this->failureCondition)
		{
			$this->quest->fail();
		}
	}

	public function getAjaxObject()
	{
		$ajaxObj = new stdClass();

		$ajaxObj->desc	= $this->description;
		$ajaxObj->num	= $this->number;
		$ajaxObj->qst	= $this->quest->name;

		$ajaxObj->fail	= $this->failureCondition;
		$ajaxObj->comp	= $this->complete;
		$ajaxObj->actv	= $this->active;

		return $ajaxObj;
	}
}

class Player extends Dude
{
	use QuestCapability;

    public $name;

	public $xp			= 0;
	public $nextLevel	= 100;

    public $MAP;
	public $mapId;

	public $slm_head;
	public $slm_hand;
	public $slm_legs;

	public $opponent = null;

	public $lastMoved;

	public $canPush = true;
	public $canOpenDoors = true;

	public $showItemPrices = false;

	public $bindings = [];

	public $lvl_DSs = [
		DS_HP_MAX => 1,
		DS_EP_MAX => 1,
	];

	public $used_DSs = [];
	public $observed_skills = [];
	// note: $used_skills is in the skillsCapability trait. - I don't know what's best but that's where it is.

	public $pendingBoons = [];
	public $pendingBoonCount = 0;

	public $TPL_passables = [
		TPL_OPENGROUND,
		TPL_LADDER,
		TPL_STAIRS,
	];

	public $WPs = [];

	public $checkpoint_n_offset;
	public $checkpoint_w_offset;
	public $checkpoint_MAP;

	public $technique = [
		TEQT_MELEE => [	// This has been tuned; the others ahave not.
			TEQ_DAMAGE		=> [DS_STRENGTH => 0.4, DS_FORCE => 0.4],
			TEQ_HIT_CHANCE	=> [DS_CONTROL => 0.8],
			TEQ_CRIT_DAMAGE	=> [DS_FORCE => 0.4, DS_FINESSE => 0.4],
			TEQ_CRIT_CHANCE	=> [DS_DEXTERITY => 0.4],
			TEQ_DEFENCE		=> [DS_RESILIENCE => 0.8],
			TEQ_DODGE_CHANCE	=> [DS_EVASIVENESS => 0.4, DS_AGILITY => 0.4],

			TEQ_ATTACK_SPEED	=> [DS_STRENGTH => 0.4, DS_FINESSE => 0.4],
			TEQ_CONSISTENCY	=> [DS_FINESSE => 0.4, DS_CONTROL => 0.4],
		],
		TEQT_MAGIC => [
			TEQ_DAMAGE		=> [DS_MAGIC => 0.8, DS_DISRUPTION => 0.5],
			TEQ_HIT_CHANCE	=> [DS_DISCIPLINE => 1],
			TEQ_CRIT_DAMAGE	=> [DS_FOCUS => 0.5],
			TEQ_CRIT_CHANCE	=> [DS_DISCIPLINE => 0.5, DS_DISRUPTION => 0.7],
			TEQ_DEFENCE		=> [DS_FOCUS => 1],
			TEQ_DODGE_CHANCE	=> [DS_FOCUS => 1],

			TEQ_ATTACK_SPEED	=> [DS_MAGIC => 1],
			TEQ_CONSISTENCY	=> [DS_FOCUS => 0.8],
		],
		TEQT_RANGED => [
			TEQ_DAMAGE		=> [DS_DEXTERITY => 0.8, DS_AGILITY => 0.5, DS_CONTROL => 0.4],
			TEQ_HIT_CHANCE	=> [DS_BALANCE => 0.5, DS_DEXTERITY => 0.5, DS_HEURISTICS => 0.2],
			TEQ_CRIT_DAMAGE	=> [DS_FINESSE => 0.5, DS_KNOWLEDGE => 0.4],
			TEQ_CRIT_CHANCE	=> [DS_INTELLECT => 0.5, DS_FINESSE => 0.7],
			TEQ_DEFENCE		=> [DS_AGILITY => 0.5, DS_RESILIENCE => 0.5],
			TEQ_DODGE_CHANCE	=> [DS_AGILITY => 1],

			TEQ_ATTACK_SPEED	=> [DS_FINESSE => 0.3, DS_CONTROL => 0.4],
			TEQ_CONSISTENCY	=> [DS_CONTROL => 0.5],
		]
	];

    function __construct($name, $MAP, $n_offset, $w_offset, $skinColour, $pantsColour, $headChar, $legsChar, $gender = GND_MALE)
    {
		$this->name = $name;

		$this->FAC	= FAC_PLAYER;

        $this->slm_head =   new SpriteElement(null, $skinColour, $headChar);
        $this->slm_hand =	new SpriteElement(null, $skinColour, '&deg;');
        $this->slm_legs =	new SpriteElement(null, $pantsColour, $legsChar);

        $this->sprite = new Sprite(
            array(
                1 => $this->slm_head,
                3 => $this->slm_hand,$this->slm_legs,$this->slm_hand)
            );

//        $this->sprite->key = 'player';

        $this->lastMoved = $_SERVER['REQUEST_TIME_FLOAT'];

        $this->MAP = $MAP;

		$this->n_offset = $n_offset;
		$this->w_offset = $w_offset;
		$this->layer	= LAYER_PLAYER;

		$this->checkpoint_n_offset	= $n_offset;
		$this->checkpoint_w_offset	= $w_offset;
		$this->checkpoint_MAP		= $MAP;

		$DSs = [
			DS_RANDOMISER => 0,
			DS_SPEED => 0.2,
			DS_SPEED_FAST => 0.2
		];

        parent::__construct($this->name, [$this->sprite], $gender, null, $DSs);

		$this->layer = LAYER_PLAYER;
    }

	function move($n_offset, $w_offset, $MAP = null)
    {
		global $map;
		global $view;

//		console_echo("Moving player to <<#fff>>{$n_offset}<>:<<#fff>>{$w_offset}<>:<<#fff>>{$MAP}<>", '#aaf');

		$requiredDelay = MIN_COOLDOWN - ($_SERVER['REQUEST_TIME_FLOAT'] - $this->lastMoved);
        if ($requiredDelay > 0)
        {
            $_SERVER['REQUEST_TIME_FLOAT'] += $requiredDelay;
            usleep($requiredDelay * 1000000);
        }

		if ($this->lastMoved + $this->__get('SPEED') > $_SERVER['REQUEST_TIME_FLOAT']) return false;

		if ($MAP && $this->MAP !== $MAP)
		{
			$this->disengage();

			$map->destroyObject($this);

			$this->MAP = $MAP;
			$this->n_offset = $n_offset;
			$this->w_offset = $w_offset;

			Map::mountPlayerMap();
		}
		else
		{

			if ($map->moveObject($this, $n_offset, $w_offset))
			{
				// Fix this - OOSENUPT!!!!
				if ($this->engagement !== null && !$this->isAdjacentTo($this->engagement))
				{
					console_echo("Disengaging {$this->engagement->name}", '#faf');
					$this->engagement->disengage();
				}

				$this->lastMoved = $_SERVER['REQUEST_TIME_FLOAT'];

				console_update_location();
			}
			else return false;
		}

		$view->forceUpdate = true;
		return true;
    }

	function alterHp ($amount)
	{
		$before = $this->hp;
		$stillAlive = parent::alterHp($amount);
		if ($before !== $this->hp) update_playerHp();
		return $stillAlive;
	}

	function alterEp ($amount, $reduceToZero = false)
	{
		$before = $this->ep;
		$successful = parent::alterEp($amount, $reduceToZero);
		if ($before !== $this->ep) update_playerEp();
		return $successful;
	}

	function alterXp ($amount)
	{
		$before = $this->xp;

		$this->xp += round($amount);
		if ($this->xp > $this->nextLevel)
		{
			$this->levelUp();
			return true;
		}
		update_playerXp();
		return false;
	}

	function levelUp ()
	{
		$this->xp -= $this->nextLevel;
		$this->nextLevel *= 1.8;
		$this->level++;

		update_playerXp(null, $this->level);
		update_thoughts("I've grown to level {$this->level}!");

		$this->getBoons();
	}

	/**
	 * Gets the Javascript associated with the player object for use in external
	 * javascript files.
	 *
	 * @return string (JavaScript)
	 */
    function getPlayerJS()
    {
        return $this->sprite->getJS();
    }

	function getWalletUpdateString()
	{
		return $this->wallet->getWalletString();
	}

	public function collide(AsObject $target, $DIR)
	{
		if ($this->engagement !== $target)
		{
			console_echo("Engaging {$target->name}", '#afa');
			$target->engage($this);
		}

		return parent::collide($target, $DIR);
	}

	function onMapChange()
	{
		$this->engagement = null;

		foreach ($this->equipped as $equiptmentIndex)
		{
			$equiptment = $this->inventory->getItemByIndex($equiptmentIndex);
			$equiptment->onMapChange();
		}
	}



	function addStatus($status)
	{
		parent::addStatus($status);
		update_statuses();
	}


	public function selectBoon ($index)
	{
		if (!isset($this->pendingBoons[$index]))
		{
			console_echo("<<#f55>>Trying to select a boon at index <<#fff>>{$index}<> but there is no boon there.<>");
			return;
		}

		$this->pendingBoons[$index]->deliver($this);

		$this->pendingBoonCount -= 1;
		if ($this->pendingBoonCount < 1)
		{
			$this->pendingBoons = [];
		}
		else
		{
			unset ($this->pendingBoons[$index]);
		}

		update_boons();
	}


	public function getBoons ()
	{
		if (count($this->used_DSs) < 3)
		{
			global $DS_typed;

			$this->used_DSs = array_keys($DS_typed);
			shuffle($this->used_DSs);
			$this->used_DSs = array_flip($this->used_DSs);
		}

		global $DS_names; console_echo("DSs use during <<#fff>>level {$this->level}<> experience gathering period:", '#afa');
		foreach ($this->used_DSs as $DS => $amount) //XXX
		{	//XXX
			console_echo("{$DS_names[$DS]}: <<#fff>>{$amount}<>", '#ffa');
		}	//XXX

		console_echo("Skills used during <<#fff>>level {$this->level}<> experience gathering period:", '#aff');
		foreach ($this->used_skills as $skill => $amount) //XXX
		{	//XXX
			console_echo("{$skill}: <<#fff>>{$amount}<>", '#faf');
		}	//XXX

		console_echo("Skills observed during <<#fff>>level {$this->level}<> experience gathering period:", '#afa');
		foreach ($this->observed_skills as $skill => $amount) //XXX
		{	//XXX
			console_echo("{$skill}: <<#fff>>{$amount}<>", '#faf');
		}	//XXX

		///////////////////////////////////
		//
		// STAT BOONS
		//
		///////////////////////////////////

		console_echo('Forming stat boons');

		arsort($this->used_DSs);
		$DS_useOrder		= array_keys($this->used_DSs);
		$DS_reverseUseOrder	= array_reverse($DS_useOrder);
		$DS_shuffledUse		= $DS_useOrder; shuffle($DS_shuffledUse);

//		foreach ($this->pendingBoons as $index => $boon)
//		{
//			if ($boon instanceof boon_stats)
//			{
//				// Get rid of all the HP and EP boosting boons.
//				if (isset($boon->DSs[DS_HP_MAX]) || isset($boon->DSs[DS_EP_MAX]))
//				{
//					unset($this->pendingBoons[$index]);
//				}
//			}
//		}

		$this->pendingBoons[$DS_useOrder[0].$DS_useOrder[1]] = new boon_stats([
			$DS_useOrder[0] => mt_rand(3, 8),
			$DS_useOrder[1] => mt_rand(3, 8),
		]);

		$this->pendingBoons[$DS_reverseUseOrder[0].$DS_reverseUseOrder[1]] = new boon_stats([
			$DS_reverseUseOrder[0] => mt_rand(10, 15),
			$DS_reverseUseOrder[1] => mt_rand(10, 15),
		]);

		$this->pendingBoons[$DS_shuffledUse[0].$DS_shuffledUse[1]] = new boon_stats([
			$DS_shuffledUse[0] => mt_rand(10, 15),
			$DS_shuffledUse[1] => mt_rand(10, 15),
		]);

		$this->pendingBoons[DS_HP_MAX] = new boon_stats([
			DS_HP_MAX => mt_rand(10, 15)
		]);

		$this->pendingBoons[DS_EP_MAX] = new boon_stats([
			DS_EP_MAX => mt_rand(10, 15)
		]);

		///////////////////////////////////
		//
		// USED SKILL BOONS
		//
		///////////////////////////////////

		console_echo('Forming skill boons');

		arsort($this->used_skills);

		$potentialBoonSkills = [];

		$all_skills = [];
		foreach ($this->skills as $skill)
		{
			$all_skills[] = $skill->key;
		}
		shuffle($all_skills);

		$all_skills = array_diff_key(array_flip($all_skills), $this->used_skills);


		if ($this->used_skills)
		{
			if (count($this->used_skills) <= 3)
			{
				foreach ($this->used_skills as $skillName => $amount)
				{
					$potentialBoonSkills[] = new $skillName (mt_rand(1, 3));
				}

			}
			else
			{
				$usedSkills = array_keys($this->used_skills);
				$most = array_shift($usedSkills);
				$least = array_pop($usedSkills);
				$other = $usedSkills(array_rand($usedSkills));

				$potentialBoonSkills[] = new $most	(mt_rand(1, 3));
				$potentialBoonSkills[] = new $least	(mt_rand(1, 3));
				$potentialBoonSkills[] = new $other	(mt_rand(1, 3));
			}
		}

		$count = 0;

		foreach ($all_skills as $skillName => $amount)
		{
//			$this->pendingBoons[$skillName] = new boon_skill(
//				new $skillName (mt_rand(1, 3))
//			);
			$potentialBoonSkills[] = new $skillName (mt_rand(1, 3));

			if (++$count >= 3) break;
		}

		foreach ($potentialBoonSkills as &$sklObject)
		{
			if ($relatedSkill = $sklObject->getRelatedSkills()) // Intentional assignment in an IF
			{
				console_echo("Checking for related skills for {$sklObject->name}.");

				foreach ($relatedSkill as $skillName => $requiredLevel)
				{
					console_echo("consider {$skillName} - level {$requiredLevel} {$sklObject->name} required");

					if (($this->skills[$sklObject->key]->level >= $requiredLevel) && percentageToBool(30))
					{
						console_echo("{$skillName} has been chosen.");
						$newSklObject = new $skillName ($sklObject->level);

						if ($this->level >= $newSklObject->requiredLevel)
						{
							console_echo("Changing {$sklObject->name} boon to a {$skillName} boon.");
							$sklObject = new $skillName ($sklObject->level);
							break;
						}
						else console_echo("Player level too low ({$newSklObject->requiredLevel} required but only have {$this->level})");
					}
					else console_echo("Insufficient skill level or bad boolean luck. Level found: {$this->skills[$sklObject->key]->level} but required: {$requiredLevel}");
				}
			}
			else console_echo("No related skills for {$sklObject->name}.");

			$this->pendingBoons[$sklObject->key] = new boon_skill($sklObject);
		}

		///////////////////////////////////
		//
		// OBSERVED SKILL BOONS
		//
		///////////////////////////////////

		console_echo('Forming observed skill boons');

		arsort($this->observed_skills);

		// Oosenupt - finish this bit.

		$this->pendingBoonCount += 2;

		$this->used_DSs		= [];
		$this->used_skills	= [];

		update_boons();
	}

	public function damageGear ($class)
	{
		$chanceToDamage = 10;

		foreach ($this->equipped as $index)
		{
			$equipment = $this->inventory->getItemByIndex($index);

			if (is_a($equipment, $class))
			{
				if (percentageToBool($chanceToDamage)) // LUCK?
				{
					$equipment->damageItem();

					if ($equipment->durability)
					{
						update_combat("{$equipment->name} was damaged! <span class=\"fade\">({$equipment->durability}/{$equipment->durabilityMax})</span>");
					}
					else
					{
						update_combat("{$equipment->name} was <<#faa>>broken<>!");
					}
				}
			}
		}
	}

	//////////////////////////////////////////////////
	//
	//	Over-written core dude functions. Keep these at the bottom of the class
	//	so that we always know where to look for them.
	//
	//////////////////////////////////////////////////

	function takeHit (Attack $attack)
	{
		// Oosenupt - potential problematic if you have takeHit behaviours mitigating some of the damage.
		update_playerHp($this->hp - $attack->damage);

		$this->damageGear('a_eqp_apparel');

		parent::takeHit	($attack);
	}

	function strike(Attack $attack)
	{
		$this->damageGear('a_eqp_weapon');

		parent::strike($attack);
	}

	function deflect(Attack $attack)
	{
		$this->damageGear('a_eqp_shield');

		parent::deflect($attack);
	}

	function death (Attack $attack)
	{
		global $view;

//		$view->setOverlay('#f00', 0.4);

		parent::death($attack);

		$this->alterHp(floor($this->__get('HP_MAX') / 3));

		$respawnPoints = [
			[100,	93],
			[100,	107],
			[93,	100],
			[107,	100],
		];

		$chosenPoint = $respawnPoints[array_rand($respawnPoints)];

		$this->move($chosenPoint[0], $chosenPoint[1], MAP_DS_GRUBREGION);
		$view->forceUpdate = true;
	}

	function kill(Attack $attack)
	{
		parent::kill($attack);

		$levelBefore = $this->level;
		$this->alterXp($attack->target->experience * ($attack->target->level / $this->level));
		if ($this->level > $levelBefore) $attack->leveled = true;
	}

	public function __debugInfo()
	{
		return parent::__debugInfo() + [
			'skills' => $this->skills,
			'passives' => $this->passives,
		];
	}

	public function onLoseItem(Item $item)
	{
		parent::onLoseItem($item);

		if ($this->engagement && $this->engagement instanceof NPC && isset($this->engagement->NPCIs['npci_sell']))
		{
			$this->engagement->NPCIs['npci_sell']->updatePanel($item);
		}
	}

	public function onGainItem(Item $item)
	{
		parent::onGainItem($item);

//		if ($this->engagement && $this->engagement instanceof NPC && isset($this->engagement->NPCIs['npci_sell']))
//		{
//			if (!isset($this->engagement->NPCIs['npci_sell']->mask) || $this->engagement->NPCIs['npci_sell']->mask->compare($item))
//			{
//				$this->engagement->NPCIs['npci_sell']->updatePanel($item);
//			}
//		}
	}
}

/*

$fallingSprite = new Sprite([
	[
		1 => new SpriteElement(null, '#c94', 'o'),
		3 => new SpriteElement(null, '#c94', '&deg;'),
		4 => new SpriteElement(null, '#c94', '&#x039b;'),
		5 => new SpriteElement(null, '#c94', '&deg;'),
	],
	[
		0 => new SpriteElement(null, '#c94', '&deg;'),
		1 => new SpriteElement(null, '#c94', 'o'),
		3 => new SpriteElement(null, '#c94', '7'),
		5 => new SpriteElement(null, '#c94', '&deg;'),
	],
	[
		0 => new SpriteElement(null, '#c94', '&#x221a;'),
		1 => new SpriteElement(null, '#c94', '&deg;'),
		3 => new SpriteElement(null, '#c94', '&deg;'),
		4 => new SpriteElement(null, '#c94', 'o'),
	],
	[
		1 => new SpriteElement(null, '#c94', 'V'),
		3 => new SpriteElement(null, '#c94', '&deg;'),
		4 => new SpriteElement(null, '#c94', 'o'),
		5 => new SpriteElement(null, '#c94', '&deg;'),
	],
	[
		1 => new SpriteElement(null, '#c94', '&deg;'),
		2 => new SpriteElement(null, '#c94', 'L'),
		4 => new SpriteElement(null, '#c94', 'o'),
		5 => new SpriteElement(null, '#c94', '&deg;'),
	],
	[
		0 => new SpriteElement(null, '#c94', '&deg;'),
		1 => new SpriteElement(null, '#c94', 'o'),
		4 => new SpriteElement(null, '#c94', '&deg'),
		5 => new SpriteElement(null, '#c94', '&#x0490;'),
	],
]);


*/

class Map
{
    public $mapName;
	public $level;
	public $id;
	public $MAP;

    public $mapPath;

	public $players;
	public $playerRegister = [];

	public $objectRegister = [];

	// The following two variables are set while the .mtl file is being processed.
	public $height;
	public $width;

    public $css;
    public $js;

	public $tileKeyJson;
	public $spriteKeyJson;

	// Tile stuff
	public $tiles;     // array of tiles
    public $tileKey;
    public $emptyTile;

	// Scenery stuff
    public $sceneryKey;
    public $scenery;	// array of scenery

	// Materials
	public $materials;

	// AsObject stuff
    public $objects;	// array of objects rebuilt with each frame

	// Effects
	public $effects;	// array of effects

    public $spriteKey			= [];
	public $spriteKeyIndexChars	= [];

	public $requirements = [];

	//\\//\\//\\//\\//\\//\\//\\//\\
	// Map properties
	//\\//\\//\\//\\//\\//\\//\\//\\

	public $minimapTop;
	public $minimapBottom;
	public $minimapLeft;
	public $minimapRight;

    public $viewHeight;
    public $viewWidth;

	public $overlayColour = '#000';
	public $overlayOpacity = 0;

	public $allowMiniMap	= true;

	public $isDark			= false;
	public $isIndoor		= false;
	public $isUnderground	= false;

	public $localCurrency;
    public $territory;
    public $continent;
    public $district;
    public $landOwner;
    public $landLord;
    public $landKing;
    public $landEmperor;

	static function mountPlayerMap ($force = false)
	{
		console_echo("=== MOUNTING PLAYER MAP ===", '#aaf');

		global $map;
		global $player;
		global $view;
		global $MAP_paths;

		// Do we even need a new map?
//		if (!$force && isset($map) && $map->mapPath === $player->map && $map->level === $player->level)
		if (!$force && isset($map) && $map->MAP === $player->MAP && $map->level === $player->level)
		{
			console_echo('Looks like you\'re in the right place; mounting of player map aborted.', '#fff');
			return;
		}

		// Alright, we're committed to changing now; put the current one into storage.
		if (isset($map))
		{
			console_echo("Putting old map into cache (id: <<#fff>>{$map->id}<>)", '#aaf');
			$_SESSION[$map->id] = serialize($map);
		}
		$map = null;

		$match = "map_{$player->MAP}_{$player->level}_";
		$length = strlen($match);

		foreach ($_SESSION as $key => $value)
		{
			if (substr($key, 0, $length) === $match)
			{
				console_echo("<<#afa>>{$key}<> matches the desired <<#ffa>>{$match}<>; let's take it.", '#fff');

				$map = unserialize($value);
			}
			else { console_echo("<<#fda>>{$key}<> does not match the desired <<#ffa>>{$match}<>.", '#fff'); }
		}

		if (!$map)
		{
			$map = new Map($player->MAP, $player->level);
		}

//		$map->playerRegister[$player->id] = &$player;
		$map->addObjects($player);

		$view = new View();
		$view->update();

		$player->sprite = $view->addClientSprite($player->sprite);
		$player->spriteSet[SPRI_DEFAULT] = $view->addClientSprite($player->sprite);

		$_SESSION[$map->id] = serialize($map);
		$_SESSION['view'] = $view;
		$_SESSION['mapId'] = $map->id;


		$player->onMapChange();
		update_jvsKeys();
	}

    function __construct ($MAP, $level = null)
    {
		global $rootPath;
		global $player;
		global $MAP_paths;

		console_echo("Constructing a map with MAP: <<#fff>>{$MAP}<>", '#afa');

		$GLOBALS['mapLevel']		= &$this->level;
		$GLOBALS['mapMaterials']	= &$this->materials;

		if (isset($MAP))
		{
			$this->MAP = $MAP;
			$mapPath = $MAP_paths[$MAP];
			$mapNameParts = explode('/', $mapPath);
			$this->mapName = end($mapNameParts);
			$this->mapPath = $mapPath;
			$this->level = isset($level) ? $level : 1;
		}
		else
		{
			if (isset($player))
			{
				$this->MAP = $player->MAP;
				$this->mapPath = $MAP_paths[$this->map];
				$this->level = $player->level;
			}
			else
			{
				console_echo('Player must be initialised before map can be created.');		//XXX
				DIE();
			}
		}

//		$this->id = 'map_' . strtolower($this->mapPath) . "_{$this->level}_" . id();
		$this->id = "map_{$this->MAP}_{$this->level}_" . id();

		console_echo("Opening {$mapPath} (level {$this->level})", '#fff');

		// Load the .map file.
		console_echo('<br>+-----+ Objects +-----+<br>', '#fff');		//XXX

		require("{$rootPath}engine/core/_commonMaterialArray.php");
		require("{$rootPath}content/maps/{$this->mapPath}.map");

		console_echo('<br>+-----+ Map properties +-----+<br>', '#fff');		//XXX
		$this->checkRequiredVars();

		if (!isset($this->tileKey))		DIE('Map cretion failed! TileKey missing or invalid.');
		if (!isset($this->sceneryKey))	DIE('Map cretion failed! SceneryKey missing or invalid.');
		if (!isset($this->objects))		DIE('Map cretion failed! Objects array missing or invalid.');

        if (empty($this->viewHeight)) $this->viewHeight = MAX_VIEW_SIZE;
        if (empty($this->viewWidth)) $this->viewWidth = MAX_VIEW_SIZE;

		console_echo('<br>+-----+ Processing map keys +-----+<br>', '#fff');		//XXX

		$this->spriteKeyIndexChars = str_split('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'); // The keys get all fucked up if you put numbers in here.
//		$keyChars = count($this->spriteKeyIndexChars) - 1;
		shuffle($this->spriteKeyIndexChars); //This will make the javascript more difficult to understand. Usually this is a bad thing but in this case it'll just keep our secrets secret.

        $this->processTileKey($this->tileKey);
        $this->processSceneryKey($this->sceneryKey);

		$this->processObjects($this->objects);

//		$this->buildSpriteKey();

		if (!$this->tiles)		$this->buildTileArrayFromFile();
		if (!$this->scenery)	$this->buildSceneryArrayFromFile();

        $this->buildJsonObjects();
        $this->buildCSS();


		console_echo('<br>+-----+ Map initialise complete +-----+<br>', '#fff');		//XXX
    }

	public function checkRequiredVars()
	{
		$requredVars = [
			'tileKey',
			'sceneryKey',
			'objects',
		];

		foreach($requredVars as $var)
		{
			if (!isset($this->$var))
			{
				console_echo("Required map variable \"{$var}\" is not set.", '#faa');		//XXX
				DIE();
			}
		}

		$output = false;
		foreach(get_object_vars($this) as $var => $val)
		{
			if ($var == 'viewHeight') $output = true;
			if ($output)
			{
				if (is_bool($val))
					$val = ($val ? 'true' : 'false');
				if (!is_null($this->$var))		//XXX
				{		//XXX
					console_echo("<span style=\"color:#afa;\">{$var}</span> is set to <span style=\"color:#aff;\">{$val}</span>",'#fff');		//XXX
				}		//XXX
				else		//XXX
				{		//XXX
					console_echo("<span style=\"color:#fda;\">{$var}</span> is not set.",'#fff');		//XXX
				}		//XXX

			}
		}
	}

	public function setProperties($settingsArray)
	{
		foreach($settingsArray as $setting => $value)
		{
			$this->$setting = $value;
			console_echo("\"$setting\" overridden to \"$value\"", '#fff');		//XXX
		}
	}

	public function processTileKey($tileKey)
	{
		$newTileKey = array();
//		$tileIndexChars = str_split('abcdefghijklmnopqrstuvwxyz');
		$tileIndexChars = str_split('aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ');
		$tileIndex = 0;
//		$spareKey = null;
		foreach ($tileKey as $tile)
		{
			if ($tileIndex >= count($tileIndexChars))
			{
				console_warning('Too many tiles! Maximum: ' . count($tileIndexChars));
				break;
			}

			if ($tile instanceof Tile)
			{

			$newTileKey[$tileIndexChars[$tileIndex]] = $tile;

			}
			// Having the tileIndex incremeenter outside the tile-checking if means
			// that nulls can be put into the tile key to remove unused tiles but
			// maintain tile order and position. Thsoe blank spaces can then be
			// used later for something else.
			$tileIndex ++;
		}

	    foreach ($newTileKey as $key => $tile)
		{
			$tile->key = $key;
		}

		$this->emptyTile = $newTileKey[$tileIndexChars[0]];

		$this->tileKey = $newTileKey;
	}

	public function processSceneryKey($sceneryKey)
	{
		$newSceneryKey = [];
		$sceneryIndexChars = str_split('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');
		$sceneryIndex = 0;
		foreach ($sceneryKey as $scenery)
		{
			if ($sceneryIndex >= count($sceneryIndexChars))
			{
				$count = count($sceneryIndexChars);
				console_warning('Too many scenery sprites! Maximum: ' . ($count * $count));
				break;
			}

			if ($scenery instanceof Scenery) $newSceneryKey[$sceneryIndexChars[$sceneryIndex]] = $scenery;
			$sceneryIndex++;

		}

		foreach ($newSceneryKey as $key => &$scenery)
		{
			$scenery->key = $key;
			$scenery->sprite = $this->prepareSprite($scenery->sprite);
		}

		$this->sceneryKey = $newSceneryKey;
	}

	/**
	 * Assigns a single letter key to each sprite used in the map and embeds the
	 * key in the sprite object. We should never have to worry about what sprite
	 * gets what key as everything that uses or references these keys are all
	 * auto-generated.
	 *
	 * @param $spriteKey An array of all the sprites used. This should be passed in from the .map file.
	 */
	public function buildSpriteKey()
	{
		$newSpriteKey = array();
		$this->spriteKeyIndexChars = str_split('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'); // The keys get all fucked up if you put numbers in here.
		$keyChars = count($this->spriteKeyIndexChars) - 1;
		shuffle($this->spriteKeyIndexChars); //This will make the javascript more difficult to understand. Usually this is a bad thing but in this case it'll just keep our secrets secret.

		$index1 = 0;
		$index2 = 0;

		foreach($this->spriteKey as $key => $sprite)
		{
			$key = $this->spriteKeyIndexChars[$index1] . $this->spriteKeyIndexChars[$index2];

			console_echo("{$key} <<#fff>>=><> " . console_sprite($sprite), '#afa');

			$newSpriteKey[$key] = $sprite;
			$index2 ++;

			if ($index2 > $keyChars)
			{
				$index2 = 0;
				$index1 ++;
			}
		}

		$totalSprites = $keyChars * $keyChars;			//XXX
		console_echo(count($this->spriteKey) . " of {$totalSprites} sprites used in {$this->mapPath}.",'#faf');		//XXX

		foreach ($newSpriteKey as $key => $sprite)
		{
			if (!($sprite instanceof Sprite))
			{
				unset($newSpriteKey[$key]);
				console_echo('Non-sprite passed into the sprite key.', '#faa');		//XXX
				continue;
			}
			$sprite->key = $key;
		}

		$this->spriteKey = $newSpriteKey;
	}

	public function processObjects($objects)
	{
		$newObjectKey = [];
        $count = 0;
		foreach ($objects as $coOrds => $object)
        {
			list($n_offset, $w_offset) = explode(':', $coOrds);

			if (!is_numeric($n_offset) || !is_numeric($w_offset))
			{
				console_echo("<<#fff>>{$object->name}<> has dodgy coordinates and is being discarded.", '#faa');
				continue;
			}

			$object->n_offset = $n_offset;
			$object->w_offset = $w_offset;

			$newObjectKey[$object->n_offset][$object->w_offset][$object->layer] = $object;

			$object->sprite = $this->prepareSprite($object->sprite);
			foreach ($object->spriteSet as $key => $sprite)
			{
				$object->spriteSet[$key] = $this->prepareSprite($sprite);
			}

			if ($object->constituents)
			{
				foreach ($object->constituents as $c_n_offset => &$constituents)
				{
					foreach ($constituents as $c_w_offset => &$constituent)
					{
						$constituent->owner = $object;
						$constituent->sprite = $this->prepareSprite($constituent->sprite);
						console_echo('constituent sprite: ' . console_sprite($constituent->sprite));
						foreach ($constituent->spriteSet as $key => $sprite)
						{
							$constituent->spriteSet[$key] = $this->prepareSprite($sprite);
							console_echo('constituent set sprite: ' . console_sprite($sprite));
						}

						$newObjectKey[$n_offset + $c_n_offset][ $w_offset + $c_w_offset][$object->layer] = $constituent;
					}
				}
//				$object->constituentPlace();
			}

			foreach ($object->behaviours as $behaviours)
			{
				foreach ($behaviours as &$behaviour)
				{
					foreach ($behaviour->spriteSet as $key => $sprite)
					{
						$behaviour->spriteSet[$key] = $this->prepareSprite($sprite);
					}
				}
			}

			$this->objectRegister[$object->id] = &$object;

            $count ++;
        }
		$this->objects = $newObjectKey;
        console_echo("Objects processed:{$count}.", '#fff');		//XXX
	}

	public function prepareSprite($sprite)
	{
//		if (!in_array($sprite, $this->spriteKey)) $this->spriteKey[] = $sprite;
//		else
//		{
//			$existingDup = $this->spriteKey[array_search($sprite, $this->spriteKey)];
//			$sprite = $existingDup;
//		}

		foreach ($this->spriteKey as $key => $existingSprite)
		{
			if ($sprite->equals($existingSprite))
			{
				return $existingSprite;
			}
		}

		$spriteKeyIndexChars = $this->spriteKeyIndexChars;
		$charsCount = count($spriteKeyIndexChars);
		$totalSprites = count($this->spriteKey) + 1; // Plus one for this sprite

		$key = $this->spriteKeyIndexChars[floor($totalSprites / $charsCount)] . $spriteKeyIndexChars[$totalSprites % $charsCount];

		$sprite->key = $key;

		$this->spriteKey[$key] = $sprite;

		return $sprite;
	}

	public function buildTileArrayFromFile()
	{
		console_echo("Loading map tile layer from {$this->mapPath}.mtl", '#fff');		//XXX

		$height = 0;
		$width = 0;

        $tileFileString = file_get_contents("{$GLOBALS['rootPath']}content/maps/{$this->mapPath}.mtl");
        $tileRowStringArray = explode(LINE_BREAK, $tileFileString);

        $count = 0;
        foreach($tileRowStringArray as $tileRowString)
        {
            $tileRow = array();
            for($index = 0; $index < strlen($tileRowString); $index++)
            {
                if ($tileRowString[$index] != ' ')
                {
                    if (isset($this->tileKey[$tileRowString[$index]]))
                    {
                        $tileRow[$index] = $this->tileKey[$tileRowString[$index]];
						if ($index > $width) $width = $index;
                        $count ++;
                    }
                    else
                        $tileRow[$index] = $this->emptyTile;
                }
            }
            $this->tiles[] = $tileRow;
			$height ++;
        }

		$this->height = $height;
		$this->width = $width;
		console_echo("Map height: {$height}", '#fff');
		console_echo("Map width: {$width}", '#fff');
        console_echo("Tiles processed:{$count}.", '#fff');		//XXX
	}

	public function buildSceneryArrayFromFile()
	{
		console_echo("Loading map scenery layer from {$this->mapPath}.msl", '#fff');		//XXX
        $sceneryFileString = file_get_contents("{$GLOBALS['rootPath']}content/maps/{$this->mapPath}.msl");
        $sceneryRowStringArray = explode(LINE_BREAK, $sceneryFileString);

        $count = 0;
        foreach($sceneryRowStringArray as $sceneryRowString)
        {
            $sceneryRow = array();
            for($index = 0; $index < strlen($sceneryRowString); $index++)
            {
                if ($sceneryRowString[$index] != ' ')
                {
                    if (isset($this->sceneryKey[$sceneryRowString[$index]]))
                    {
                        $sceneryRow[$index] = $this->sceneryKey[$sceneryRowString[$index]];
                        $count ++;
                    }
                    else
                        $sceneryRow[$index] = null;
                }
            }
            $this->scenery[] = $sceneryRow;
        }
        console_echo("Scenery processed:{$count}.", '#fff');		//XXX
	}

	// This was a nice idea but I don't think it'll be any use where we're going.
	public function getMaterialsByType()
	{
		$acceptedTypes = func_get_args();
		$returnMaterials = [];

		foreach ($this->materials as $material)
		{
			foreach($acceptedTypes as $type)
			{
				if (is_a($material, $type))
				{
					$returnMaterials[] = $material;
					break;
				}
			}
		}
		return $returnMaterials;
	}

    public function buildCSS()
    {
        foreach($this->tileKey as $tile)
        {
            $this->css .= $tile->getCSS();
        }
    }

    public function buildJsonObjects()
    {
		$jsonTiles = [];
		foreach($this->tileKey as $tile)
        {
            $jsonTiles[$tile->key] = $tile->jsonObject;
        }
		$this->tileKeyJson = $jsonTiles;


//		$spr_notFound = new Sprite([
//			new SpriteElement('#0f0', '#f0f', '&#x2580;'),
//			new SpriteElement('#0f0', '#f0f', '&#x2584;'),
//			new SpriteElement('#0f0', '#f0f', '&#x2580;'),
//			new SpriteElement('#0f0', '#f0f', '&#x2580;'),
//			new SpriteElement('#0f0', '#f0f', '&#x2584;'),
//			new SpriteElement('#0f0', '#f0f', '&#x2580;'),
//		]);

		$spr_notFound = new Sprite([
			new SpriteElement('#000', '#f00', 'E'),
			new SpriteElement('#000', '#f00', 'R'),
			new SpriteElement('#000', '#f00', 'R'),
			new SpriteElement('#000', '#f00', 'O'),
			new SpriteElement('#000', '#f00', 'R'),
			new SpriteElement('#000', '#f00', '!'),
		]);

		$jsonSprites = [];
        foreach($this->spriteKey as $sprite)
        {
//            $jsonSprites[$sprite->key] = $sprite->jsonObject;
            $jsonSprites[$sprite->key] = $sprite->getJsonObject();
        }

//		$jsonSprites['player'] = $GLOBALS['player']->sprite->getJsonObject();
		$jsonSprites['notFound'] = $spr_notFound->getJsonObject();

		$this->spriteKeyJson = $jsonSprites;
    }

    function getTileByLocation($n_offset, $w_offset)
    {
        if (isset($this->tiles[$n_offset][$w_offset])) return $this->tiles[$n_offset][$w_offset];
        else return $this->emptyTile;
    }

	/**
	 * Collides an object with anything in a specified location. The object
	 * attempting to enter will collide with the tile, then the sceneery then
	 * the mapObject. IF any of these things prevent the sending object from
	 * entering the tile, <b>false</b> will be returned and entry denied.
	 * <br/>Collision events will be run at each of the three testing stages.
	 *
	 * @param AsObject $instigator The object attempting the enter the tile.
	 * @param integer $n_offset The north offset of the tile being collided with.
	 * @param integer $w_offset The west offset of the tile being collided with.
	 * @return boolean <b>true</b> if the sender is allowed to enter the tile, <b>false</b> if the sender is not allowed to enter the tile.
	 */
    function collideByLocation($instigator, $n_offset, $w_offset)
    {
		global $player;
		global $DIR_opposites;

		$DIR = 0;

		if ($instigator instanceof ObjectConstituent)
		{
			$instigator = $instigator->owner;
		}
		elseif ($instigator->n_offset === $n_offset && $instigator->w_offset === $w_offset)
		{
			console_echo("{$instigator->name} doesn't even want to move!");
			return false;
		}

		if ($instigator->n_offset !== $n_offset)
		{
			$DIR = $n_offset < $instigator->n_offset ? DIR_NORTH : DIR_SOUTH;
		}
		else
		{
			$DIR = $w_offset < $instigator->w_offset ? DIR_WEST : DIR_EAST;
		}

//		$dirnames = [DIR_NORTH => 'north', DIR_SOUTH => 'south', DIR_EAST => 'east', DIR_WEST => 'west'];//XXX
//		console_echo("$instigator->name <<#aaa>>-=><> {$dirnames[$DIR]}", ($instigator === $player ? '#aaa':null));
//        $canMove = $this->getTileByLocation($n_offset, $w_offset)->collide();

		// Can we move into the tile?
        $canMove = in_array($this->getTileByLocation($n_offset, $w_offset)->TPL, $instigator->TPL_passables);

        if // Can we enter the scenery in that direction? Does it even care?
		(
			isset($this->scenery[$n_offset][$w_offset])
			&& isset($this->scenery[$n_offset][$w_offset]->TPL_borders[$DIR_opposites[$DIR]])
		)
        {
            $canMove = in_array($this->scenery[$n_offset][$w_offset]->TPL_borders[$DIR_opposites[$DIR]], $instigator->TPL_passables);
			if (!$canMove) return false;
        }

		if // Can we exit the current scenery in that direction? Does it even care?
		(
			isset($this->scenery[$instigator->n_offset][$instigator->w_offset])
			&& isset($this->scenery[$instigator->n_offset][$instigator->w_offset]->TPL_borders[$DIR])
		)
		{
//			$canMove = $canMove && $this->scenery[$instigator->n_offset][$instigator->w_offset]->canExit($DIR);
			$canMove = $canMove && in_array($this->scenery[$instigator->n_offset][$instigator->w_offset]->TPL_borders[$DIR], $instigator->TPL_passables);
			if (!$canMove) return false;
		}


        if (!empty($this->objects[$n_offset][$w_offset]))
        {
			$object = end($this->objects[$n_offset][$w_offset]);
			if ($object instanceof ObjectConstituent) $object = $object->owner;

			// Weirdly, this only applies when an object's constituent's new location
			// is being tested and is colliding with itself.
			if ($object !== $instigator)
				$canMove = $instigator->collide($object, $DIR) && $canMove;
        }
		if (!$instigator instanceof Player && $n_offset == $player->n_offset && $w_offset == $player->w_offset)
		{
			$canMove = $instigator->collide($player, $DIR) && $canMove;
		}

		if (!($instigator instanceof Player) && !isset($this->objects[$instigator->n_offset][$instigator->w_offset][$instigator->layer])) return false;

        return $canMove;
    }

	public function runIdleActions()
	{
		global $view;
		global $player;

		$fastestObject = 1;

		foreach ($player->behaviours as $behaviour)
		{
			$behaviour = end($behaviour);

			if ($behaviour->can('onIdle'))
			{
				$behaviour->onIdle();
				$behaviour->triggercooldown();
			}

			if ($behaviour->onIdle === true && $behaviour->cooldown <= $fastestObject && $behaviour->cooldown >= MIN_COOLDOWN)
			{
				$fastestObject = $behaviour->cooldown;
			}
		}

		for($renderedTileRow = $view->actionTopOffset; $renderedTileRow <= $view->actionBottomOffset; $renderedTileRow++)
		{
			for($renderedTileColumn = $view->actionLeftOffset; $renderedTileColumn <= $view->actionRightOffset; $renderedTileColumn ++)
            {
				if (isset($this->objects[$renderedTileRow][$renderedTileColumn]))
				{
					foreach ($this->objects[$renderedTileRow][$renderedTileColumn] as $object)
					{
						if ($object instanceof ObjectConstituent) continue;

						if ($object instanceof Dude)
						{
							if ($object->nextStatusCheck <= $_SERVER['REQUEST_TIME_FLOAT'])
							{
								$object->checkStatuses();
							}
						}

						foreach ($object->behaviours as $behaviour)
						{

							$behaviour = end($behaviour);

//							if (!($behaviour instanceof Behaviour))
//							{
//								console_echo($object->name, '#0ff');
//								foreach($object->behaviours as $bhv)
//								{
//									foreach ($bhv as $b)
//									console_echo('## ' . get_class($b), '#f00');
//								}
//
//								continue;
//							}

							if ($behaviour->can(TRG_IDLE))
							{
								$behaviour->onIdle();
								$behaviour->triggercooldown();
							}

							if ($behaviour->onIdle === true && $behaviour->cooldown <= $fastestObject && $behaviour->cooldown >= MIN_COOLDOWN)
							{
								$fastestObject = $behaviour->cooldown;
							}
						}
						if ($object instanceof Dude) $object->regenerate();
						$object->lastUpdated = $_SERVER['REQUEST_TIME_FLOAT'];
					}
				}
			}
		}

//        $view->setRefreshRate($fastestObject >= 0.2 ? $fastestObject : 0.2);
        $view->refreshRate = ($fastestObject >= 0.2 ? $fastestObject : 0.2);
	}

	function addEffects()
	{
		foreach(func_get_args() as $arg)
		{
			if (is_array($arg))
			{
				foreach($arg as $effect)
				{
					$this->effects[$effect->n_offset][$effect->w_offset] = $effect;
				}
			}
			else
			{
				$this->effects[$arg->n_offset][$arg->w_offset] = $arg;
			}
		}
	}

	function addObjects()
	{
		foreach(func_get_args() as $arg)
		{
			if (is_array($arg))
			{
				foreach($arg as $object)
				{
					$this->objects[$object->n_offset][$object->w_offset][$object->layer] = $object;
					$this->objectRegister[$object->id] = &$object;
				}
			}
			else
			{
				$this->objects[$arg->n_offset][$arg->w_offset][$arg->layer] = $arg;
				$this->objectRegister[$arg->id] = &$arg;
			}
		}
	}

	/**
	 * Moves an object to a new location on the map (if allowed).
	 * @param AsObject $object The object to be moved
	 * @param type $n_offset The new n_offset for the object
	 * @param type $w_offset The new w_offset for the object
	 * @param type $force Allows the caller to over-ride usual collision rules (cannot over-ride the object's "stationary" boolean)
	 * @return boolean <b>TRUE</b> if the object moves, <b>FALSE</b> if it can't move
	 */
	function moveObject(AsObject $object, $n_offset, $w_offset, $force = false)
    {
		if ($object->stationary) return false;

		if (!$force)
		{
			if (!$this->collideByLocation($object, $n_offset, $w_offset)) return false;
			if ($object->constituents && !$object->constituentCollide($n_offset, $w_offset)) return false;
		}

		if ($object->constituents) $object->constituentClear();

		$n_offset_old = $object->n_offset;
		$w_offset_old = $object->w_offset;

		$object->onMove($n_offset, $w_offset);

		$object->n_offset = $n_offset;
		$object->w_offset = $w_offset;

		$this->objects[$n_offset][$w_offset][$object->layer] = $object;
		unset($this->objects[$n_offset_old][$w_offset_old][$object->layer]);

		if ($object->constituents) $object->constituentPlace();

		return true;
    }

	function resortObjectLayers($n_offset, $w_offset)
	{
		$objects = &$this->objects[$n_offset][$w_offset];
		if (is_array($objects))
		{
			foreach($objects as $layer => $object)
			{
				if($object->layer != $layer)
				{
					$objects[$object->layer] = $object;
					unset($objects[$layer]);
				}
			}
		}
		ksort($objects);
	}

//    function destroyObject($n_offset, $w_offset, $layer)
//    {
//		unset($this->objectRegister[$this->objects[$n_offset][$w_offset][$layer]->id]);
//        unset($this->objects[$n_offset][$w_offset][$layer]);
//    }

    function destroyObject(AsObject $object)
    {

		unset($this->objectRegister[$object->id]);
        unset($this->objects[$object->n_offset][$object->w_offset][$object->layer]);
    }

	function replaceObject($n_offset, $w_offset, $layer, AsObject $newObject)
	{
//		unset($this->objects[$n_offset][$w_offset][$layer]);
//		$this->objects[$n_offset][$w_offset][$layer]->destroy();
		$this->destroyObject($this->objects[$n_offset][$w_offset][$layer]);

		$newObject->n_offset = $n_offset;
		$newObject->w_offset = $w_offset;

		$this->addObjects($newObject);

//		$this->objects[$n_offset][$w_offset][$newObject->layer] = $newObject;
//		$this->objects[$n_offset][$w_offset][$newObject->layer]->n_offset = $n_offset;
//		$this->objects[$n_offset][$w_offset][$newObject->layer]->w_offset = $w_offset;
	}

	public function getSpriteIndex(Sprite $sprite)
	{
		return array_search($sprite, $this->spriteKey);
	}

	public function getObjectsInArea($n_offset_1, $w_offset_1, $n_offset_2, $w_offset_2)
	{
		$top = min($n_offset_1, $n_offset_2);
		$bottom = max($n_offset_1, $n_offset_2);
		$left = min($w_offset_1, $w_offset_2);
		$right = max($w_offset_1, $w_offset_2);

		$objects = [];

		for ($r = $top; $r <= $bottom; $r ++)
		{
			for ($c = $left; $c <= $right; $c++)
			{
				if (isset($this->objects[$r][$c]))
				{
					foreach ($this->objects[$r][$c] as &$object)
					{
						$objects[] = $object;
					}
				}
			}
		}

		return $objects;
	}

	public function getMiniMap($n_offset_1 = null, $w_offset_1 = null, $n_offset_2 = null, $w_offset_2 = null, $showTiles = true, $showSprites = true, $showObjects = true)
	{
		$visibleObjectLayers =
		[
			LAYER_DOOR_CLOSED,
			LAYER_DOOR_OPEN,
			LAYER_PORTAL,
			LAYER_SIGN,
		];

		if (isset($n_offset_1, $w_offset_1, $n_offset_2, $w_offset_2))
		{
			$topEdge = min($n_offset_1, $n_offset_2);
			$bottomEdge = max($n_offset_1, $n_offset_2);
			$leftEdge = min($w_offset_1, $w_offset_2);
			$rightEdge = max($w_offset_1, $w_offset_2);
		}
		else
		{
			$topEdge = 0;
			$bottomEdge = getLargestIndex($this->tiles);
			$leftEdge = 0;
			$rightEdge = 0;

			foreach ($this->tiles as $row)
			{
				$rowWidth = getLargestIndex($row);
				if ($rowWidth > $rightEdge)
					$rightEdge = $rowWidth;
			}

			$margin = 10;

			$topEdge -= $margin;
			$bottomEdge += $margin;
			$leftEdge -= $margin;
			$rightEdge += $margin;
		}

		$emptyColour = $showTiles ? $this->emptyTile->bg : '#000';
		$lastTop = null;
		$lastBottom = null;

		$mapString = '';

		for ($r = $topEdge; $r <= $bottomEdge; $r+=2)
		{
			for ($c = $leftEdge; $c <= $rightEdge; $c++)
			{
				if ($showTiles)
				{
					$top = (isset($this->tiles[$r][$c])) ? $this->tiles[$r][$c]->bg : $emptyColour;
					$bottom = (isset($this->tiles[$r+1][$c])) ? $this->tiles[$r+1][$c]->bg : $emptyColour;
				}
		//*
				if ($showSprites)
				{
					if (!$showTiles)
					{
						$top = $emptyColour;
						$bottom = $emptyColour;
					}

					$top = (isset($this->scenery[$r][$c]) && $this->scenery[$r][$c]->minimap) ? $this->scenery[$r][$c]->sprite->getMainColour() : $top;
					$bottom = (isset($this->scenery[$r+1][$c]) && $this->scenery[$r+1][$c]->minimap) ? $this->scenery[$r+1][$c]->sprite->getMainColour() : $bottom;
				}

				if ($showObjects)
				{
					foreach($visibleObjectLayers as $l)
					{
						if (isset($this->objects[$r][$c][$l]) && !empty($this->objects[$r][$c][$l]->sprite->frames[0]))
						{
							$top = $this->objects[$r][$c][$l]->sprite->getMainColour();
						}
						if (isset($this->objects[$r+1][$c][$l]) && !empty($this->objects[$r+1][$c][$l]->sprite->frames[0]))
						{
							$bottom = $this->objects[$r+1][$c][$l]->sprite->getMainColour();
						}
//						$top = (isset($this->objects[$r][$c][$l]))		? $this->objects[$r][$c][$l]->sprite->getMainColour()	: $top;
//						$bottom = (isset($this->objects[$r+1][$c][$l]))	? $this->objects[$r+1][$c][$l]->sprite->getMainColour()	: $bottom;
					}
				}

		/*/
				$top = (isset($map->scenery[$r][$c]) ) ? $map->scenery[$r][$c]->sprite->getMainColour() : $top;
				$bottom = (isset($map->scenery[$r+1][$c]) ) ? $map->scenery[$r+1][$c]->sprite->getMainColour() : $bottom;
		//*/

				if ($r +1 > $bottomEdge) $bottom = '#000';

				if ($top !== $lastTop || $bottom !== $lastBottom)
				{
					$lastTop = $top;
					$lastBottom = $bottom;

					$mapString .= (isset($lastTop) ? '</span>' : '') . "<span style=\"background-color:{$top};" . ($top === $bottom ? '' : "color:{$bottom};") . '">';
				}

				$mapString .= ($top === $bottom ? '&nbsp;' : '&#x2584');
			}
			$mapString .= '<br>';
		}

		return $mapString;
	}

	public function renderWholeMap()
	{
		$visibleObjectLayers =
		[
			LAYER_DOOR_CLOSED,
			LAYER_DOOR_OPEN,
			LAYER_PORTAL,
			LAYER_SIGN,
			LAYER_CHEST,
			LAYER_PUSHBLOCK,
		];

		$topEdge = 0;
		$bottomEdge = getLargestIndex($this->tiles);
		$leftEdge = 0;
		$rightEdge = 0;

		foreach ($this->tiles as $row)
		{
			$rowWidth = getLargestIndex($row);
			if ($rowWidth > $rightEdge)
				$rightEdge = $rowWidth;
		}

		$margin = 3;

		$topEdge -= $margin;
		$bottomEdge += $margin;
		$leftEdge -= $margin;
		$rightEdge += $margin;

		$mapString = '<span>';

		$lastTile = null;

		for ($r = $topEdge; $r <= $bottomEdge; $r++)
		{
			for ($rt = 0; $rt <= 1; $rt ++)
			{
				for ($c = $leftEdge; $c <= $rightEdge; $c++)
				{
					$sprite = null;
					$tile = (isset($this->tiles[$r][$c])) ? $this->tiles[$r][$c] : $this->emptyTile;

					foreach ($visibleObjectLayers as $layer)
					{
						if (isset($this->objects[$r][$c][$layer]))
						{
							$sprite = $this->objects[$r][$c][$layer]->sprite;
							break;
						}
					}
					if (!$sprite) $sprite = (isset($this->scenery[$r][$c])) ? $this->scenery[$r][$c]->sprite : null;

					if ($tile !== $lastTile)
					{
						$lastTile = $tile;
						$mapString .= "</span><span class=\"{$tile->key}\">";
					}

					$offset = $rt === 0 ? 0 : 3;


					for ($e = $offset; $e <= 2 + $offset; $e++)  // ELEMENT
					{
						if (isset($sprite) && isset($sprite->frames[0][$e]))
						{
							$mapString .= $sprite->frames[0][$e];
						}
						else
						{
							if ($tile->static)
							{
								$mapString .= $tile->chars[$e];
							}
							else
							{
								$te = mt_rand(0, ($tile->scatterDilution));
								$mapString .= isset($tile->chars[$te]) ? $tile->chars[$te] : $tile->chars[0];
							}
						}
					}
				}

				$mapString .= '<br>';
			}
		}

		$mapString .= '</span>';

		return $mapString;
	}
}

class PlayerRegistration
{
	public $n_offset;
	public $w_offset;

	public function __construct()
	{
		global $player;

		$this->n_offset = &$player->n_offset;
		$this->w_offset = &$player->w_offset;
	}
}

class View
{
	public $playerId;
	public $mapId;

	// No point setting these two, they get re-written.
	public $height;
	public $width;

	public $baseHeight;
	public $baseWidth;

	public $lightSources = [];

	public $sizeAlteration;

	public $topOffset;
    public $leftOffset;
    public $rightOffset;
    public $bottomOffset;

	public $actionTopOffset;
    public $actionLeftOffset;
    public $actionRightOffset;
    public $actionBottomOffset;

	public $refreshRate = 1;
//	public $refreshRateSet = false;

	public $defaultOverlayColour;
	public $defaultOverlayOpacity;

	public $overlayOpacity;
	public $overlayColour;

	public $tileString;
	public $spriteString;

	public $forceUpdate;

	public $clientSpriteRegister = [];
	public $clientSpriteJson = [];

	public $editorHeight = 45;
	public $editorWidth = 45;

	function __construct()
	{
		global $map;
		global $player;

		$this->playerId	= $player->id;
		$this->mapId	= $map->id;

		$this->baseHeight	= $map->viewHeight;
		$this->baseWidth	= $map->viewWidth;

		// Editor player doesn't get affected by lighting so gtfo.
		if ($player instanceof EditorPlayer2) return;

		$this->defaultOverlayColour		= $map->overlayColour;
		$this->defaultOverlayOpacity	= $map->overlayOpacity;

		$this->overlayColour = $this->defaultOverlayColour;
		$this->overlayOpacity = $this->defaultOverlayOpacity;

		update_overlay($this->overlayColour, $this->overlayOpacity);
	}

	function update()
    {
		global $player;
		global $map;

		$tileString		= null;
		$spriteString	= null;

        $this->height = $this->baseHeight + ($this->sizeAlteration * 2);
        $this->width = $this->baseWidth + ($this->sizeAlteration * 2);

		if (!($player instanceof EditorPlayer || $player instanceof EditorPlayer2)) // EDITOR LINE
		{								// EDITOR LINE
		// Not too big
		if ($this->height > MAX_VIEW_SIZE) $this->height = MAX_VIEW_SIZE;
		if ($this->width > MAX_VIEW_SIZE) $this->width = MAX_VIEW_SIZE;


		// Not too small
		if ($this->height < MIN_VIEW_SIZE) $this->height = MIN_VIEW_SIZE;
		if ($this->width < MIN_VIEW_SIZE) $this->width = MIN_VIEW_SIZE;

		// Make sure it's odd so we can have a center point for the player
        if ($this->height % 2 != 1) $this->height ++;
        if ($this->width % 2 != 1) $this->width ++;

		}											// EDITOR LINE
		else										// EDITOR LINE
		{											// EDITOR LINE
			$this->height = $this->editorHeight;	// EDITOR LINE
			$this->width = $this->editorWidth;		// EDITOR LINE
		}											// EDITOR LINE

		// Set out area for view
        $this->topOffset = $player->n_offset - floor($this->height / 2);
        $this->leftOffset = $player->w_offset - floor($this->width / 2);

        $this->rightOffset = $player->w_offset + floor($this->width / 2);
        $this->bottomOffset = $player->n_offset + floor($this->height / 2);

		// Set out area for idle actions to be triggered
		$this->actionTopOffset = $player->n_offset - ACTION_AREA_RADIUS;
        $this->actionLeftOffset = $player->w_offset - ACTION_AREA_RADIUS;

        $this->actionRightOffset = $player->w_offset + ACTION_AREA_RADIUS;
        $this->actionBottomOffset = $player->n_offset + ACTION_AREA_RADIUS;

		// Run those idle actions
		if (!($player instanceof EditorPlayer || $player instanceof EditorPlayer2)) // EDITOR LINE //XXX
			$map->runIdleActions();

        for($renderedTileRow = $this->topOffset; $renderedTileRow <= $this->bottomOffset; $renderedTileRow++)
        {
            for($renderedTileColumn = $this->leftOffset; $renderedTileColumn <= $this->rightOffset; $renderedTileColumn ++)
            {
				// Get the tile
				if (isset($map->tiles[$renderedTileRow][$renderedTileColumn]))
				{
					$tileString .= $map->tiles[$renderedTileRow][$renderedTileColumn]->key;
				}
				else
				{
					$tileString .= $map->emptyTile->key;
				}

				$nextSpriteKey = null;
				$effectLayer = 0;

				if (isset($map->effects[$renderedTileRow][$renderedTileColumn]))
				{
					$nextSpriteKey = $map->effects[$renderedTileRow][$renderedTileColumn]->sprite->key;
					$effectLayer = $map->effects[$renderedTileRow][$renderedTileColumn]->layer;
					if (--$map->effects[$renderedTileRow][$renderedTileColumn]->frames <= 0)
					{
						$map->effects[$renderedTileRow][$renderedTileColumn]->delete();
					}
				}

				// Get the sprite (if appropriate)
				if (isset($map->objects[$renderedTileRow][$renderedTileColumn]))
                {
					ksort($map->objects[$renderedTileRow][$renderedTileColumn]);
					$object = end($map->objects[$renderedTileRow][$renderedTileColumn]);

					if ($object instanceof AsObject || $object instanceof ObjectConstituent)
					{
						if (!$object->invisible && $object->layer >= $effectLayer) $nextSpriteKey = $object->sprite->key;
					}
					else
					{
//						console_var_dump($object);
						unset($map->objects[$renderedTileRow][$renderedTileColumn]);
					}
                } // No object on this tile. Do we have some scenery?

				if (!$nextSpriteKey && isset($map->scenery[$renderedTileRow][$renderedTileColumn]))
				{
					$nextSpriteKey = $map->scenery[$renderedTileRow][$renderedTileColumn]->sprite->key;
				} // No scenery either. Oh well, just the tile then.

				$spriteString .= $nextSpriteKey ? $nextSpriteKey : '-';
            }
        }

		$this->tileString		= $tileString;
		$this->spriteString		= $spriteString;

		return true;
    }

	public function setOverlay($colour = null, $opacity = 0)
	{
		$this->defaultOverlayColourAlteration = $colour;

		if (!$this->defaultOverlayOpacityAlteration) $this->defaultOverlayOpacityAlteration = 0;
		$this->defaultOverlayOpacityAlteration += $opacity;

		$colour = $this->defaultOverlayColourAlteration !== null ? $this->defaultOverlayColourAlteration : $this->defaultOverlayColour;
		$opacity = $opacity >= 0 ? $opacity : $this->defaultOverlayOpacity + $opacity;
		update_overlay($colour, $opacity);
	}

	public function resetOverlay($updateClient = true)
	{
		$this->defaultOverlayColourAlteration = null;
		$this->defaultOverlayOpacityAlteration = null;

		if ($updateClient) update_overlay($this->colour, $this->opacity);
	}

//	public function setRefreshRate($refreshRate)
//    {
//        if ($this->refreshRate == $refreshRate && $this->refreshRateSet) return;
//        $this->refreshRate = $refreshRate;
//		$this->refreshRateSet = true;
//        $refreshRate = $refreshRate * 1000;
//		update(UPD_REFRESHRATE, $refreshRate);
//    }

	public function addLightSource(lightSource $lightSource)
	{
		$this->lightSources[] = $lightSource;
		//console_var_dump($this->lightSources, '#afa');		//XXX
		$this->refreshLighting();
	}

	public function removeLightSource(lightSource $lightSource)
	{
		unset($this->lightSources[array_search($lightSource, $this->lightSources)]);
		//console_var_dump($this->lightSources, '#faf');		//XXX
		$this->refreshLighting();
	}

	public function refreshLighting()
	{
		$colour = $this->defaultOverlayColour;
		$distance = 0;
		$opacity = $this->defaultOverlayOpacity;

		foreach ($this->lightSources as $lightSource)
		{
			$calcutedOpacity = ($lightSource->absoluteOpacity ? $lightSource->opacity : $this->defaultOverlayOpacity - $lightSource->opacity);
			if ($calcutedOpacity <= $opacity)
			{
				$opacity = $calcutedOpacity;
				$colour = $lightSource->colour;
			}
			$distance += $lightSource->distance;
		}

		console_echo('Setting light to ' . console_swatch($colour) . " with opacity {$opacity}.");		//XXX

		$this->sizeAlteration = $distance;

		$this->overlayColour = $colour;
		$this->overlayOpacity = $opacity;

		update_overlay($colour, $opacity);
	}

	/**
	 *	This function keeps track of which sprites have been sent to the client
	 * and will send a sprite to the client then give it a key. If an identical
	 * sprite has already been sent, it will instead return that keyed version
	 * of that sprite for use in sprited objects.	 *
	 *
	 * @param Sprite $sprite - The sprite you wish to send to the client.
	 * @return Sprite - This sprite has a key and is ready to use.
	 */
	function addClientSprite(Sprite $sprite)
	{
		// First up, try to short-circut the whole function.
		if (isset($sprite->key)											&&
			isset($this->clientSpriteRegister[$sprite->key])			&&
			$this->clientSpriteRegister[$sprite->key]->equals($sprite)	)
			return $sprite;

		// See if we already have it.
		$checked = 0;
		foreach ($this->clientSpriteRegister as $clientSprite)
		{
			$checked++;
			if ($clientSprite->equals($sprite))
			{
				console_echo('Already had that sprite made.', '#aff', CNS_SPRITE);	//XXX
				console_echo("Found after <<#fff>>{$checked}<> checks.", '#aaf', CNS_SPRITE);
				console_echo($clientSprite->key . console_sprite($clientSprite) . ' == ' . $sprite->key . console_sprite($sprite), null, CNS_SPRITE);
				return $clientSprite;
			}
			//else console_echo($clientSprite->key . console_sprite($clientSprite) . ' != ' . $sprite->key . console_sprite($sprite));
		}

		// Sprite is not on the client side, get it a key from the map.
		global $map;
		$spriteKeyIndexChars = $map->spriteKeyIndexChars;
		$charsCount = count($spriteKeyIndexChars);

		$totalSprites = count($map->spriteKey) + count($this->clientSpriteRegister) + 1;

		console_echo("Total sprites = {$totalSprites}", '#faf', CNS_SPRITE);

		$key = $spriteKeyIndexChars[floor($totalSprites / $charsCount)] . $spriteKeyIndexChars[$totalSprites % $charsCount];

		$sprite->key = $key;

		console_echo("Made a new sprite with the key \"{$key}\".", '#faf', CNS_SPRITE);	//XXX
//		try
//		{
//			console_echo(console_sprite($sprite), null, CNS_SPRITE);
//		}
//		catch (Exception $ex)
//		{
			console_var_dump($sprite, '#faa', CNS_SPRITE);
//		}


		$this->clientSpriteRegister[$key] = $sprite;
//		$this->clientSpriteJson[$key] = $sprite->jsonObject;
		$this->clientSpriteJson[$key] = $sprite->getJsonObject();
		update_sprite($key, $sprite, false);
		return $sprite;
	}

	/**
	 *
	 * @global type $player
	 * @param type $n_offset
	 * @param type $w_offset
	 * @return type Array - 0 => n_offset, 1 => w_offset
	 */
	public function viewPosToMapPos ($n_offset, $w_offset = 0)
	{
		global $player;

		if (is_string($n_offset))
		{
			$coOrds = explode(',', $n_offset);
			$n_offset = $coOrds[0];
			$w_offset = $coOrds[1];
		}

		$n_offset = $n_offset + $player->n_offset - floor($this->width / 2);
		$w_offset = $w_offset + $player->w_offset - floor($this->height / 2);

		return [$n_offset, $w_offset];
	}
}

class lightSource
{
	public $distance;
	public $colour;
	public $opacity;
	public $absoluteOpacity;

	public function __construct($distance, $colour = null, $opacity = null, $absoluteOpacity = true)
	{
		$this->distance = $distance;
		$this->colour = $colour;
		$this->opacity = $opacity;
		$this->absoluteOpacity = $absoluteOpacity;
	}
}



class Item
{
	use BehaviourCapability;

	public $name			= null;
	public $id;						// Used only as ID on client side to prevent updating entire inventory every time something changes
	public $description		= null;

	public $quantity		= 1;
	public $level			= null;
	public $materials		= null;

	public $durability;
	public $durabilityMax;
	public $isBroken		= false;


	public $INV; // Should contain an INV_# constant. This is for special inventory slots.

	public $sprite			= null;
	public $spriteSet		= null;

	public $goldValue		= 0; // This is NOT the price; this is the item's base value without the added value of behaviours or stats.

	public $ICATs = [];

	public $owner;
	public $SKLS;

	public $cantLose		= false; // Items cannot be pulled while this is true.

	public $finished		= false;

	function __construct($name, $description, $spriteSet, $behaviours = null)
	{
		$this->name = $name;

		$this->description = $description;

		if ($spriteSet instanceof Sprite) $spriteSet = [$spriteSet];
		$this->spriteSet = $spriteSet;

//		if (isset($behaviours)) $this->behaviours = $behaviours;
	}

	function __clone()
	{
		$this->owner	= null;
		$this->SKLS		= null;
//		$this->id = uniqid() . mt_rand(0, 99999);
		$this->id = id(5);
		$this->behaviour__clone();
	}

	function finish()
	{
		if ($this->finished) return true;

		$this->fillGaps();
		$this->consolidate();
		$this->finished = true;
		$this->registerBehaviour();

		$this->id = id(5);

		$this->durability = $this->durabilityMax;

		return true;
	}

	protected function fillGaps()
	{
		if (!isset($this->level))
		{
			$this->level = isset($GLOBALS['mapLevel']) ? $GLOBALS['mapLevel'] : $GLOBALS['map']->level;
		}
	}

	protected function consolidate($problems = [])
	{
		$showName = isset($this->name) ? $this->name : 'something'; //XXX
		console_echo("Running item consolidator on {$showName}", null, CNS_ITEMS);

		// First made sure we have all that we need. If not, assign problems.
		if (!isset($this->name))		$problems[] = 'name missing';
		if (!isset($this->description))	$problems[] = 'description missing';
		if (!isset($this->spriteSet))	$problems[] = 'sprite set missing';

		// Make sure we don't have any problems.
		$this->problemCheck($problems);

		// Do stuff and set stuff and all that
		$this->name = ucwords($this->name);
		$this->sprite = $this->spriteSet[SPRI_DEFAULT];

//		$this->registerBehaviour();

		// We got here so things must be ok. Consolidate and return true.
		return empty($problems);
	}

	function problemCheck($problems)
	{
		if (!empty($problems))
		{
			$problems = implode(',', $problems);
			trigger_error("Couldn't consolidate item \"{$this->name}\"; {$problems}!", E_USER_ERROR);
		}
	}

	/**
	 * If you're running calculations on an item based on the stats stored in its
	 * materials, use this list of materials. It only returns one of each material
	 * present in the item unless it only has one material in which case it returns
	 * two of said material.
	 *
	 * @return Array of Material objects
	 */
	function getWorkingMaterials()
	{
		$workingMaterials = [];

		foreach ($this->materials as $material)
			if (!in_array($material, $workingMaterials))
				$workingMaterials[] = $material;

		if (empty($workingMaterials))
		{
			console_echo("{$this->name} hasn't got any materials but it's trying to apply materials mods. Look into that.", '#faa', CNS_ITEMS);
			return [];
		}

		// If the item has only one material, double its effectiveness.
		if (count($workingMaterials) === 1) $workingMaterials[] = $workingMaterials[0];

		return $workingMaterials;
	}

	public function inspect()
	{
		update_itemInfo($this);

		//////// CONSOLE ONLY //////////

		console_echo("{$this->name}'s hidden stats:", '#ffa', CNS_ITEMS);

		if (isset($this->DSs[DS_LUCK])) console_echo("Luck : {$this->DSs[DS_LUCK]}", '#aaf');
		if (isset($this->materials))									//XXX
		{																//XXX
			console_echo("{$this->name} is made of:", '#aaf', CNS_ITEMS);			//XXX
			foreach ($this->materials as $role => $material)			//XXX
			{															//XXX
				console_echo("{$role} - {$material->name}", '#aaf', CNS_ITEMS);	//XXX
			}															//XXX
		}																//XXX
		console_echo('Gold value: '. $this->getPrice(CUR_GOLD), '#aaf', CNS_ITEMS);//XXX
	}

	public function useItem()
	{
		console_echo("Using {$this->name}", CNS_ITEMS);
		$this->onUse();
	}

	function delete($quantity = null)
	{
		$this->owner->inventory->pullItem($this, $quantity);
	}

	public function getPrice($CUR = null, $sa = null)
	{
		$goldValue = $this->goldValue;
//		$goldValue = isset($this->PROPs[PROP_VALUE]) ? $this->PROPs[PROP_VALUE] : 0;

		console_echo("Price of {$this->name} = {$goldValue}", '#fda', CNS_ITEMS);

		if (isset($this->DMGs))
		{
			$goldValue += array_sum($this->DMGs) * 0.1;
			console_echo('+ ' . (array_sum($this->DMGs) * 0.1) . ' (damage)', '#fda', CNS_ITEMS);
		}

		if (isset($this->DMGs_def))
		{
			$goldValue += array_sum($this->DMGs_def) * 0.1;
			console_echo('+ ' . (array_sum($this->DMGs_def) * 0.1) . ' (defence)', '#fda', CNS_ITEMS);
		}

		if (isset($this->DSs))
		{
			$goldValue += array_sum($this->DSs) * 0.02;
			console_echo('+ ' . (array_sum($this->DSs) * 0.02) . ' (attributes)', '#fda', CNS_ITEMS);
		}

		$bhvGold = 0; //XXX
		foreach ($this->behaviours as $behaviours)
		{
			foreach ($behaviours as $behaviour)
			{
				$goldValue += $behaviour->goldValue;
				console_echo(' - ' . $behaviour->goldValue . ' (' . get_class($behaviour) . ')', '#ffa', CNS_ITEMS);
				$bhvGold += $behaviour->goldValue;	//XXX
			}
		}
		console_echo("+ {$bhvGold} (behaviour)", '#fda', CNS_ITEMS);

		console_echo("Total: $goldValue\n", '#ffa', CNS_ITEMS);
		if ($this->owner === $GLOBALS['player']) $goldValue = $goldValue * PLAYER_SALE_MULTIPLYER;

		// Convert to the appropriate currency
		$CUR_value = $CUR ? convertCurrency($goldValue, CUR_GOLD, $CUR) : $goldValue;

		// Add the special rate if there is one
		if ($sa) $CUR_value = sa($CUR_value, $sa);

		// Round it up or down depending on how mean we want to be
		$CUR_value = ($this->owner instanceof Player) ? floor($CUR_value) : ceil($CUR_value);

		// Done
		return $CUR_value;
	}

	public function getAjaxObject($CUR = null, $sa_priceMod = null)
	{

		$i = new stdClass();

		$i->id = $this->id;

		if ($this->quantity < 1)
		{
			$i->delete = true;
			return $i;
		}

		$i->name		= $this->name;
		$i->quantity	= $this->quantity;
		$i->equipped	= ($this instanceof Equipment && $this->isEquipped);
		$i->INV			= $this->INV;
		$i->SKLS		= $this->SKLS;

		if (isset($this->level))
		{
			$i->level = $this->level;
		}

		if (isset($CUR))
		{
			$i->price = $this->getPrice($CUR, $sa_priceMod);
		}

		return $i;
	}

	public function equals(Item $item)
	{
		if (get_class($item) !== get_class($this)) return false;

		if ($this->name			!== $item->name			) return false;
		if ($this->description	!== $item->description	) return false;
		if ($this->level		!== $item->level		) return false;
//		if ($this->materials	!== $item->materials	) return false;

		return true;
	}

	/**
	 * Custom equals lets you determine whether or not two items are equal based
	 * only on the properties you pass in.
	 * If you want to compare on class, make sure "class" is all lower case.
	 *
	 * @param Item $item The item for comparison
	 * @param type $properties The properties that you want to check against
	 * @return boolean <b>TRUE</b> if all properties match, <b>FALSE</b> otherwise
	 */
	public function cEquals(Item $item, $properties)
	{
		console_echo("Running cEquals on {$item->name} and {$this->name}:", '#afa', CNS_ITEMS);
		foreach ($properties as $property)
		{
			if ($property === 'class')
			{
				if (get_class($item) !== get_class($this)) //return false;
				{
					console_echo('class doesn\'t match.', '#aaa', CNS_ITEMS);
					return false;
				}
			}
			else
			{
				if (!isset($this->$property, $item->$property))
				{
					console_echo("{$property} not present in both", '#aaa', CNS_ITEMS);
					return false; // Oosenupt - not sure about this.
				}
				if ($this->$property !== $item->$property)
				{
					console_echo("{$property} not equal in both", '#aaa', CNS_ITEMS);
					return false;
				}
			}
		}

		return true;
	}

	public function damageItem ()
	{
		if ($this->isBroken) return;

		$this->durability -= 1;

		$this->onDamage();

		if ($this->durability < 1) $this->breakItem();
	}

	public function breakItem ()
	{
		if ($this->isBroken) return;

		$this->durability = 0;
		$this->durabilityMax = round($this->durabilityMax * 0.6, 0, PHP_ROUND_HALF_UP);

		if ($this->durabilityMax > MIN_DURABILITY) $this->durabilityMax = MIN_DURABILITY;

		$this->onBreak();
	}

	public function onClick($UIN)
	{
		global $player;

		if ($this->owner === $player) // Handling click on inventory item
		{
			$quantity = 1;
			switch ($UIN)
			{
				case UIN_CLICK:
					$this->inspect();
					break;
				case UIN_CTRL_ALT_RIGHT_CLICK:
					$quantity = $this->quantity;
				case UIN_CTRL_RIGHT_CLICK:
					if (isset($player->engagement->inventory) && ($player->engagement->inventory->lootable))
					{
						$player->engagement->inventory->add($player->inventory->pullItem($this, $quantity));
					}
					break;
				case UIN_RIGHT_CLICK:
					$this->useItem();
					break;
			}
		}
		elseif ($player->engagement && $this->owner === $player->engagement)	// Handling click on engagement's item
		{
			$quantity = 1;
			switch ($UIN)
			{
				case UIN_CLICK:
					$this->inspect();
					break;
				case UIN_CTRL_RIGHT_CLICK;
					$quantity = $this->quantity;
					console_echo("Taking {$quantity} {$this->name}s", null, CNS_ITEMS);
				case UIN_RIGHT_CLICK:
					{
						$player->inventory->add($player->engagement->inventory->pullItem($this, $quantity));
					}
					break;
			}
		}
	}

	public function __debugInfo ()
	{
		return [
			'name' => $this->name,
			'description' => $this->description,
			'sprite' => $this->sprite,
			'level' => $this->level,
			'quantity' => $this->quantity,
			'durability' => "{$this->durability}/{$this->durabilityMax}",
		];
	}

	public function onTransform($TFI) { return $this; }

    public function onCollect()	{ $this->executeBehaviours(__FUNCTION__); }
	public function onDrop()	{ $this->executeBehaviours(__FUNCTION__); }
	public function onUse()		{ $this->executeBehaviours(__FUNCTION__); }
	public function onDamage()	{ $this->executeBehaviours(__FUNCTION__); }
	public function onBreak()	{ $this->executeBehaviours(__FUNCTION__); }
}

abstract class ItemBehaviour extends Behaviour
{
	public $goldValue			= 1;
	public $ICATs				= [];

	public $onCollect			= null;
	public $onDrop				= null;
	public $onUse				= null;
	public $onDamage			= null;
	public $onBreak				= null;

	public function onCollect	() { }
	public function onDrop		() { }
	public function onUse		() { }
	public function onDamage	() { }
	public function onBreak		() { }
}

abstract class Material
{
	public $name;
	public $description;
	public $colour;
	public $sprite;

	public $durability	= 1;
	public $goldValue	= 1;

	private $DMGs		= [];
	private $DMGDLs		= [];
	private $DMGs_def	= [];
	private $DSs		= [];
	private $DSs_req	= [];

	public function __construct($name, $description, $colour,
		$DMGs		= null,
		$DMGDLs		= null,
		$DMGs_def	= null,
		$DSs		= null,
		$DSs_req	= null
		)
	{
		$this->name			= $name;
		$this->description	= $description;
		$this->colour		= $colour;
		$this->sprite		= $this->getSprite();

		$arrayNames = [
			'DMGs',
			'DMGDLs',
			'DMGs_def',
			'DSs',
			'DSs_req',
		];


		foreach ($arrayNames as $array)
		{
			if (!isset($$array)) $$array = [];

			$baseArray = $this->getArray($array);
			$resultArray = $$array + $baseArray;
			foreach ($baseArray as $key => $value)
			{
				if (is_string($value)) $resultArray[$key] = "{$resultArray[$key]}";
			}
			$this->{"_{$array}"} = $resultArray; // Terrible
		}
	}

	function __toString()
	{
		return $this->name;
	}

	function getArray($array) { return $this->$array; }

	abstract function getSprite();

	function __get($name)
	{
		if (isset($this->{"_{$name}"}))
		{
			return $this->{"_{$name}"};
		}
	}
}

trait MaterialTrait
{
	function getArray($array)
	{
		$thisArray = isset($this->$array) ? $this->$array : [];
		$parentArray = parent::getArray($array);
		$returnArray = $thisArray + $parentArray;
		foreach ($parentArray as $key => $value)
		{
			if (is_string($value)) $returnArray[$key] = "{$returnArray[$key]}";
		}
		return $returnArray;
	}
}

class itm_material extends Item
{
	public function __construct(Material $material)
	{
		$this->materials = [$material];

		parent::__construct(
			$material->name,
			$material->description,
			$material->sprite
		);
	}
}

class mat_fabric extends Material
{
	use MaterialTrait;

	public $durability = 1;

	private $DMGs_def =
	[
		DMG_COLD => '1.5',
	];
	private $DSs =
	[
		DS_AGILITY => 1.2,
	];

	function getSprite()
	{
		return new Sprite([
			0 => new SpriteElement(tint($this->colour, -1), '#fff', '@'),
			1 => new SpriteElement(tint($this->colour, 1), $this->colour, '&#x2584;'),
			2 => new SpriteElement(tint($this->colour, 1), $this->colour, '&#x2584;'),
			4 => new SpriteElement($this->colour, '#fff', '&#x2026;'),
			5 => new SpriteElement($this->colour, '#fff', '&#x2026;'),
		]);
	}
}

class mat_lightFabric extends mat_fabric
{
	use MaterialTrait;

	public $durability = 0.7;
}

class mat_heavyFabric extends mat_fabric
{
	use MaterialTrait;

	public $durability = 1.4;

	private $DMGs_def =
	[
		DMGDL_CUT => 1.5,
	];
}

class mat_skin extends mat_heavyFabric
{
	use MaterialTrait;

	public $durability = 1.7;

	private $DMGs_def = [
		DMG_WATER => '2.0',
	];

	function getSprite()
	{
		return new Sprite([
			0 => new SpriteElement($this->colour, '#000', '&#x201a;'),
			1 => new SpriteElement(null, $this->colour, '&#x2584;'),
			2 => new SpriteElement($this->colour, null, null),
			3 => new SpriteElement($this->colour, '#000', '&#x2019;'),
			4 => new SpriteElement(null, $this->colour, '&#x2580;'),
			5 => new SpriteElement($this->colour, null, null),
			]);
	}
}

class mat_metal extends Material
{
	use MaterialTrait;

	public $durability = 2.5;

	private $DMGs_def =[
		DMGDL_CUT		=> '2.0',
		DMGDL_BLUNT		=> '2.0',
		DMGDL_POINT		=> '2.0',

		DMG_ELECTRIC	=> -0.5,
	];
	private $DSs =[
		DS_RESILIENCE	=> '1.8',
		DS_FORCE		=> 1.7,
	];

	function getSprite()
	{
		return new Sprite([
			0 => new SpriteElement(null, $this->colour, '&#x2584;'),
			1 => new SpriteElement(null, $this->colour, '&#x2584;'),
			2 => new SpriteElement(null, $this->colour, '&#x2584;'),
			3 => new SpriteElement(tint($this->colour, -2), $this->colour, '&#x2500;'),
			4 => new SpriteElement(tint($this->colour, -2), $this->colour, '&#x2500;'),
			5 => new SpriteElement(tint($this->colour, -2), $this->colour, '&#x2500;'),
		]);
	}
}

class mat_wood extends Material
{
	use MaterialTrait;

	public $durability = 2;

	private $DMGs_def = [
		DMG_FIRE	=> '-0.5',
		DMGDL_BLUNT	=> '1.8',
		DMGDL_CUT	=> '1.5',
		DMGDL_POINT	=> '1.6',
	];
	private $DMGDLs =[
		DMGDL_CUT	=> 0.1,
		DMGDL_BLUNT	=> 1.1,
		DMGDL_POINT	=> 1.3,
	];

	function getSprite()
	{
		$tint = tint($this->colour, -2);
		return new Sprite([
			0 => new SpriteElement(null, $this->colour, '&#x2584;'),
			1 => new SpriteElement(null, $this->colour, '&#x2584;'),
			2 => new SpriteElement(null, $this->colour, '&#x2584;'),
			3 => new SpriteElement($this->colour, $tint, '&#x2584;'),
			4 => new SpriteElement($this->colour, $tint, '&#x2584;'),
			5 => new SpriteElement($this->colour, $tint, '&#x2584;'),
		]);
	}

}

class mat_bone extends Material
{
	use MaterialTrait;

	public $durability = 1.9;

	function getSprite()
	{
		return new Sprite([
			1 => new SpriteElement(null, $this->colour, '_'),
			2 => new SpriteElement(null, $this->colour, '_'),
			3 => new SpriteElement(null, $this->colour, '('),
			4 => new SpriteElement(null, $this->colour, '('),
			5 => new SpriteElement(null, $this->colour, '('),
		]);
	}
}

class mat_stone extends Material
{
	use MaterialTrait;

	public $durability = 2.9;

	function getSprite()
	{
		$top		= tint($this->colour, 3, true);
		$topDetail	= tint($this->colour, 6, true);

		return new Sprite([
			new SpriteElement($top, $topDetail, 'L'),
			new SpriteElement($top, $topDetail, '_'),
			new SpriteElement($top, $topDetail, '_'),
			new SpriteElement($this->colour, $top, 'L'),
			new SpriteElement($this->colour, $top, '_'),
			new SpriteElement($this->colour, $top, '_')
		]);
	}
}

class mat_gem extends mat_stone
{
	use MaterialTrait;

	public $durability = 3.5;

//	function getSprite()
//	{
//		// Need a sprite lol
//	}
}

const CUR_GOLD		= 1;
const CUR_FENT		= 2;
const CUR_SHARPS	= 3;
const CUR_VITTIS	= 4;
const CUR_GRODOS	= 5;

$currencies = [
	CUR_GOLD	=> new currency(CUR_GOLD,	'Gold',		'&#x00a4;',	1,		'#fd0'),
	CUR_FENT	=> new currency(CUR_FENT,	'Fent',		'&#x20a3;',	100,	'#f85'),
	CUR_SHARPS	=> new currency(CUR_SHARPS,	'Sharps',	'&#x0424;',	250,	'#ddd'),
	CUR_VITTIS	=> new currency(CUR_VITTIS,	'Vittis',	'&#x040f;',	800,	'#fa0'),
	CUR_GRODOS	=> new currency(CUR_GRODOS,	'Grodos',	'&#x0431;',	640,	'#c53'),
];

function spr_money($coinColour)
{
	$coins = [
		new SpriteElement(null, $coinColour, '.'),
		new SpriteElement(null, $coinColour, ':'),
		new SpriteElement(null, $coinColour, '&bull;'),
		new SpriteElement(null, $coinColour, '&bull;'),
		null,
		null,
	];

	shuffle($coins);
	$coins = array_filter($coins);
	return new Sprite($coins);
}

function convertCurrency($amount, $curFrom, $curTo)
{
	global $currencies;
	return ($amount / $currencies[$curFrom]->goldPrice) * $currencies[$curTo]->goldPrice;
}

function getFormattedAmount($amount, $CUR, $convertFromGold = false)
{
	console_echo('Getting formatted amount.');

	if ($convertFromGold) $amount = convertCurrency($amount, CUR_GOLD, $CUR);

	$amount = number_format($amount);

	global $currencies;
//	return "{$currencies[$CUR]->symbol}&nbsp;" . number_format($amount, 2);
	return "{$currencies[$CUR]->symbol}&nbsp;{$amount}";
}

class currency
{
	public $key;
	public $name;
	public $symbol;
	public $goldPrice;
	public $coinColour;

	private $sprites = [];

	function __construct($key, $name, $symbol, $goldPrice, $coinColour)
	{
		$this->key			= $key;
		$this->name			= $name;
		$this->symbol		= $symbol;
		$this->goldPrice	= $goldPrice;
		$this->coinColour	= $coinColour;

		for ($i = 0; $i <= 3; $i++)
		{
			$this->sprites[] = spr_money($coinColour);
		}
	}

	public function __get($name)
	{
		return ($name == 'sprite' ? $this->sprites[mt_rand(0, 3)] : null);
	}

	function __toString()
	{
		return $this->name;
	}
}


class itm_money extends Item
{
	public $CUR;
	public $amount;

	function __construct($CUR, $goldValue, $absoluteValue = false)
	{
		$currency = $GLOBALS['currencies'][$CUR];
		$this->CUR = $CUR;

		if ($absoluteValue) $this->amount = $goldValue;
		else
		{
			$goldValue = (mt_rand(0, RAND_MAX) / RAND_MAX) * $goldValue + ($goldValue / 2);
			$this->amount	= round(convertCurrency($goldValue, CUR_GOLD, $CUR), 2);
		}

		// This stuff is for the parent constructor:
        $name = "{$this->amount} {$currency}";
        $description = getFormattedAmount($this->amount, $this->CUR);
		$sprite = $currency->sprite;

		console_echo("Made a money item: $description", '#ffa');

		parent::__construct($name, $description, $sprite);
	}
}


abstract class Equipment extends Item
{
	public $EQP;	// Slot
	public $isEquipped		= false;

	public $DSs				= null;
	public $DSs_req			= null;

	public $durabilityMax = 100;

	// Generator variables:
	// Counts and mods and yadda yadda yadda
	public $DSs_mod			= 1;
	public $DSs_req_mod		= 1;

	public $DSs_count		= 1;
	public $DSs_req_count	= 1;

	public $durability_mod	= 1;

	// This is one of the base DSs (Strength, Agility, Magic, Intelligence, Social).
	public $DS_base			= null;
	// If you want to reduce the scope of the possibilities for the DS_base variable, define the choices in the DS_base_choices array.
	public $DS_base_choices	= null;

	// This is the name pulled out of the key of the shopping list used to assign the materials.
	// Used for name generation purposes.
	public $noun;

	abstract function getShoppingLists();
	abstract function getSpriteSet();
	abstract function getDescription();

	function __construct($level = null, $name = null, $description = null, $spriteSet = null)
	{
		$this->level = $level;

		parent::__construct($name, $description, $spriteSet);
	}

	public static function constructFromMask (Mask $mask)
	{
		if (isset($mask->class))
		{
			if (is_array($mask->class))
			{
				$class = $mask->class[array_rand($mask->class)];
			}
			else
			{
				$class = $mask->class;
			}

			$equipment = new $class();

//			console_var_dump($equipment, '#aaa', CNS_ITEMS);

			if (!($equipment instanceof Equipment)) return null;

			foreach (get_object_vars($equipment) as $name => $val)
			{
				if (isset($mask->$name)) $equipment->$name = $mask->$name;
			}

			$equipment->finish();

			return $equipment;
		}
		else return null;
	}

	// There are three main object closure functions: fillGaps(), consolidate()
	// and applyQuirks().
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// fillGaps() is designed to make sure that every type to advantage associated
	// with a piece of equipment as been added to each instance whether it has been
	// explicitly added or not.
	//
	// consolidate() is designed to tie a piece of equipment together so that the
	// equipment and its properties "make sense". consolidate() needs to be called
	// after fillGaps() because typically, consolidate() reads or manipulates the
	// values set by the fillGaps() function. consolidate() should also check for
	// essential properties that are not set.
	//
	// The key difference between fillGaps() and consolidate() is that fillGaps()
	// needs only the absolute minimum amount of information to be loaded into the
	// equipment for it to be run but consolidate() needs all the "gaps to be filled"
	// so that it can draw all the details together.
	//
	// applyQuirks() is designed to allow automated "finishing touches" to an item
	// to keep things interesting (e.g., an item that does lightning damage might
	// use applyQuirks() to make it so that there's a 50% chance that this damage
	// will turn into a behaviour that applies that damage over time).
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// When overriding fillGaps(), a call to the parent function must be made at
	// the START of the overriding function.
	// When overriding consolidate(), a call to the parent function must be made
	// at the END of the overriding function. consolidate() must also accept an
	// array of strings as a parameter and return the same array of strings. The
	// strings should describe problems or warnings detected in the considication
	// process.
	// When overriding applyQuirks(), it's best to call it at the <b>END</b> of
	// the override to make sure that the individual quirks of the item itself
	// have the highest chance of being triggered.

	abstract protected function applyQuirks();

	/**
	 * fillGaps() should be written assuming that only the minimum developer-specified
	 * values have been set on the item and that only the gaps need to be filled.
	 * A call to the parent function <b>MUST</b> be placed at the <b>START<b/> of
	 * any overrides.
	 */
	protected function fillGaps()
	{
		global $DS_types;

		parent::fillGaps();

		if (!isset($this->DS_base) || !isset($DS_types[$this->DS_base]))
		{
			if (isset($this->DS_base_choices))
			{
				$this->DS_base = $this->DS_base_choices[array_rand($this->DS_base_choices)];
			}
			else
			{
				$this->DS_base = array_rand($DS_types);
			}
		}

		$this->assignMaterials();

		if (!isset($this->DSs))			$this->DSs = $this->generateDSs();
		if (!isset($this->DSs_req))		$this->DSs_req = $this->generateDSs_req();

		if (!isset($this->spriteSet))	$this->spriteSet = $this->getSpriteSet();
	}

	/**
	 * consolidate() should be written assuming that all the equipment's properties
	 * have been set and just need tidying up and linking together.
	 * A call to the parent function <b>MUST</b> be placed at the <b>END</b> of
	 * any overrides and must pass in the $problems array (and make use of the returned
	 * array when the parent function has finished executing).
	 *
	 * @param array $problems - an array of strings describing detected problems.
	 * @return array - the same array with any additional problem descriptions added to it.
	 */
	protected function consolidate($problems = [])
	{
		console_echo("Running equipment consolidator on {$this->name}");

		$this->problemCheck($problems);

		$this->applyMaterialMods();

		if (!isset($this->name))		$this->name = $this->getName();
		if (!isset($this->description))	$this->description = '';
		if (!isset($this->spriteSet))	$this->spriteSet = $this->getSpriteSet();

		$this->applyQuirks();

		$this->description .= $this->getDescriptionAnnex(); // If a description is set, this description will add do it, not replace it.

		return parent::consolidate($problems);
	}

	function assignMaterials()
	{
		console_echo("Assigning materials for {$this->name}");

		$shoppingLists = $this->getShoppingLists();
		shuffle_assoc($shoppingLists);

		if (isset($this->materials))
		{
			if ($this->buildMaterialList()) return;
		}
		// If we are here it means that the material list is either missing or
		// fucked so we need to get a working material list from the map and
		// merge with with whatever we have.

		$materialAnnex = isset($GLOBALS['mapMaterials']) ? $GLOBALS['mapMaterials'] : $GLOBALS['map']->materials;

		if (!is_array($this->materials)) $this->materials = [];

		$this->materials = array_merge($this->materials, $materialAnnex);

		if ($this->buildMaterialList()) return;

		trigger_error('Unable to find / assign appropriate materials to make a ' . get_class($this));
	}

	/**
	 *	This function exists solely to prevent code repetition in the function above.
	 *	Never call this outside of assignMaterials().
	 */
	private function buildMaterialList ()
	{
		$shoppingLists = $this->getShoppingLists();

		foreach ($shoppingLists as $listNoun => $shoppingList)
		{
			$listMaterials = getRandomObjectsByClassList($this->materials, $shoppingList);

			if ($listMaterials)
			{
				$this->noun = trim($listNoun, '1234567890');

				$this->materials = $listMaterials;
				return true;
			}
		}

		return false;
	}

	function getRequiredStats($statName)
	{
		$base = $this->level * $this->{"{$statName}_mod"};

		$workingMaterials = $this->getWorkingMaterials();
		$requiredStats = [];
		foreach ($workingMaterials as $material)
		{
			if (!is_array($material->$statName)) continue;
			foreach ($material->$statName as $stat => $value)
			{
				if (is_string($value)) $requiredStats[$stat] = $base;
			}
		}
		console_echo("{$this->name} - {$statName} required:", '#faa');
//		console_var_dump($requiredStats, '#fca');
		return $requiredStats;
	}

	/**
	 * Sets a semi-random group of attributes to the base level appropritate for
	 * the equiptment type and level. Attributes will be weighted loosely towards
	 * one of the three stat types. The base of the weighted stat type is returned.
	 *
	 * @return DS returns a base DS constant (strength, agility or magic).
	 */
	function generateDSs($number = null)
	{
//		global $DS_types;
		global $DS_types_core;
		global $DS_types_subs;
		global $DS_typed;
		global $DS_global;

		$DS_extra = $DS_typed + $DS_global;

		$base = (10 + ($this->level ^ 1.2)) * $this->DSs_mod;
		if (!isset($number)) $number = 4;

		foreach ($DS_types_core[$this->DS_base] as $DS)
		{
			$DSs[$DS] = $base;
		}

		for ($i = count($DSs) - getNuancedValue($number, 30); $i > 0; $i--)
		{
			unset($DSs[array_rand($DSs)]);
		}

		$base = ceil($base / 2);
		for ($i = mt_rand(1, $number); $i > 0; $i--)
		{
			$newDS = array_rand(mt_rand(0,1) ? $DS_extra : $DS_types_subs);
			if (!isset($DSs[$newDS])) $DSs[$newDS] = $base;
		}

		return $this->getRequiredStats('DSs') + $DSs;
	}

	function generateDSs_req()
	{
		$base = ($this->level ^ 1.2);
		$reqs = $this->getRequiredStats('DSs_req') + [$this->DS_base => getNuancedValue($base, 10) + 90];

		foreach ($reqs as &$req) $req *= $this->DSs_req_mod;
		return $reqs;
	}

	function getName()
	{
		return $this->noun;
	}

	function getDescriptionAnnex()
	{
		$description = ' ' . ucfirst($this->getDescription());

		$base = $this->level * $this->DSs_mod * 2;
		if ($this->DSs && max($this->DSs) >= $base)
		{
			global $DS_names;

			$description .= " A boon to {$DS_names[array_search(max($this->DSs), $this->DSs)]}.";
		}

		if (isset($this->DMGs_def))
		{
			$base = $this->level * $this->DMGs_def_mod * 2;
			if ($this->DMGs_def && max($this->DMGs_def) >= $base)
			{
				global $DMG_DMGDL_names;

				$description .= " Highly effective against {$DMG_DMGDL_names[array_search(max($this->DMGs_def), $this->DMGs_def)]} attacks.";
			}
		}

		if (isset($this->DMGs))
		{
			$base = $this->level * $this->DMGs_mod * 2;
			if ($this->DMGs && max($this->DMGs) >= $base)
			{
				global $DMG_names;

				$description .= " Delivers a potent {$DMG_names[array_search(max($this->DMGs), $this->DMGs)]} attack.";
			}
		}

		return $description;
	}

	function applyMaterialMods()
	{
		$arrays = ['DMGs', 'DMGs_def', 'DSs', 'DSs_req'];

		$workingMaterials = $this->getWorkingMaterials();

		foreach ($arrays as $statType)
		{
			if (!isset($this->$statType)) continue;
//			console_echo("Applying materials mods to {$this->name}'s {$statType}");

			if (isset($this->$statType) && !empty($this->$statType))
			{
				foreach ($this->$statType as $key => &$value)
				{
					console_echo("{$key} before = {$value}", '#aff');

					$base = $value;

					foreach ($workingMaterials as $material)
					{
						$array = $material->$statType;
						if (isset($array[$key])) $value += ($base * $array[$key]) - $base;
					}

					$value = floor($value);

					console_echo("{$key} after = {$value}", '#afe');
				}
			}

			$this->$statType = array_filter($this->$statType);
		}

		$durabilityMod = $this->durabilityMax;

		foreach ($workingMaterials as $material)
		{
			$durabilityMod *= ($material->durability - 1);
		}

		$this->durabilityMax += $durabilityMod;
	}

	function equip()
	{
		if ($this->isBroken)
		{
			$this->owner->say("{$this->name} is broken.");
			return;
		}
		$this->owner->equip($this);
	}

	function unequip()
	{
		$this->owner->unequip($this);
	}

	function useItem()
	{
		if ($this->isEquipped) $this->unequip();
		else $this->equip();
	}

	function breakItem()
	{
		if ($this->isEquipped) $this->unequip();

		parent::breakItem();
	}


	// Mandatory behaviour functions below this point

	function onAttack	(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	function onMiss		(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	function onStrike	(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	function onKill		(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }

	function onDefend	(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	function onDeflect	(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	function onTakeHit	(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }
	function onDeath	(Attack $attack)	{ $this->executeBehaviours(__FUNCTION__, $attack); }

	function onEquip		()	{ $this->executeBehaviours(__FUNCTION__); }
	function onUnequip		()	{ $this->executeBehaviours(__FUNCTION__); }

	function onMapChange	()	{ $this->executeBehaviours(__FUNCTION__); }
}

abstract class EquipmentBehaviour extends ItemBehaviour
{
	public $onAttack			= null;
	public $onMiss				= null;
	public $onStrike			= null;
	public $onKill				= null;

	public $onDefend			= null;
	public $onDeflect			= null;
	public $onTakeHit			= null;
	public $onDeath				= null;

	public $onEquip				= null;
	public $onUnequip			= null;

	public $onMapChange			= null;

	public function onAttack	(Attack $attack) { }
	public function onMiss		(Attack $attack) { }
	public function onStrike	(Attack $attack) { }
	public function onKill		(Attack $attack) { }

	public function onDefend	(Attack $attack) { }
	public function onDeflect	(Attack $attack) { }
	public function onTakeHit	(Attack $attack) { }
	public function onDeath		(Attack $attack) { }

	public function onEquip		() { }
	public function onUnequip	() { }

	public function onMapChange	() { }
}


class Attack
{
	public $attacker;
	public $target = null;

	protected $base_DMGDL;
	protected $base_DMGs = [];

	public $TEQT;

	public $cooldown;
	public $readyTime;

	public $isBaseAttack = true;
	public $noVariation	= false;

	// The difficulty stat is used to calculate biases on teqnique variables that
	// don't have an opposite (e.g., attack speed). I imagine that the way in which
	// this stat is calculated will chnage a lot during the balancing process.
	public $difficulty;

	// For these values: TRUE = always, FALSE = never, NULL = no change
	public $alwaysHit = null;
	public $alwaysCrit = null;
	public $alwaysReady = null;

	// TRANSIENT VARIABLES:
	// These get reset with every execution.

	public $damage	= 0;

	// What needs to be here?

	// See and edit total damage
	public $damage_modifiers = [];
	// See and edit specific damage types
	public $DMGs_modifiers = [];
	public $DMGs_def_modifiers = [];
	// See and edit delivery method
	public $DMGDL;
	public $DMGs = [];
	public $DMGs_def = [];
	// See and edit the chance to hit
	public $hitChance_modifiers = [];
	public $dodgeChance_modifiers = [];
	// See and edit whether or not the attack is a crit
	public $isCrit; // Boolean
	// See and edit chance to crit
	public $critChance_modifiers = [];
	// See and edit dude stats of both parties
	public $attackerDSs_modifers = [];
	public $targetDSs_modifers = [];
	// See and edit attack config of both parties

	// What needs to NOT be in here?
	// Direct access to the calculated bias variables

	// Other read-only attributes for use in quest determiners
	public $hit;		// Did the attack hit?
	public $kill;		// Did the attack kill?
	public $leveled;	// Did the attack cause a level up?

	public function __construct(Dude $attacker, $DMGDL = null, $DMGs = null, $TEQT = null)
	{
		global $DMG_DMGDL_names;

		$this->attacker	= $attacker;

		if (!isset($TEQT)) $TEQT = $attacker->TEQT;
		$this->TEQT = $TEQT;

		if (isset($DMGDL) && isset($DMGs))
		{
			$this->isBaseAttack = false;
			$this->base_DMGDL	= $DMGDL;
			$this->base_DMGs	= $DMGs;
		}
		else
		{
			$this->isBaseAttack = true;
			$this->base_DMGDL	= $attacker->DMGDL;
			$this->base_DMGs	= $attacker->DMGs;
		}

		$DMGDL_mod = $attacker->{"DMGDL_{$DMG_DMGDL_names[$this->base_DMGDL]}"} . '%';

		foreach ($this->base_DMGs as $DMG => $value)
		{
			$this->base_DMGs[$DMG] = sa($this->base_DMGs[$DMG], $attacker->{"DMG_{$DMG_DMGDL_names[$DMG]}"} . '%'); // Terrible
			$this->base_DMGs[$DMG] = sa($this->base_DMGs[$DMG], $DMGDL_mod);
		}

		if ($weapon = $attacker->getItemByEQP(EQP_HAND)) // Forget the warning, this is on purpose.
			$this->difficulty = $weapon->level * 10;		// Oosenupt - this hasn't be thought through properly and balancing may require additional attention here.
		else
			$this->difficulty = 100 + $attacker->level;

		$this->readyTime = $_SERVER['REQUEST_TIME_FLOAT'];

		global $DMGDL_names;	//XXX
		console_echo('Attack details:', '#faf', CNS_ATTACK);
		console_echo("Attacker: {$this->attacker->name}", '#fff', CNS_ATTACK);
		console_echo('Total damage: ' . array_sum($this->base_DMGs), '#fff', CNS_ATTACK);
		console_echo("cooldown: {$this->cooldown}", '#fff', CNS_ATTACK);
		console_echo("Damage delivery: {$DMGDL_names[$this->base_DMGDL]}", '#fff', CNS_ATTACK);
	}

	function __get($name)
	{
		return $this->$name;
	}

	public function execute(AsObject $target)
	{
		global $player;

		if (!$this->alwaysReady === true && ($this->alwaysReady === false || $_SERVER['REQUEST_TIME_FLOAT'] < $this->readyTime))
		{
			console_echo('Attack not ready.', null, CNS_ATTACK);
			return;
		}

		console_echo("{$this->attacker->name} is attacking {$target->name}!", '#aaf', CNS_ATTACK);

		// Identify target
		$this->target = $target;
		$this->DMGDL = $this->base_DMGDL;
		$this->DMGs = $this->base_DMGs;

		// Determine method of attack
		if ($target instanceof Dude)
		{
			$this->attackDude();
		}

		if ($this->attacker === $player)
		{
			$usedDSs = array_merge(
				array_keys($this->attacker->technique[$this->TEQT][TEQ_DAMAGE]),
				array_keys($this->attacker->technique[$this->TEQT][TEQ_HIT_CHANCE]),
				array_keys($this->attacker->technique[$this->TEQT][TEQ_CRIT_DAMAGE]),
				array_keys($this->attacker->technique[$this->TEQT][TEQ_CRIT_CHANCE])
			);
		}
		elseif ($this->target === $player)
		{
			$usedDSs = array_merge(
				array_keys($this->target->technique[$this->TEQT][TEQ_DEFENCE]),
				array_keys($this->target->technique[$this->TEQT][TEQ_DODGE_CHANCE])
			);
		}


		if (isset($usedDSs))
		{
			global $DS_names; //XXX
			console_echo("DSs used by <<#fff>>{$player->name}<> in this attack:", '#faf', CNS_ATTACK);

			foreach ($usedDSs as $DS)
			{
				console_echo("{$DS_names[$DS]}", '#ffa', CNS_ATTACK);

				if (isset($player->used_DSs[$DS])) $player->used_DSs[$DS] += 1;
				else $player->used_DSs[$DS] = 1;
			}
		}

		console_echo("cooldown: <<#fff>>{$this->cooldown}<>", '#afa', CNS_ATTACK);
		$this->readyTime = $_SERVER['REQUEST_TIME_FLOAT'] + $this->cooldown;
		if ($this->cooldown === null) console_echo("<<#ffa>>NULL<> cooldown for attack of {$this->attacker->name}", '#faa');

		// Clear target
		$this->target = null;
		$this->cooldown = null;

		$this->damage					= 0;
		$this->DMGDL					= null;
		$this->DMGs						= [];
		$this->DMGs_def					= [];

		$this->isCrit					= null;
		$this->damage_modifiers			= [];
		$this->DMGs_modifiers			= [];
		$this->DMGs_def_modifiers		= [];
		$this->hitChance_modifiers		= [];
		$this->dodgeChance_modifiers	= [];
		$this->critChance_modifiers		= [];

		$this->kill						= null;
		$this->hit						= null;
	}

	function getcooldown($speedBias)
	{
		// The difficulty is the FOR variable because that's what makes the cooldown HIGHER.
		$speedBias = getBiasCalculation($this->difficulty, $speedBias, GBC_DECIMAL);
		// cooldown is set here but actually handled in the execute() function.
		return 0.5 + (3 * $speedBias);
	}

	function attackDude()
	{
		global $player;
		global $DMG_names; //XXX
		global $DMG_colours; //XXX

		global $FAC_standing;

		$event = new attackEvent();

		$event->isBaseAttack = $this->isBaseAttack;

		$event->attackerName = $this->attacker->name;
		$event->targetName = $this->target->name;

		$event->DMGDL = $this->DMGDL;
		$event->TEQT = $this->TEQT;

		$event->rawDamage = array_sum($this->DMGs);

		$event->towardsPlayer = $this->target === $player;

		$attackerLevelAdvantage = $this->attacker->level - $this->target->level;

		if ($this->attacker === $player)
		{
			console_echo("Setting opponent to {$this->target->name}", null, CNS_ATTACK);
			$player->opponent = $this->target;
		}
		elseif ($this->target === $player && !$player->opponent)
		{
			console_echo("Setting opponent to {$this->attacker->name}", null, CNS_ATTACK);
			$player->opponent = $this->attacker;
		}

		///////////////////////////////////////
		//
		//	PART I: Setting up
		//
		///////////////////////////////////////

		$attackerBiases = $this->attacker->getTEQbiases($this->TEQT);
		foreach($attackerBiases as &$value) $value += $value * (($this->attacker->level - $this->target->level) * 0.2);

		$targetBiases = $this->target->getTEQbiases($this->TEQT);
//		foreach($targetBiases as &$value) $value *= $this->target->level / $this->attacker->level;

		// Get the cooldown early so that behaviours can modify it with ease.
		$this->cooldown = $this->getcooldown($attackerBiases[TEQ_ATTACK_SPEED]);

//		$targetDefence = $this->target->DMGs_def;
		$this->DMGs_def = $this->target->DMGs_def;

		$report = $this->attacker === $GLOBALS['player'] || $this->target === $GLOBALS['player'];
		console_echo('Attack reporting is ' . ($report ? '<<#afa>>ON<>': '<<#faa>>OFF<>'), '#aaf', CNS_ATTACK);

		console_echo('Total damage before defence reduction: <<#fff>>' . array_sum($this->base_DMGs) . '<>', '#ffa', CNS_ATTACK);

		///////////////////////////////////////
		//
		//	PART II: First lot of behaviours
		//
		///////////////////////////////////////

		// Execute behaviours
		$this->attacker->attack($this);
		$this->target->defend($this);

		if ($this->isBaseAttack)
		{
			switch ($this->TEQT)
			{
				case TEQT_MELEE:
					update_sound(SND_SWING);
					break;
			}
		}

		///////////////////////////////////////
		//
		//	PART III: Did it hit?
		//
		///////////////////////////////////////

		if ($this->alwaysHit === null)
		{
			// Calculate odds of successful hit
			$hitChance = getBiasCalculation($attackerBiases[TEQ_HIT_CHANCE], $targetBiases[TEQ_DODGE_CHANCE], GBC_PERCENTAGE);

			console_echo("Chance to hit (beofre mods): <<#fff>>{$hitChance}%<>.", '#aaf', CNS_ATTACK);

			$this->hitChance_modifiers[] = $hitChance;
			$hitChance = valueListToValue($this->hitChance_modifiers);

			console_echo("Chance to hit (after mods): <<#fff>>{$hitChance}%<>.", '#aaf', CNS_ATTACK);

			// Get result
			$this->hit = percentageToBool($hitChance);
		}
		else
		{
			$this->hit = $this->alwaysHit;
			console_echo('This attack will ' . ($this->alwaysHit ? '<<#afa>>ALWAYS<>' : '<<#faa>>NEVER<>') . ' hit.', '#aaf', CNS_ATTACK);
		}

		console_echo('The attack will ' . ($this->hit ? '<<#afa>>HIT<>' : '<<#faa>>MISS<>'), '#aaf', CNS_ATTACK);

		///////////////////////////////////////
		//
		//	PART IV: Will it crit?
		//
		///////////////////////////////////////

		if ($this->alwaysCrit === null)
		{
			$critResistBias = 10 * ($targetBiases[TEQ_DODGE_CHANCE] + $targetBiases[TEQ_DEFENCE]);

			$critChance = getBiasCalculation($attackerBiases[TEQ_CRIT_CHANCE], $critResistBias, GBC_PERCENTAGE);

			console_echo("Crit chance (before mods): <<#fff>>{$critChance}%<>", '#ffa', CNS_ATTACK);

			$this->critChance_modifiers[] = $critChance;
			$critChance = valueListToValue($this->critChance_modifiers);

			console_echo("Crit chance (after mods): <<#fff>>{$critChance}%<>", '#ffa', CNS_ATTACK);
		}
		else
		{
			$critChance = $this->alwaysCrit ? 999 : 0;
			console_echo('This attack will ' . ($this->alwaysCrit ? '<<#afa>>ALWAYS<>' : '<<#faa>>NEVER<>') . ' crit.', '#ffa', CNS_ATTACK);
		}

		if (percentageToBool($critChance) && $this->hit)
		{
			console_echo('Critical hit has transpired', '#ffa', CNS_ATTACK);

			$this->isCrit = true;
			$critAmp = getBiasCalculation($attackerBiases[TEQ_CRIT_DAMAGE], $targetBiases[TEQ_DEFENCE], GBC_PERCENTAGE);

//			if ($this->isBaseAttack) update_sound(SND_WOOSHDING); // Oosenupt - make a better crit sound; this one is irritating as hell
			console_echo("Crit amp: <<#fff>>{$critAmp}%<>", '#ffa', CNS_ATTACK);
		}
		else
		{
			$critAmp = 0;
		}

		$event->critPercentage = $critAmp;

		///////////////////////////////////////
		//
		//	PART V: Hit or go home
		//
		///////////////////////////////////////

		// Did we get 'em?
		if ($this->hit)
		{
			// Execute behaviours related to a successful strike
			$this->attacker->strike($this);
			$this->target->takeHit($this);

			$event->hit = true;

			if ($this->isBaseAttack)
			{
				switch ($this->TEQT)
				{
					case TEQT_MELEE:
						switch ($this->DMGDL)
						{
							case DMGDL_BLUNT:	update_sound(SND_DMGDL_BLUNT);	break;
							case DMGDL_POINT:	update_sound(SND_DMGDL_POINT);	break;
							case DMGDL_CUT:		update_sound(SND_DMGDL_CUT);	break;
						}
						break;
				}
			}
		}
		else
		{
			$event->hit = false;

			// execute behaviours related to a failed attack
			$this->attacker->miss($this);
			$this->target->deflect($this);

			update_combat($event);
			return;
		}

		///////////////////////////////////////
		//
		//	PART VI: How much damage as actually done?
		//
		///////////////////////////////////////

		// Apply random aspect
		$randomisation = getBiasCalculation($this->difficulty, $attackerBiases[TEQ_CONSISTENCY], GBC_DECIMAL);
		$randomisation = mt_rand(
			ATTACK_RAND_MIN * $randomisation,
			ATTACK_RAND_MAX * $randomisation
		) . '%';

		console_echo("Randomisation value: <<#fff>>{$randomisation}<>", '#aff');

//		$this->damage_modifiers[] = $randomisation;

		$event->mainDMG = array_search(max($this->DMGs), $this->DMGs);

		foreach ($this->DMGs as $DMG => &$amount)
		{
			$consoleDMG = "<<{$DMG_colours[$DMG]}>>{$DMG_names[$DMG]}<>"; //XXX
			console_echo("{$consoleDMG} damage (before crit amp): <<#fff>>$amount<>", '#faa');
			// Aplly crit amp first (since it should be one of the more significant multipliers).
			$amount = sa($amount, "{$critAmp}%");

			console_echo("{$consoleDMG} damage (after crit amp): <<#fff>>$amount<>", '#faa');

			// Apply bias here? Not sure.

			// Apply damage modifiers (these should be affected by behaviours)
			if (isset($this->DMGs_modifiers[$DMG]))
			{
				console_echo("{$consoleDMG} damage (before mods): <<#fff>>$amount<>", '#faa');

				$this->DMGs_modifiers[$DMG][] = $amount;
				$amount = valueListToValue($this->DMGs_modifiers[$DMG]);

				console_echo("{$consoleDMG} damage (after mods): <<#fff>>$amount<>", '#faa');
			}

			// Sort out which defence types are relevant and apply those
			if (isset($this->DMGs_def[$DMG]))
			{
				console_echo("{$consoleDMG} damage (before {$DMG_names[$DMG]} defence): <<#fff>>$amount<>", '#faa');

				if (isset($this->DMGs_def_modifiers[$DMG]))
				{
					console_echo("{$consoleDMG} defence (before mods): <<#fff>>{$this->DMGs_def[$DMG]}<>", '#afa');

					$this->DMGs_def_modifiers[$DMG][] = $this->DMGs_def[$DMG];
					$this->DMGs_def[$DMG] = valueListToValue($this->DMGs_def_modifiers[$DMG]);
				}

				$amount = getBiasCalculation($amount, $this->DMGs_def[$DMG]);

				console_echo("{$consoleDMG} damage (after {$DMG_names[$DMG]} defence): <<#fff>>$amount<>", '#faa');
			}
		}

		$this->damage = array_sum($this->DMGs);

		console_echo("Total damage (before delivery defence): <<#fff>>{$this->damage}<>", '#faa');

		if (isset($this->DMGs_def[$this->DMGDL]))
		{
			$this->damage = getBiasCalculation($this->damage, $this->DMGs_def[$this->DMGDL]);

			console_echo("Total damage (after delivery defence): <<#fff>>{$this->damage}<>", '#faa');
		}
		else { console_echo('No delivery defence!', '#fda'); }

		$damageBias = getBiasCalculation($attackerBiases[TEQ_DAMAGE], $targetBiases[TEQ_DEFENCE], GBC_PERCENTAGE) . '%';

		$this->damage_modifiers[] = $damageBias;
		$this->damage_modifiers[] = $this->damage;

//		$damageBiasBoost = $this->damage * getBiasCalculation($attackerBiases[TEQ_DAMAGE], $targetBiases[TEQ_DEFENCE], GBC_DECIMAL);
		$event->rawDamage = sa($event->rawDamage, $damageBias);

//		$this->damage_modifiers[] = $this->damage + $damageBiasBoost;

		$this->damage = valueListToValue($this->damage_modifiers);

		$event->damage = round($this->damage, 1);

		$this->damage = sa($this->damage, $randomisation); // Randomisation is only factored in after the event has its value to make sure its always giving consistent and valuable feedback.

		$event->dealtDamage = $this->damage;

		console_echo("Total damage (after mods): <<#fff>>{$this->damage}<>", '#faa', CNS_ATTACK);

		///////////////////////////////////////////
		//                                      //
		//	PART VII: Do the damage            //
		//                                    //
		///////////////////////////////////////

		$this->kill = !$this->target->alterHp(0 - $this->damage);



		// Are they dead?
		if ($this->kill)
		{
//			if ($report) update_combat("<<#fff>>{$this->target->name}<> was <<#faa>>killed<> by <<#fff>>{$this->attacker->name}<>!");

			$event->killed = true;

			// Execute behaviours related to the killing of a dude
			$this->target->death($this);
			$this->attacker->kill($this);
		}

		if ($this->attacker === $player || $this->target === $player)
		{
			$player->handleEventOfInterest(EOI_ATTACK, $this);
			update_combat($event);
		}


	}

	function defer($seconds)
	{
		$this->readyTime += $seconds;
	}
}

class attackEvent
{
	public $isBaseAttack;
	public $attackerName;
	public $targetName;
	public $critPercentage;
	public $rawDamage;
	public $damage;
	public $DMGDL;
	public $dealtDamage;
	public $hit;
	public $killed = false;
	public $mainDMG;
	public $TEQT;
	public $towardsPlayer;

	public function __toString()
	{
		global $DMG_DMGDL_names;
		global $DMG_colours;
		global $TEQT_names;


		$this->rawDamage = round($this->rawDamage, 1);
		$this->dealtDamage = round($this->dealtDamage, 1);
		$rating = round(($this->damage / $this->rawDamage) * 100);

		if ($this->isBaseAttack)
		{
			if (!$this->hit) return "<<#fff>>{$this->attackerName}<> missed <<#fff>>{$this->targetName}<>.";

			$hitType = $this->killed ? 'killed' : 'hit';

			if ($this->critPercentage > 0)
			{
				$crit = 'critical <span class="fade">(+' . round($this->critPercentage) . '%)</span> ';
				$damageColour = '#f22';
			}
			else
			{
				$crit = '';
				$damageColour = '#f88';
			}

			$damageType = "<<{$DMG_colours[$this->mainDMG]}>>{$DMG_DMGDL_names[$this->mainDMG]}<>";


			$string = "<<#fff>>{$this->attackerName}<> {$hitType} <<#fff>>{$this->targetName}<> with <<{$damageColour}>>{$this->dealtDamage}<> {$crit}{$damageType} damage via a {$TEQT_names[$this->TEQT]} <<#fff>>{$DMG_DMGDL_names[$this->DMGDL]}<> attack.<br><span class=\"fade\">{$rating}% effective.</span>";
		}
		else
		{
			$direction = $this->towardsPlayer ? '<<#a00>>&#x25bc;<>' : '<<#0a0>>&#x25b2;<>';
			$string = "{$direction} +<<{$DMG_colours[$this->mainDMG]}>>{$this->dealtDamage}<> <span class=\"fade\">{$rating}%</span>";
		}

		return "{$string}";
	}

}

abstract class NPCInteraction extends DudeBehaviour
{
	public $name;
	public $description;
	public $key;

	public $owner;

	public function __construct($name, $description)
	{
		$this->name			= $name;
		$this->description	= $description;
		$this->key			= get_class($this);

		parent::__construct($description, $this->key);
	}

	/**
	 * onInovoke should be triggered when the interaction is chosen.
	 * e.g., Clicking "buy" should trigger onInvoke(); clicking "steel sword" should trigger onUse().
	 */
//	abstract function onInvoke();
	function onClick($UIN) { }

	/**
	 * onUse should be triggered when the player triggers options made available by the interaction type.
	 * e.g., Clicking "buy" should trigger onInvoke(); clicking "steel sword" should trigger onUse().
	 */
//	abstract function onUse ();
	function onItemClick ($UIN, $content) { }


	// Other triggers

	function onRegister() { }

	function onGainItem(Item $item) { }
	function onLoseItem(Item $item) { }
}

class AssetSet
{
	protected function getColour($colour, $directive = null)
	{
		if (!$directive)			return $colour;
		if (is_numeric($directive))	return tint($colour, (int) $directive);
		if (is_string($directive))	return $directive;
	}
}